/* -*- Mode: C++ -*-
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +
 + Filename:      inst-ws.cpp
 +
 + Gensym module: activex/control/wsview
 +
 + File Summmary: Implementation of CWorkspaceViewModule and DLL registration.
 +
 + Copyright (C) 1986-2017 Gensym Corporation.
 +            All Rights Reserved.
 +
 + Author(s):    jv
 +
 + Description:  This file contains functions for controlling instantiation of
 +               the control
 +               
 + 
 + Key:
 +
 + File Organization:
 +   Section:      INCLUDE FILES 
 +   Section:      DEFINES
 +   Section:      GLOBALS
 +   Section:      FUNCTION GROUP
 +      
 + External Interface:
 +
 + Dependencies:
 +
 + Notes:          This code was mostly generated by the Visual C++ Wizard
 +
 + Modifications:
 +
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      INCLUDE FILES
 %
 % Description:  All required include files are referenced here.
 %
 % Notes:
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
#include "props-ws.h"

#ifdef L_USE_COMCAT
#  include <comcat.h>
#endif // L_USE_COMCAT

#include <objsafe.h>


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      DEFINES
 %
 % Description:  Module specific macros defined in this section. 
 %
 % Notes:
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
#define GENSYM_LCID 0x0409 // english
#define MAX_LEN_CATINFO 127


#ifdef _DEBUG
#  undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      GLOBALS
 %
 % Description:  Module specific typedefs, variables, & externs defined here
 %
 % Notes:
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
CWorkspaceViewModule NEAR theApp;

const GUID CDECL BASED_CODE _tlid =
                { 0xD03BCBA5, 0x8C30, 0x4FD6, { 0xa0, 0x2e, 0x9f, 0x7b, 0xe4, 0x12, 0xfa, 0x3f } };
const WORD _wVerMajor = TW_AX_CONTROL_MAJOR_VERSION;
const WORD _wVerMinor = TW_AX_CONTROL_MINOR_VERSION;


extern BOOL initialize_logger ();
extern void close_global_streams ();


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      FUNCTION GROUP - Instance Utilities
 %
 % Description:
 %   
 %   
 % Notes:
 %
 % Modifications:
 %   usage: Modifications in this header should be restricted to mentioning
 %      the addition or deletion of functions within this section. Actual
 %      function changes should be commented in the specific function's
 %      header.
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::InitInstance - DLL initialization

BOOL CWorkspaceViewModule::InitInstance ()
{
  BOOL bInit = COleControlModule::InitInstance();

  m_InstanceChain = NULL;
  if (bInit) {
    cWorkspaces = 0;
    // TODO: Add more of your own module initialization code here.
    initialize_logger();
#ifdef _DEBUG
    set_debug_level(TOFILE);
#else
    set_debug_level(DERROR);
#endif
    dprintf(DUMP, "inst-ws InitInstance method call");
  }

  return bInit;
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::ExitInstance - DLL termination

int CWorkspaceViewModule::ExitInstance ()
{
  dprintf(DUMP, "inst-ws ExitInstance method call");
  // TODO: Add more of your own module termination code here.
  close_global_streams();
  return COleControlModule::ExitInstance();
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::GetWorkspaceNumber - workspace enumeration

int CWorkspaceViewModule::GetWorkspaceNumber (class CWorkspaceView *p_wsview)
{
  wsv_instance *new_instance;
  int id_of_new_instance;

  id_of_new_instance = ++cWorkspaces;

  new_instance = (wsv_instance *)malloc(sizeof(wsv_instance));
  // null check
  new_instance->theInstance = p_wsview;
  new_instance->session_id = GWVC_NO_TW_SESSION;
  new_instance->gateway = NULL;
  new_instance->next = m_InstanceChain;
  m_InstanceChain = new_instance;

  return id_of_new_instance;
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::DestroyMe -- called by an instance when it is being
// destroyed.  Such an event forces a kind of a poor man's garbage collection,
// where the potential garbage is a process.  If the instance which is being
// destroyed is the only instance left which was using a particular TW, we call
// TerminateProcess on that TW.
//
// Note, this is really not correct.  How many workspace views are using the TW
// is, in theory, irrelevant.  All that is supposed to matter is, is the gateway
// still running.  In fact, when TW first starts up, there is an instant during
// which no WSVs are using it.  But if stuff is up and running and workspace
// views get connected, and then all of the connected WSVs are destroyed,
// we take that as a good sign that the whole system is shutting down.
//
// In fact, we don't know if the Gateway is up or not.  Since no WSVs are using
// the TW, it's really not necessarily a sin to shut it down anyway, even if the
// gateway is still up, as long as a new TW would be started up again as needed.
// That would be the case if we called ClearTWLock and put_TWHandle on the
// gateway when the TW is destroyed.  However, for the moment, I'm afraid that
// the gateway might have been destroyed already, and I don't want to call
// methods on an instance which has been destroyed.  For now, we will live with
// the far less common bug.
//
// UPDATE, jv, 7/02/04: In Issue HQ-4820876, "G2 abort calling ShowWorkspaceWith
// Name on the WorkspaceView ActiveX control", Smart Signal ran into what I
// thought would be "the far less common bug", using VB techniques I hadn't
// thought of.  We are now going to do what I mentioned above: call ClearTWLock
// and put_TWHandle.  In order to make sure the Gateway is still there for us to
// call it, we will call an explicit AddRef when we assign the gateway, and an
// explicit Release after we've cleared the lock and the handle.
//
// There is another peculiarity.  WorkspaceViews have a member variable which
// is intended to hold the process id of the TW they are connected to.  However,
// they don't always have that information.  Only the WSV which starts up TW
// knows its pid initially.  And the only place that the other WSVs ever find
// out the pid?  Right here.  This is the logic: let's say a workspace view is
// being destroyed which knows its pid.  We need to iterate over all the other
// workspace views to see if any of them are using the same TW.  We determine
// "same TW" without involving the pid: the same TW means the same gateway, and
// the same session ID.  If we don't find any matches, that means that this was
// the last (or the only) WSV using the TW, and we should kill it (and that is
// the point of the iteration).  If we find other WSVs using the TW, then we
// must not shut down TW; but we also need to make sure that the other WSVs know
// the pid, so that when *they* are destroyed, the pid is there and we can call
// TerminateProcess on it.
//
// So, if a WSV is destroyed which *doesn't* know its pid, that must mean that
// the WSV which originally spawned the TW is still running, and therefore we
// know we don't need to shut down TW.  If the pid is its default value of
// GWVC_NO_TW_PROCESS_ID, we just return without iterating over the other
// instances.  We know we are just destroying a WSV which is piggy-backing on
// a TW spawned by a different WSV.
//
// One more note about the pid's: it suffices for only one WSV to have the pid
// at any given time, and maybe it's even conceptually simpler that way: we
// could think of one WSV holding the "shut down cookie" or something.  But I'd
// just as soon have as many WSVs know their pid's as possible, so we don't jump
// out of the loop below just because we find a second WSV which is using the
// same Telewindows as the WSV which is shutting down.

void CWorkspaceViewModule::DestroyMe (class CWorkspaceView *p_wsview,
				      HANDLE p_pid)
{
  int old_session = GWVC_NO_TW_SESSION;
  AXL_IFACE *old_gateway = NULL;
  BOOL ok_to_shut_down_tw = TRUE;
  wsv_instance *temp = m_InstanceChain;

  dprintf(DUMP, "inst-ws DestroyMe, wsview = 0x%x, pid handle = %d",
	  p_wsview, p_pid);

  // First, we attempt to locate the WSV in the chain of instances.
  while ((temp != NULL) && (temp->theInstance != p_wsview)) {
    temp = temp->next;
  }

  if (temp == NULL) {
    // Something went wrong, we can't find the instance
    dprintf(DERROR, "unable to remove 0x%x from instance chain", p_wsview);
    return;
  }

  // We've found the instance; stash away its data in local variables.
  old_session = temp->session_id;
  old_gateway = temp->gateway;

  // Too lazy to actually remove it from the list; just make it "inactive".
  temp->session_id = GWVC_NO_TW_SESSION;
  temp->gateway = NULL;
  temp->theInstance = NULL;

  // If this was "piggy-backing" on another WSV, we are done.  See above.
  if (p_pid == GWVC_NO_TW_PROCESS_ID) {
    dprintf(DETAIL, "shutting down a WSV with no PID; leaving TW alone");
    return;
  }

  // Now search for other instances which are using the same gateway with the
  // same session id.
  temp = m_InstanceChain;
  while (temp != NULL) {
    if ((temp->gateway == old_gateway) && (temp->session_id == old_session)) {
      ok_to_shut_down_tw = FALSE;
      if (temp->theInstance != NULL) {
	temp->theInstance->ReceiveTWProcId(p_pid);
      }
    }
    temp = temp->next;
  }

  if (ok_to_shut_down_tw) {
    old_gateway->ClearTWLock();
    old_gateway->put_TWHandle(0);
    old_gateway->Release();
    dprintf(PROGRESS, "killing TW process %d", p_pid);
    TerminateProcess(p_pid, 0);
  } else {
    dprintf(DETAIL, "leaving TW running because other wsv's are using it");
  }
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::SetSessionId

void CWorkspaceViewModule::SetSessionId (class CWorkspaceView *p_wsview,
					 int p_session_id)
{
  wsv_instance *temp = m_InstanceChain;

  dprintf(DUMP, "inst-ws SetSessionId, wsview = 0x%x, session id = %d",
	  p_wsview, p_session_id);

  while (temp != NULL) {
    if (temp->theInstance == p_wsview) {
      dprintf(PROGRESS, "instance setting session id for 0x%x to %d",
	      (unsigned int) p_wsview, p_session_id);
      temp->session_id = p_session_id;
      temp = NULL;  // break out of loop
    } else {
      temp = temp->next;
    }
  }
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::SetGateway

void CWorkspaceViewModule::SetGateway (class CWorkspaceView *p_wsview,
				       AXL_IFACE *p_gateway)
{
  wsv_instance *temp = m_InstanceChain;

  dprintf(DUMP, "inst-ws SetGateway, wsview = 0x%x, gateway = 0x%x",
	  p_wsview, p_gateway);

  while (temp != NULL) {
    if (temp->theInstance == p_wsview) {
      dprintf(PROGRESS, "instance setting gateway for 0x%x to 0x%x",
	      (unsigned int) p_wsview, (unsigned int) p_gateway);
      p_gateway->AddRef();
      temp->gateway = p_gateway;
      temp = NULL;  // break out of loop
    } else {
      temp = temp->next;
    }
  }
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::BroadcastTWConnection

void CWorkspaceViewModule::BroadcastTWConnection (AXL_IFACE *p_gw, int p_session)
{
  wsv_instance *temp = m_InstanceChain;

  while (temp != NULL) {
    if (temp->theInstance != NULL) {
      temp->theInstance->NoteTWConnection(p_gw, p_session);
    }
    temp = temp->next;
  }
}


////////////////////////////////////////////////////////////////////////////
// CWorkspaceViewModule::BroadcastTWShutdown

void CWorkspaceViewModule::BroadcastTWShutdown (AXL_IFACE *p_gw, int p_session)
{
  wsv_instance *temp = m_InstanceChain;

  while (temp != NULL) {
    if (temp->theInstance != NULL) {
      temp->theInstance->NoteTWShutdown(p_gw, p_session);
    }
    temp = temp->next;
  }
}


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      FUNCTION GROUP - Self-Registration 
 %
 % Description:
 %   Not entirely clear, but these functions get called when the control is
 %   called upon to register itself (e.g., by regsvr32)
 %   
 % Notes:
 %   I (jv) "inherited" these functions, and have not modified them, except to
 %   add the dprintfs.  The first attempt to put Telewindows into an ActiveX
 %   control was a project called "TWHack", which was initiated by Carl Shapiro
 %   using the Visual Studio MFC ActiveX Control wizard.  I believe this code
 %   was generated by the wizard, although Carl may have edited it somewhat.
 %   TWHack turned into TWAX, which was the baseline for starting the Workspace
 %   View ActiveX control.
 %
 %   Running "regsvr32 /c WorkspaceView.ocx" causes DllRegisterServer to be
 %   called, which in turn calls CreateComponentCategory and RegisterCLSIDIn
 %   Category.  Running regsvr32 with /u causes DllUnregisterServer to be
 %   called, which calls UnRegisterCLSIDInCategory.  As far as I can see,
 %   these functions never get called in at any other time.
 %
 %   One other thing to note: these are plain old C functions, having nothing
 %   in particular to do with the CWorkspaceViewModule class.  Maybe they should
 %   be moved into a separate file with a ".c" extension.
 %
 % Modifications:
 %   usage: Modifications in this header should be restricted to mentioning
 %      the addition or deletion of functions within this section. Actual
 %      function changes should be commented in the specific function's
 %      header.
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

#ifdef L_USE_COMCAT
// Helper function to create a component category and associated description
HRESULT CreateComponentCategory(CATID catid, WCHAR *catDescription)
{
  dprintf(DUMP, "inst-ws CreateComponentCategory function call");
  ICatRegister *pcr = NULL;
  HRESULT hr = S_OK;

  hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
  if (FAILED(hr)) {
    return hr;
  }

  // Make sure the HKCR\Component Categories\{..catid...}
  // key is registered
  CATEGORYINFO catinfo;
  catinfo.catid = catid;
  catinfo.lcid = GENSYM_LCID;

  // Make sure the provided description is not too long.
  // Only copy the first characters if it is
  int len = wcslen(catDescription);
  if (len > MAX_LEN_CATINFO) {
    len = MAX_LEN_CATINFO;
  }
  wcsncpy(catinfo.szDescription, catDescription, len);
  // Make sure the description is null terminated
  catinfo.szDescription[len] = '\0';

  hr = pcr->RegisterCategories(1, &catinfo);
  pcr->Release();

  return hr;
}


// Helper function to register a CLSID as belonging to a component category
HRESULT RegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
  dprintf(DUMP, "inst-ws RegisterCLSIDInCategory function call");
  // Register your component categories information.
  ICatRegister *pcr = NULL;
  HRESULT hr = S_OK;
  hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pcr);
  if (SUCCEEDED(hr)) {
    // Register this category as being "implemented" by the class.
    CATID rgcatid[1];
    rgcatid[0] = catid;
    hr = pcr->RegisterClassImplCategories(clsid, 1, rgcatid);
  }

  if (pcr != NULL) {
    pcr->Release();
  }
  
  return hr;
}


// Helper function to unregister a CLSID as belonging to a component category
HRESULT UnRegisterCLSIDInCategory(REFCLSID clsid, CATID catid)
{
  dprintf(DUMP, "inst-ws UnRegisterCLSIDInCategory function call");
  ICatRegister *pcr = NULL;
  HRESULT hr = S_OK;
  hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr, 
			NULL, CLSCTX_INPROC_SERVER,
			IID_ICatRegister, (void**)&pcr);
  if (SUCCEEDED(hr)) {
    // Unregister this category as being "implemented" by the class.
    CATID rgcatid[1];
    rgcatid[0] = catid;
    hr = pcr->UnRegisterClassImplCategories(clsid, 1, rgcatid);
  }

  if (pcr != NULL) {
    pcr->Release();
  }
  
  return hr;
}
#endif // L_USE_COMCAT


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry.  Called by regsvr32
// when registering the control.

STDAPI DllRegisterServer (void)
{
  HRESULT hr = NOERROR;
  AFX_MANAGE_STATE(_afxModuleAddrThis);

  dprintf(DUMP, "inst-ws DllRegisterServer function call");
  if (!AfxOleRegisterTypeLib(AfxGetInstanceHandle(), _tlid)) {
    return ResultFromScode(SELFREG_E_TYPELIB);
  }

  if (!COleObjectFactoryEx::UpdateRegistryAll(TRUE)) {
    return ResultFromScode(SELFREG_E_CLASS);
  }

  hr = CreateComponentCategory(CATID_SafeForScripting,
                               L"Controls that are safely scriptable");
  if (FAILED(hr)) {
    dprintf(DERROR, "Failed to create component category (scriptable)!");
  }

  hr = CreateComponentCategory(CATID_SafeForInitializing,
                               L"Controls safely initializable from persistent data");
  if (FAILED (hr)) {
    dprintf(DERROR, "Failed to create component category (persistence)!");
  }

  hr = RegisterCLSIDInCategory(CWorkspaceView::guid, CATID_SafeForScripting);
  if (FAILED(hr)) {
    dprintf(DERROR, "Failed to register control as safe for scripting!");
  }

  hr = RegisterCLSIDInCategory(CWorkspaceView::guid, CATID_SafeForInitializing);
  if (FAILED(hr)) {
    dprintf(DERROR, "Failed to register control as safe for initializing!");
  }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry.  Called by
// regsvr32 when unregistering the control ("/u" flag to regsvr32).

STDAPI DllUnregisterServer (void)
{
  AFX_MANAGE_STATE(_afxModuleAddrThis);

  dprintf(DUMP, "inst-ws DllUnregisterServer function call");
  if (!AfxOleUnregisterTypeLib(_tlid, _wVerMajor, _wVerMinor)) {
    return ResultFromScode(SELFREG_E_TYPELIB);
  }

  if (!COleObjectFactoryEx::UpdateRegistryAll(FALSE)) {
    return ResultFromScode(SELFREG_E_CLASS);
  }

  // This removes the Implemented Categories from the control's registration.
  // Only need to unregister them if registered above.
  // WARNING: Unregister the control before removing the L_USE_COMCAT definition.
  HRESULT hr = NOERROR;
  hr = UnRegisterCLSIDInCategory(CWorkspaceView::guid, CATID_SafeForScripting);
  hr = UnRegisterCLSIDInCategory(CWorkspaceView::guid, CATID_SafeForInitializing);

  if (hr == 0x80070002) {
    // This is a file not found error.  I'm not sure what file it's looking for.
    // In any case, the unregister seems to go fine, so I want it to say it
    // succeeded; therefore, return NOERROR.
    return NOERROR;
  }

  return hr;
}

/* This is an available place to make note of the settings to use to debug the
   ActiveX controls.  I got sick and tired of typing these values.  Maybe now I
   can just cut and paste if I need to enter them again.

     C:\Program Files\Microsoft Visual Studio\VB98\VB6.EXE
     C:\unix\bt\jv\src\activex\G2Com\demos\VBDemo
     /runexit WorkspaceViewDemo

     c:\unix\bt\jv\src\activex\control\examples
     c:\unix\bt\jv\src\activex\control\examples\wsview.html

     C:\Program Files\Microsoft Visual Studio\Common\Tools\TSTCON32.EXE
     tw.tcs

     /runexit GensymAxDemo
 */
