/* -*- Mode: C++ -*-
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 +
 + Filename:      logger.cpp
 +
 + Gensym module: activex/control/src
 +
 + File Summmary: Message logger for Gensym ActiveX Controls
 +
 + Copyright (C) 1986-2017 Gensym Corporation.
 +            All Rights Reserved.
 +
 + Author(s):     jv
 +
 + Description:   This file contains functions for letting the control
 +                communicate with the user.  This file is used by both the
 +                Telewindows ActiveX Control and the Workspace View Control.
 +
 + File Organization:
 +   Section:      INCLUDE FILES
 +   Section:      DEFINES
 +   Section:      GLOBALS
 +   Section:      FUNCTION GROUP
 +
 + External Interface:
 +
 + Dependencies:
 +
 + Notes:          This is all hand-written code.  It was not generated by
 +                 Visual Studio or Visual C++
 +
 + Modifications:
 +
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      INCLUDE FILES
 %
 % Description:  All required include files are referenced here.
 %
 % Notes:
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

#include <stdio.h>
#ifdef WORKSPACE_VIEW_CONTROL
#  include "afx-ws.h"
#  include "defs-ws.h"
#else
#  include "gafx.h"
#  include "defs-twax.h"
#endif /* WORKSPACE_VIEW_CONTROL */

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      DEFINES
 %
 % Description:  Module specific macros defined in this section.
 %
 % Notes:
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
// First three characters used for logfile name
#ifdef WORKSPACE_VIEW_CONTROL
#  define TEMP_FILE_PREFIX   TEXT("gws")
#else
#  define TEMP_FILE_PREFIX   TEXT("gax")
#endif

#define NO_OUTPUT          0
#define DEBUG_WINDOW       1
#define USE_STDERR         2
#define WRITE_TO_FILE      4
#define REDIRECT_TO_FILE   6  // stderr & write_to_file
#define WINDOW_AND_LOGGING 7  // redirect & debug_window

#define DPRINTF_MAX_LINE_LENGTH 1024
#define DPRINTF_TIME_STRING_LENGTH 64

#define TIME_DELIMITER _T(": ")
#define LENGTH_TIME_DELIMITER 2

/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      GLOBALS
 %
 % Description:  Module specific typedefs, variables, & externs defined here
 %
 % Notes:
 %   There is currently no way to turn off s_use_timestamps.  -jv, 1/16/04
 %
 % Modifications:
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/
static FILE *s_outstream = NULL;
static BOOL s_did_initialization = FALSE;
static BOOL s_use_timestamps = TRUE;

#if defined(_DEBUG) || defined(_VERBOSE)
// dump EVERYTHING to the log file
static short s_debug_level = TOFILE + 1;
// if we're in the debugger, send stuff to the debug window
static short s_output_type = DEBUG_WINDOW;
#else
// by default, be relatively quiet;
static short s_debug_level = DERROR;
// by default, don't send output anywhere
static short s_output_type = NO_OUTPUT;
#endif


/*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 %
 % Section:      FUNCTION GROUP - Logging utilities
 %
 % Description:
 %   These functions provide some rudimentary way to communicate with the user.
 %
 % Notes:
 %
 % Modifications:
 %   usage: Modifications in this header should be restricted to mentioning
 %      the addition or deletion of functions within this section. Actual
 %      function changes should be commented in the specific function's
 %      header.
 %
 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*/

/*************************************************************************
*
* void dprintf (short, char *, ...)
*
* Purpose: Formats a string and adds it to the listbox, but only if the
*     specified debug level indicates we shouldn't ignore it, and only if
*     s_output_type indicates that we should try to do some output.  The string
*     should not contain '\n' characters; those do not work properly inside the
*     list box.  This function will append a newline by default when writing to
*     a stream.
*
*************************************************************************/
void dprintf (short debug_level, char *format_plus_va_list, ...)
{
  static TCHAR buf[DPRINTF_MAX_LINE_LENGTH];
  int room_left_in_buf = DPRINTF_MAX_LINE_LENGTH - 1;
  time_t now_universal_time;
  struct tm *now_local_time_structure;
  TCHAR *format_string, *bufptr = buf;
  int chars_written = 0, accumulated_strlen = 0;

  if (s_debug_level < debug_level) return;
  if (s_output_type == NO_OUTPUT) return;

  now_universal_time = time(NULL);
  if (now_universal_time != -1) {
    now_local_time_structure = localtime(&now_universal_time);
    if (now_local_time_structure) {
      chars_written = (int) _tcsftime(bufptr, room_left_in_buf,
                                     _T("%Y-%m-%d %H:%M:%S"),
                                     now_local_time_structure);
    }
  }
  if (chars_written > 0) {
    room_left_in_buf -= chars_written;
    accumulated_strlen += chars_written;
    bufptr += chars_written;
  } else {
    OutputDebugString(_T("Warning: error formatting the following message.\n"));
  }

  chars_written = 0;
  if (room_left_in_buf > LENGTH_TIME_DELIMITER) {
    _tcsncat(bufptr, TIME_DELIMITER, room_left_in_buf);
    chars_written = LENGTH_TIME_DELIMITER;
  }
  if (chars_written > 0) {
    room_left_in_buf -= chars_written;
    accumulated_strlen += chars_written;
    bufptr += chars_written;
  } else {
    OutputDebugString(_T("Warning: error formatting the following message.\n"));
  }

#ifdef UNICODE
#  error "UNICODE BUILD NOT REALLY SUPPORTED!!!"
  format_string = (TCHAR *) malloc(strlen(ascii_format_string) * sizeof(TCHAR));
#else
  format_string = format_plus_va_list;
#endif

  chars_written = _vsntprintf(bufptr, room_left_in_buf, format_string,
                              (va_list)(&format_plus_va_list+1));
  if (chars_written > 0) {
    room_left_in_buf -= chars_written;
    accumulated_strlen += chars_written;
    bufptr += chars_written;
  } else {
    OutputDebugString(_T("Warning: error formatting the following message.\n"));
  }
  if (room_left_in_buf < 1) {
    // Overwrite the last character with the newline.
    accumulated_strlen--;
  }
  buf[accumulated_strlen] = '\n';
  buf[++accumulated_strlen] = 0;

  if (s_output_type & DEBUG_WINDOW) {
    OutputDebugString(buf);
  }
  if (s_output_type & USE_STDERR) {
    _fputts(buf, stderr);
    fflush(stderr);
  }
  if (s_output_type & WRITE_TO_FILE) {
    _fputts(buf, s_outstream);
    fflush(s_outstream);
  }
}


/***************************************************************************\
*  void close_global_streams ()
*
*  PURPOSE: cleanly shut down any streams we've opened
*
*  COMMENTS: Once again, the stream code is borrowed from the ext/c code,
*     and perhaps does not need to be so elaborate.
*
****************************************************************************/
void close_global_streams ()
{
  if (s_outstream != NULL) {
    fclose(s_outstream);
  }
  s_did_initialization = FALSE;
}


/***************************************************************************\
*  void set_debug_level (short)
*
*  PURPOSE: take a short int, and use it to set the level of verbosity for
*     the control.
*
*  COMMENTS:
*
****************************************************************************/
void set_debug_level (short new_level)
{
  s_debug_level = new_level;
  dprintf(PROGRESS, "set debug level to %d", s_debug_level);
}

/***************************************************************************\
*  void set_minimum_debug_level (short)
*
*  PURPOSE: take a short int, and use it to turn up the level of verbosity for
*     the control.  If the verbosity is already higher before this call, it
*     is not changed.
*
*  COMMENTS:
*
****************************************************************************/
void set_minimum_debug_level (short new_level)
{
  if (new_level > s_debug_level) {
    set_debug_level(new_level);
  }
}

/***************************************************************************\
*  BOOL parse_and_set_debug_level (TCHAR *)
*
*  PURPOSE: take a string which may be symbolic or numeric, and use it to set
*     the level of verbosity for the plugin.
*
*  COMMENTS:
*
****************************************************************************/
BOOL parse_and_set_debug_level (TCHAR *requested_level)
{
  int parsed_debug_level;

  parsed_debug_level = _ttoi(requested_level);
  dprintf(PROGRESS, "parsed debug level to %d", parsed_debug_level);
  if (parsed_debug_level == 0) {
    // atoi returns 0 for non-numeric values; first, check if the user
    // actually did pass in zero
    if (_tcscmp(requested_level, TEXT("0")) == 0) {
      parsed_debug_level = DERROR;
    } else if (_tcsicmp(requested_level, TEXT("derror")) == 0) {
      parsed_debug_level = DERROR;
    } else if (_tcsicmp(requested_level, TEXT("progress")) == 0) {
      parsed_debug_level = PROGRESS;
    } else if (_tcsicmp(requested_level, TEXT("detail")) == 0) {
      parsed_debug_level = DETAIL;
    } else if (_tcsicmp(requested_level, TEXT("dump")) == 0) {
      parsed_debug_level = DUMP;
    } else if (_tcsicmp(requested_level, TEXT("tofile")) == 0) {
      parsed_debug_level = TOFILE;
    } else {
      dprintf(ALWAYS, "Parse error: verbosity level %s not understood",
              requested_level);
      return FALSE;
    }
  } else if (parsed_debug_level <= DERROR) {
    parsed_debug_level = DERROR;
  } else if (parsed_debug_level <= PROGRESS) {
    parsed_debug_level = PROGRESS;
  } else if (parsed_debug_level <= DETAIL) {
    parsed_debug_level = DETAIL;
  } else if (parsed_debug_level <= DUMP) {
    parsed_debug_level = DUMP;
  } else {
    parsed_debug_level = TOFILE;
  }

  set_debug_level((short)parsed_debug_level);
  return TRUE;
}

/***************************************************************************\
*  void write_version_information ()
*
*  PURPOSE: write out version information to whoever is listening
*
*  COMMENTS: this is probably the only dprintf that should have "higher-than-
*    error" "ALWAYS" priority.
*  We have two different ways of building the TW Control.  We believe and hope
*  that they are equivalent.  However, only the version built by runmake
*  should ever leave the building.  To help us verify that, anything built
*  by the Visual Studio project will always output with "v" as the build-
*  type... i.e., 6.2v0 instead of 6.2r0.  Another thing this can be used
*  for is to sanity-check is that your changes are being used at all...
*  whichever method you're using to build, just build the "other" way and
*  verify that the version written to the log file changes.  If it does,
*  go back to your regular build and then test again.  If the version
*  reverts, you're getting the version you expect to.
*
****************************************************************************/
void write_version_information ()
{
  char release_type = 'z';

  switch (TW_AX_CONTROL_RELEASE_QUALITY) {
  case TW_AX_CONTROL_CRELEASE:
  case TW_AX_CONTROL_PATCH:
    release_type = 'r';
    break;
  case TW_AX_CONTROL_BETA:
    release_type = 'b';
    break;
  case TW_AX_CONTROL_ALPHA:
    release_type = 'a';
    break;
  case TW_AX_CONTROL_PRERELEASE:
    release_type = 'p';
  }

#ifdef WORKSPACE_VIEW_CONTROL
  dprintf(ALWAYS, "Gensym Workspace View ActiveX Control");
#else
  dprintf(ALWAYS, "Gensym Telewindows ActiveX Control");
#endif
  dprintf(ALWAYS, "  Version %d (%s)%s",
          TW_AX_CONTROL_MAJOR_VERSION,
          TW_AX_CONTROL_BUILD_ID_STRING, TW_AX_CONTROL_PATCH_STRING);

#ifdef _DEBUG
#  ifdef MFGEN
  dprintf(ALWAYS, "intelnt-o debuggable build; debug level = %d", s_debug_level);
#  else
  dprintf(ALWAYS, "vstudio Debug build; debug level = %d", s_debug_level);
#  endif
#else
#  ifdef MFGEN
  // the release version; do not print anything unless we are in a verbose mode
  dprintf(DETAIL, "intelnt-opt optimized build");
#  else
  dprintf(ALWAYS, "Release build");
#  endif
#endif
}

/***************************************************************************\
*  TCHAR *filename_for_logfile ()
*
*  PURPOSE: finds an appropriate logfile, returns its name
*
*  COMMENTS:
*       Unlike G2/TW, we're happy just using the default tmpfile name, which
*    will contain a ".tmp" suffix.  We avoid a lot of the pain of constructing
*    the filename by giving in on that point.
*
****************************************************************************/
TCHAR *filename_for_logfile ()
{
  UINT got_temp_name;
  TCHAR *directory, *filename;

  directory = (TCHAR *)malloc(MAX_PATH * sizeof(TCHAR));
  if (!directory) {
    MessageBox(NULL, OUT_OF_MEMORY_MSG, _T("Error"), MB_OK | MB_ICONINFORMATION);
    return NULL;
  }
  if (GetTempPath(MAX_PATH, directory) == 0) {
    // whatever
    _tcscpy(directory, DEFAULT_LOGFILE_DIRECTORY);
  }

  filename = (TCHAR *)malloc((MAX_PATH + 1) * sizeof(TCHAR));
  got_temp_name = GetTempFileName(directory, TEMP_FILE_PREFIX, 0, filename);
  free(directory);
  if (got_temp_name == 0) {
    MessageBox(NULL, NO_LOGFILE_MSG, _T("Error"), MB_OK | MB_ICONINFORMATION);
    return NULL;
  }

  return filename;
}


/***************************************************************************\
*  BOOL open_logfile (TCHAR *filename)
*
*  PURPOSE: opens the requested logfile, stores the file descriptor
*    in a global variable, and reroutes stdout and stderr to the file.
*
*  COMMENTS: some code lifted from default G2/TW logging in ext/c/msmain.c.
*    There are some comments there about things working differently under
*    Windows 95/98, which surely is important for the plugin, but get things
*    going under W2K first.
*
****************************************************************************/
BOOL open_logfile (TCHAR *filename)
{
  s_outstream = _tfopen(filename, _T("w"));
  if (s_outstream == NULL) {
    MessageBox(NULL, NO_LOGFILE_MSG, _T("Error"), MB_OK | MB_ICONINFORMATION);
    return FALSE;
  }
  s_output_type |= WRITE_TO_FILE;
  return TRUE;
}


/***************************************************************************\
*  BOOL initialize_logger_with_logfile (TCHAR *logfile_name)
*
*  PURPOSE:
*
*  COMMENTS: Note, here rval defaults to FALSE, whereas in the other function,
*    it is TRUE!  That is because if you're asking us to initialize just in
*    general, and we already did, everything is groovy; but if you specifically
*    ask for a logfile by name, and we don't open it, then that is a failure.
*
****************************************************************************/
BOOL initialize_logger_with_logfile (TCHAR *logfile_name)
{
  BOOL rval = FALSE;

  if (!s_did_initialization) {
    rval = open_logfile(logfile_name);
    if (rval) {
      write_version_information();
      s_did_initialization = TRUE;
    }
  }
  return rval;
}


/***************************************************************************\
*  BOOL initialize_logger ()
*
*  PURPOSE:
*
*  COMMENTS:
*
****************************************************************************/
BOOL initialize_logger ()
{
  TCHAR *logfile_name;
  BOOL rval;

  if (s_did_initialization) {
    return TRUE;
  }
  logfile_name = filename_for_logfile();
  rval = initialize_logger_with_logfile(logfile_name);
  free(logfile_name);
  return rval;
}
