

Terminals which are not used:

   xOBJECT
   OPERATOR
   PUNCTUATOR
   LITERAL
   IDENTIFIER
   KEYWORD
   LITERAL_DECINT
   LITERAL_HEXINT
   LITERAL_OCTINT
   LITERAL_FP
   LITERAL_CHAR
   LITERAL_CHARHEX
   LITERAL_CHAROCT
   LITERAL_STRING
   NEG




token types:
 type -1 is $
 type 37 is '%'
 type 38 is '&'
 type 40 is '('
 type 41 is ')'
 type 42 is '*'
 type 43 is '+'
 type 44 is ','
 type 45 is '-'
 type 47 is '/'
 type 58 is ':'
 type 59 is ';'
 type 60 is '<'
 type 61 is '='
 type 62 is '>'
 type 91 is '['
 type 93 is ']'
 type 94 is '^'
 type 123 is '{'
 type 124 is '|'
 type 125 is '}'
 type 126 is '~'
 type 256 is error
 type 258 is xANY
 type 259 is xATTRIBUTE
 type 260 is xBOOLEAN
 type 261 is xCASE
 type 262 is xCHAR
 type 263 is xCONST
 type 264 is xCONTEXT
 type 265 is xDEFAULT
 type 266 is xDOUBLE
 type 267 is xENUM
 type 268 is xEXCEPTION
 type 269 is xFALSE
 type 270 is xFLOAT
 type 271 is xIN
 type 272 is xINOUT
 type 273 is xINTERFACE
 type 274 is xLONG
 type 275 is xMODULE
 type 276 is xOBJECT
 type 277 is xOCTET
 type 278 is xONEWAY
 type 279 is xOUT
 type 280 is xRAISES
 type 281 is xREADONLY
 type 282 is xSEQUENCE
 type 283 is xSHORT
 type 284 is xSTRING
 type 285 is xSTRUCT
 type 286 is xSWITCH
 type 287 is xTRUE
 type 288 is xTYPEDEF
 type 289 is xUNSIGNED
 type 290 is xUNION
 type 291 is xVOID
 type 292 is OPERATOR
 type 293 is PUNCTUATOR
 type 294 is LITERAL
 type 295 is IDENTIFIER
 type 296 is KEYWORD
 type 297 is LITERAL_DECINT
 type 298 is LITERAL_HEXINT
 type 299 is LITERAL_OCTINT
 type 300 is LITERAL_FP
 type 301 is LITERAL_CHAR
 type 302 is LITERAL_CHARHEX
 type 303 is LITERAL_CHAROCT
 type 304 is LITERAL_STRING
 type 305 is DOUBLE_COLON
 type 306 is DOUBLE_LT
 type 307 is DOUBLE_GT
 type 308 is FLOATING_PT_LITERAL
 type 309 is CHARACTER_LITERAL
 type 310 is STRING_LITERAL
 type 311 is INTEGER_LITERAL
 type 312 is xIDENTIFIER
 type 313 is NEG


state 0

    xCONST	shift, and go to state 1
    xENUM	shift, and go to state 2
    xEXCEPTION	shift, and go to state 3
    xINTERFACE	shift, and go to state 4
    xMODULE	shift, and go to state 5
    xSTRUCT	shift, and go to state 6
    xTYPEDEF	shift, and go to state 7
    xUNION	shift, and go to state 8

    specification	go to state 9
    definition	go to state 10
    module	go to state 11
    interface	go to state 12
    interface_dcl	go to state 13
    forward_dcl	go to state 14
    interface_header	go to state 15
    const_dcl	go to state 16
    type_dcl	go to state 17
    struct_type	go to state 18
    union_type	go to state 19
    enum_type	go to state 20
    except_dcl	go to state 21



state 1

    const_dcl  ->  xCONST . const_type xIDENTIFIER '=' const_exp   (rule 29)

    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 32
    const_type	go to state 33
    floating_pt_type	go to state 34
    integer_type	go to state 35
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 42
    boolean_type	go to state 43
    string_type	go to state 44



state 2

    enum_type  ->  xENUM . xIDENTIFIER '{' aux_4 '}'   (rule 132)

    xIDENTIFIER	shift, and go to state 45



state 3

    except_dcl  ->  xEXCEPTION . xIDENTIFIER '{' '}'   (rule 148)
    except_dcl  ->  xEXCEPTION . xIDENTIFIER '{' aux_7 '}'   (rule 149)

    xIDENTIFIER	shift, and go to state 46



state 4

    forward_dcl  ->  xINTERFACE . xIDENTIFIER   (rule 12)
    interface_header  ->  xINTERFACE . xIDENTIFIER   (rule 13)
    interface_header  ->  xINTERFACE . xIDENTIFIER inheritance_spec   (rule 14)

    xIDENTIFIER	shift, and go to state 47



state 5

    module  ->  xMODULE . xIDENTIFIER '{' definition '}'   (rule 8)

    xIDENTIFIER	shift, and go to state 48



state 6

    struct_type  ->  xSTRUCT . xIDENTIFIER '{' member_list '}'   (rule 114)

    xIDENTIFIER	shift, and go to state 49



state 7

    type_dcl  ->  xTYPEDEF . type_declarator   (rule 69)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 53
    type_declarator	go to state 54
    type_spec	go to state 55
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    union_type	go to state 67
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70



state 8

    union_type  ->  xUNION . xIDENTIFIER xSWITCH '(' switch_type_spec ')' '{' switch_body '}'   (rule 118)

    xIDENTIFIER	shift, and go to state 71



state 9

    specification  ->  specification . definition   (rule 2)

    $   	shift, and go to state 293
    xCONST	shift, and go to state 1
    xENUM	shift, and go to state 2
    xEXCEPTION	shift, and go to state 3
    xINTERFACE	shift, and go to state 4
    xMODULE	shift, and go to state 5
    xSTRUCT	shift, and go to state 6
    xTYPEDEF	shift, and go to state 7
    xUNION	shift, and go to state 8

    definition	go to state 72
    module	go to state 11
    interface	go to state 12
    interface_dcl	go to state 13
    forward_dcl	go to state 14
    interface_header	go to state 15
    const_dcl	go to state 16
    type_dcl	go to state 17
    struct_type	go to state 18
    union_type	go to state 19
    enum_type	go to state 20
    except_dcl	go to state 21



state 10

    specification  ->  definition .   (rule 1)

    $default	reduce using rule 1 (specification)



state 11

    definition  ->  module . ';'   (rule 7)

    ';' 	shift, and go to state 73



state 12

    definition  ->  interface . ';'   (rule 6)

    ';' 	shift, and go to state 74



state 13

    interface  ->  interface_dcl .   (rule 9)

    $default	reduce using rule 9 (interface)



state 14

    interface  ->  forward_dcl .   (rule 10)

    $default	reduce using rule 10 (interface)



state 15

    interface_dcl  ->  interface_header . '{' interface_body '}'   (rule 11)

    '{' 	shift, and go to state 75



state 16

    definition  ->  const_dcl . ';'   (rule 4)

    ';' 	shift, and go to state 76



state 17

    definition  ->  type_dcl . ';'   (rule 3)

    ';' 	shift, and go to state 77



state 18

    type_dcl  ->  struct_type .   (rule 70)

    $default	reduce using rule 70 (type_dcl)



state 19

    type_dcl  ->  union_type .   (rule 71)

    $default	reduce using rule 71 (type_dcl)



state 20

    type_dcl  ->  enum_type .   (rule 72)

    $default	reduce using rule 72 (type_dcl)



state 21

    definition  ->  except_dcl . ';'   (rule 5)

    ';' 	shift, and go to state 78



state 22

    boolean_type  ->  xBOOLEAN .   (rule 111)

    $default	reduce using rule 111 (boolean_type)



state 23

    char_type  ->  xCHAR .   (rule 110)

    $default	reduce using rule 110 (char_type)



state 24

    floating_pt_type  ->  xDOUBLE .   (rule 99)

    $default	reduce using rule 99 (floating_pt_type)



state 25

    floating_pt_type  ->  xFLOAT .   (rule 98)

    $default	reduce using rule 98 (floating_pt_type)



state 26

    signed_long_int  ->  xLONG .   (rule 104)

    $default	reduce using rule 104 (signed_long_int)



state 27

    signed_short_int  ->  xSHORT .   (rule 105)

    $default	reduce using rule 105 (signed_short_int)



state 28

    string_type  ->  xSTRING . '<' positive_int_const '>'   (rule 138)
    string_type  ->  xSTRING .   (rule 139)

    '<' 	shift, and go to state 79

    $default	reduce using rule 139 (string_type)



state 29

    unsigned_long_int  ->  xUNSIGNED . xLONG   (rule 108)
    unsigned_short_int  ->  xUNSIGNED . xSHORT   (rule 109)

    xLONG	shift, and go to state 80
    xSHORT	shift, and go to state 81



state 30

    scoped_name  ->  DOUBLE_COLON . xIDENTIFIER   (rule 27)

    xIDENTIFIER	shift, and go to state 82



state 31

    scoped_name  ->  xIDENTIFIER .   (rule 26)

    $default	reduce using rule 26 (scoped_name)



state 32

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    const_type  ->  scoped_name .   (rule 35)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 35 (const_type)



state 33

    const_dcl  ->  xCONST const_type . xIDENTIFIER '=' const_exp   (rule 29)

    xIDENTIFIER	shift, and go to state 84



state 34

    const_type  ->  floating_pt_type .   (rule 33)

    $default	reduce using rule 33 (const_type)



state 35

    const_type  ->  integer_type .   (rule 30)

    $default	reduce using rule 30 (const_type)



state 36

    integer_type  ->  signed_int .   (rule 100)

    $default	reduce using rule 100 (integer_type)



state 37

    signed_int  ->  signed_long_int .   (rule 102)

    $default	reduce using rule 102 (signed_int)



state 38

    signed_int  ->  signed_short_int .   (rule 103)

    $default	reduce using rule 103 (signed_int)



state 39

    integer_type  ->  unsigned_int .   (rule 101)

    $default	reduce using rule 101 (integer_type)



state 40

    unsigned_int  ->  unsigned_long_int .   (rule 106)

    $default	reduce using rule 106 (unsigned_int)



state 41

    unsigned_int  ->  unsigned_short_int .   (rule 107)

    $default	reduce using rule 107 (unsigned_int)



state 42

    const_type  ->  char_type .   (rule 31)

    $default	reduce using rule 31 (const_type)



state 43

    const_type  ->  boolean_type .   (rule 32)

    $default	reduce using rule 32 (const_type)



state 44

    const_type  ->  string_type .   (rule 34)

    $default	reduce using rule 34 (const_type)



state 45

    enum_type  ->  xENUM xIDENTIFIER . '{' aux_4 '}'   (rule 132)

    '{' 	shift, and go to state 85



state 46

    except_dcl  ->  xEXCEPTION xIDENTIFIER . '{' '}'   (rule 148)
    except_dcl  ->  xEXCEPTION xIDENTIFIER . '{' aux_7 '}'   (rule 149)

    '{' 	shift, and go to state 86



state 47

    forward_dcl  ->  xINTERFACE xIDENTIFIER .   (rule 12)
    interface_header  ->  xINTERFACE xIDENTIFIER .   (rule 13)
    interface_header  ->  xINTERFACE xIDENTIFIER . inheritance_spec   (rule 14)

    ':' 	shift, and go to state 87

    '{' 	reduce using rule 13 (interface_header)
    $default	reduce using rule 12 (forward_dcl)

    inheritance_spec	go to state 88



state 48

    module  ->  xMODULE xIDENTIFIER . '{' definition '}'   (rule 8)

    '{' 	shift, and go to state 89



state 49

    struct_type  ->  xSTRUCT xIDENTIFIER . '{' member_list '}'   (rule 114)

    '{' 	shift, and go to state 90



state 50

    any_type  ->  xANY .   (rule 113)

    $default	reduce using rule 113 (any_type)



state 51

    octet_type  ->  xOCTET .   (rule 112)

    $default	reduce using rule 112 (octet_type)



state 52

    sequence_type  ->  xSEQUENCE . '<' simple_type_spec ',' positive_int_const '>'   (rule 136)
    sequence_type  ->  xSEQUENCE . '<' simple_type_spec '>'   (rule 137)

    '<' 	shift, and go to state 91



state 53

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    simple_type_spec  ->  scoped_name .   (rule 78)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 78 (simple_type_spec)



state 54

    type_dcl  ->  xTYPEDEF type_declarator .   (rule 69)

    $default	reduce using rule 69 (type_dcl)



state 55

    type_declarator  ->  type_spec . declarators   (rule 73)

    xIDENTIFIER	shift, and go to state 92

    declarators	go to state 93
    declarator	go to state 94
    simple_declarator	go to state 95
    complex_declarator	go to state 96
    array_declarator	go to state 97



state 56

    type_spec  ->  simple_type_spec .   (rule 74)

    $default	reduce using rule 74 (type_spec)



state 57

    simple_type_spec  ->  base_type_spec .   (rule 76)

    $default	reduce using rule 76 (simple_type_spec)



state 58

    simple_type_spec  ->  template_type_spec .   (rule 77)

    $default	reduce using rule 77 (simple_type_spec)



state 59

    type_spec  ->  constr_type_spec .   (rule 75)

    $default	reduce using rule 75 (type_spec)



state 60

    base_type_spec  ->  floating_pt_type .   (rule 79)

    $default	reduce using rule 79 (base_type_spec)



state 61

    base_type_spec  ->  integer_type .   (rule 80)

    $default	reduce using rule 80 (base_type_spec)



state 62

    base_type_spec  ->  char_type .   (rule 81)

    $default	reduce using rule 81 (base_type_spec)



state 63

    base_type_spec  ->  boolean_type .   (rule 82)

    $default	reduce using rule 82 (base_type_spec)



state 64

    base_type_spec  ->  octet_type .   (rule 83)

    $default	reduce using rule 83 (base_type_spec)



state 65

    base_type_spec  ->  any_type .   (rule 84)

    $default	reduce using rule 84 (base_type_spec)



state 66

    constr_type_spec  ->  struct_type .   (rule 87)

    $default	reduce using rule 87 (constr_type_spec)



state 67

    constr_type_spec  ->  union_type .   (rule 88)

    $default	reduce using rule 88 (constr_type_spec)



state 68

    constr_type_spec  ->  enum_type .   (rule 89)

    $default	reduce using rule 89 (constr_type_spec)



state 69

    template_type_spec  ->  sequence_type .   (rule 85)

    $default	reduce using rule 85 (template_type_spec)



state 70

    template_type_spec  ->  string_type .   (rule 86)

    $default	reduce using rule 86 (template_type_spec)



state 71

    union_type  ->  xUNION xIDENTIFIER . xSWITCH '(' switch_type_spec ')' '{' switch_body '}'   (rule 118)

    xSWITCH	shift, and go to state 98



state 72

    specification  ->  specification definition .   (rule 2)

    $default	reduce using rule 2 (specification)



state 73

    definition  ->  module ';' .   (rule 7)

    $default	reduce using rule 7 (definition)



state 74

    definition  ->  interface ';' .   (rule 6)

    $default	reduce using rule 6 (definition)



state 75

    interface_dcl  ->  interface_header '{' . interface_body '}'   (rule 11)

    $default	reduce using rule 15 (interface_body)

    interface_body	go to state 99



state 76

    definition  ->  const_dcl ';' .   (rule 4)

    $default	reduce using rule 4 (definition)



state 77

    definition  ->  type_dcl ';' .   (rule 3)

    $default	reduce using rule 3 (definition)



state 78

    definition  ->  except_dcl ';' .   (rule 5)

    $default	reduce using rule 5 (definition)



state 79

    string_type  ->  xSTRING '<' . positive_int_const '>'   (rule 138)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 111
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122
    positive_int_const	go to state 123



state 80

    unsigned_long_int  ->  xUNSIGNED xLONG .   (rule 108)

    $default	reduce using rule 108 (unsigned_long_int)



state 81

    unsigned_short_int  ->  xUNSIGNED xSHORT .   (rule 109)

    $default	reduce using rule 109 (unsigned_short_int)



state 82

    scoped_name  ->  DOUBLE_COLON xIDENTIFIER .   (rule 27)

    $default	reduce using rule 27 (scoped_name)



state 83

    scoped_name  ->  scoped_name DOUBLE_COLON . xIDENTIFIER   (rule 28)

    xIDENTIFIER	shift, and go to state 124



state 84

    const_dcl  ->  xCONST const_type xIDENTIFIER . '=' const_exp   (rule 29)

    '=' 	shift, and go to state 125



state 85

    enum_type  ->  xENUM xIDENTIFIER '{' . aux_4 '}'   (rule 132)

    xIDENTIFIER	shift, and go to state 126

    aux_4	go to state 127
    enumerator	go to state 128



state 86

    except_dcl  ->  xEXCEPTION xIDENTIFIER '{' . '}'   (rule 148)
    except_dcl  ->  xEXCEPTION xIDENTIFIER '{' . aux_7 '}'   (rule 149)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31
    '}' 	shift, and go to state 129

    scoped_name	go to state 53
    type_spec	go to state 130
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    member	go to state 131
    union_type	go to state 67
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70
    aux_7	go to state 132



state 87

    inheritance_spec  ->  ':' . scoped_name   (rule 22)
    inheritance_spec  ->  ':' . scoped_name aux_1   (rule 23)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 133



state 88

    interface_header  ->  xINTERFACE xIDENTIFIER inheritance_spec .   (rule 14)

    $default	reduce using rule 14 (interface_header)



state 89

    module  ->  xMODULE xIDENTIFIER '{' . definition '}'   (rule 8)

    xCONST	shift, and go to state 1
    xENUM	shift, and go to state 2
    xEXCEPTION	shift, and go to state 3
    xINTERFACE	shift, and go to state 4
    xMODULE	shift, and go to state 5
    xSTRUCT	shift, and go to state 6
    xTYPEDEF	shift, and go to state 7
    xUNION	shift, and go to state 8

    definition	go to state 134
    module	go to state 11
    interface	go to state 12
    interface_dcl	go to state 13
    forward_dcl	go to state 14
    interface_header	go to state 15
    const_dcl	go to state 16
    type_dcl	go to state 17
    struct_type	go to state 18
    union_type	go to state 19
    enum_type	go to state 20
    except_dcl	go to state 21



state 90

    struct_type  ->  xSTRUCT xIDENTIFIER '{' . member_list '}'   (rule 114)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 53
    type_spec	go to state 130
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    member_list	go to state 135
    member	go to state 136
    union_type	go to state 67
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70



state 91

    sequence_type  ->  xSEQUENCE '<' . simple_type_spec ',' positive_int_const '>'   (rule 136)
    sequence_type  ->  xSEQUENCE '<' . simple_type_spec '>'   (rule 137)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 53
    simple_type_spec	go to state 137
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    sequence_type	go to state 69
    string_type	go to state 70



state 92

    simple_declarator  ->  xIDENTIFIER .   (rule 96)
    array_declarator  ->  xIDENTIFIER . aux_5   (rule 140)

    '[' 	shift, and go to state 138

    $default	reduce using rule 96 (simple_declarator)

    aux_5	go to state 139
    fixed_array_size	go to state 140



state 93

    type_declarator  ->  type_spec declarators .   (rule 73)

    $default	reduce using rule 73 (type_declarator)



state 94

    declarators  ->  declarator .   (rule 90)
    declarators  ->  declarator . aux_2   (rule 91)

    ',' 	shift, and go to state 141

    $default	reduce using rule 90 (declarators)

    aux_2	go to state 142



state 95

    declarator  ->  simple_declarator .   (rule 94)

    $default	reduce using rule 94 (declarator)



state 96

    declarator  ->  complex_declarator .   (rule 95)

    $default	reduce using rule 95 (declarator)



state 97

    complex_declarator  ->  array_declarator .   (rule 97)

    $default	reduce using rule 97 (complex_declarator)



state 98

    union_type  ->  xUNION xIDENTIFIER xSWITCH . '(' switch_type_spec ')' '{' switch_body '}'   (rule 118)

    '(' 	shift, and go to state 143



state 99

    interface_dcl  ->  interface_header '{' interface_body . '}'   (rule 11)
    interface_body  ->  interface_body . export   (rule 16)

    xANY	shift, and go to state 50
    xATTRIBUTE	shift, and go to state 144
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xCONST	shift, and go to state 1
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xEXCEPTION	shift, and go to state 3
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xONEWAY	shift, and go to state 145
    xREADONLY	shift, and go to state 146
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xTYPEDEF	shift, and go to state 7
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    xVOID	shift, and go to state 147
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31
    '}' 	shift, and go to state 148

    export	go to state 149
    scoped_name	go to state 150
    const_dcl	go to state 151
    type_dcl	go to state 152
    base_type_spec	go to state 153
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 18
    union_type	go to state 19
    enum_type	go to state 20
    string_type	go to state 154
    attr_dcl	go to state 155
    except_dcl	go to state 156
    op_dcl	go to state 157
    op_attribute	go to state 158
    op_type_spec	go to state 159
    param_type_spec	go to state 160



state 100

    boolean_literal  ->  xFALSE .   (rule 67)

    $default	reduce using rule 67 (boolean_literal)



state 101

    boolean_literal  ->  xTRUE .   (rule 66)

    $default	reduce using rule 66 (boolean_literal)



state 102

    literal  ->  FLOATING_PT_LITERAL .   (rule 64)

    $default	reduce using rule 64 (literal)



state 103

    literal  ->  CHARACTER_LITERAL .   (rule 63)

    $default	reduce using rule 63 (literal)



state 104

    literal  ->  STRING_LITERAL .   (rule 62)

    $default	reduce using rule 62 (literal)



state 105

    literal  ->  INTEGER_LITERAL .   (rule 61)

    $default	reduce using rule 61 (literal)



state 106

    unary_operator  ->  '-' .   (rule 55)

    $default	reduce using rule 55 (unary_operator)



state 107

    unary_operator  ->  '+' .   (rule 56)

    $default	reduce using rule 56 (unary_operator)



state 108

    unary_operator  ->  '~' .   (rule 57)

    $default	reduce using rule 57 (unary_operator)



state 109

    primary_expr  ->  '(' . const_exp ')'   (rule 60)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 161
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 110

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    primary_expr  ->  scoped_name .   (rule 58)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 58 (primary_expr)



state 111

    positive_int_const  ->  const_exp .   (rule 68)

    $default	reduce using rule 68 (positive_int_const)



state 112

    const_exp  ->  or_expr .   (rule 36)
    or_expr  ->  or_expr . '|' xor_expr   (rule 38)

    '|' 	shift, and go to state 162

    $default	reduce using rule 36 (const_exp)



state 113

    or_expr  ->  xor_expr .   (rule 37)
    xor_expr  ->  xor_expr . '^' and_expr   (rule 40)

    '^' 	shift, and go to state 163

    $default	reduce using rule 37 (or_expr)



state 114

    xor_expr  ->  and_expr .   (rule 39)
    and_expr  ->  and_expr . '&' shift_expr   (rule 42)

    '&' 	shift, and go to state 164

    $default	reduce using rule 39 (xor_expr)



state 115

    and_expr  ->  shift_expr .   (rule 41)
    shift_expr  ->  shift_expr . DOUBLE_GT add_expr   (rule 44)
    shift_expr  ->  shift_expr . DOUBLE_LT add_expr   (rule 45)

    DOUBLE_LT	shift, and go to state 165
    DOUBLE_GT	shift, and go to state 166

    $default	reduce using rule 41 (and_expr)



state 116

    shift_expr  ->  add_expr .   (rule 43)
    add_expr  ->  add_expr . '+' mult_expr   (rule 47)
    add_expr  ->  add_expr . '-' mult_expr   (rule 48)

    '-' 	shift, and go to state 167
    '+' 	shift, and go to state 168

    $default	reduce using rule 43 (shift_expr)



state 117

    add_expr  ->  mult_expr .   (rule 46)
    mult_expr  ->  mult_expr . '*' unary_expr   (rule 50)
    mult_expr  ->  mult_expr . '/' unary_expr   (rule 51)
    mult_expr  ->  mult_expr . '%' unary_expr   (rule 52)

    '*' 	shift, and go to state 169
    '/' 	shift, and go to state 170
    '%' 	shift, and go to state 171

    $default	reduce using rule 46 (add_expr)



state 118

    mult_expr  ->  unary_expr .   (rule 49)

    $default	reduce using rule 49 (mult_expr)



state 119

    unary_expr  ->  unary_operator . primary_expr   (rule 53)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    primary_expr	go to state 172
    literal	go to state 121
    boolean_literal	go to state 122



state 120

    unary_expr  ->  primary_expr .   (rule 54)

    $default	reduce using rule 54 (unary_expr)



state 121

    primary_expr  ->  literal .   (rule 59)

    $default	reduce using rule 59 (primary_expr)



state 122

    literal  ->  boolean_literal .   (rule 65)

    $default	reduce using rule 65 (literal)



state 123

    string_type  ->  xSTRING '<' positive_int_const . '>'   (rule 138)

    '>' 	shift, and go to state 173



state 124

    scoped_name  ->  scoped_name DOUBLE_COLON xIDENTIFIER .   (rule 28)

    $default	reduce using rule 28 (scoped_name)



state 125

    const_dcl  ->  xCONST const_type xIDENTIFIER '=' . const_exp   (rule 29)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 174
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 126

    enumerator  ->  xIDENTIFIER .   (rule 135)

    $default	reduce using rule 135 (enumerator)



state 127

    enum_type  ->  xENUM xIDENTIFIER '{' aux_4 . '}'   (rule 132)
    aux_4  ->  aux_4 . ',' enumerator   (rule 134)

    '}' 	shift, and go to state 175
    ',' 	shift, and go to state 176



state 128

    aux_4  ->  enumerator .   (rule 133)

    $default	reduce using rule 133 (aux_4)



state 129

    except_dcl  ->  xEXCEPTION xIDENTIFIER '{' '}' .   (rule 148)

    $default	reduce using rule 148 (except_dcl)



state 130

    member  ->  type_spec . declarators ';'   (rule 117)

    xIDENTIFIER	shift, and go to state 92

    declarators	go to state 177
    declarator	go to state 94
    simple_declarator	go to state 95
    complex_declarator	go to state 96
    array_declarator	go to state 97



state 131

    aux_7  ->  member .   (rule 150)

    $default	reduce using rule 150 (aux_7)



state 132

    except_dcl  ->  xEXCEPTION xIDENTIFIER '{' aux_7 . '}'   (rule 149)
    aux_7  ->  aux_7 . member   (rule 151)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31
    '}' 	shift, and go to state 178

    scoped_name	go to state 53
    type_spec	go to state 130
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    member	go to state 179
    union_type	go to state 67
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70



state 133

    inheritance_spec  ->  ':' scoped_name .   (rule 22)
    inheritance_spec  ->  ':' scoped_name . aux_1   (rule 23)
    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)

    DOUBLE_COLON	shift, and go to state 83
    ',' 	shift, and go to state 180

    $default	reduce using rule 22 (inheritance_spec)

    aux_1	go to state 181



state 134

    module  ->  xMODULE xIDENTIFIER '{' definition . '}'   (rule 8)

    '}' 	shift, and go to state 182



state 135

    struct_type  ->  xSTRUCT xIDENTIFIER '{' member_list . '}'   (rule 114)
    member_list  ->  member_list . member   (rule 116)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31
    '}' 	shift, and go to state 183

    scoped_name	go to state 53
    type_spec	go to state 130
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    member	go to state 184
    union_type	go to state 67
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70



state 136

    member_list  ->  member .   (rule 115)

    $default	reduce using rule 115 (member_list)



state 137

    sequence_type  ->  xSEQUENCE '<' simple_type_spec . ',' positive_int_const '>'   (rule 136)
    sequence_type  ->  xSEQUENCE '<' simple_type_spec . '>'   (rule 137)

    ',' 	shift, and go to state 185
    '>' 	shift, and go to state 186



state 138

    fixed_array_size  ->  '[' . positive_int_const ']'   (rule 143)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 111
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122
    positive_int_const	go to state 187



state 139

    array_declarator  ->  xIDENTIFIER aux_5 .   (rule 140)
    aux_5  ->  aux_5 . fixed_array_size   (rule 142)

    '[' 	shift, and go to state 138

    $default	reduce using rule 140 (array_declarator)

    fixed_array_size	go to state 188



state 140

    aux_5  ->  fixed_array_size .   (rule 141)

    $default	reduce using rule 141 (aux_5)



state 141

    aux_2  ->  ',' . declarator   (rule 92)

    xIDENTIFIER	shift, and go to state 92

    declarator	go to state 189
    simple_declarator	go to state 95
    complex_declarator	go to state 96
    array_declarator	go to state 97



state 142

    declarators  ->  declarator aux_2 .   (rule 91)
    aux_2  ->  aux_2 . ',' declarator   (rule 93)

    ',' 	shift, and go to state 190

    $default	reduce using rule 91 (declarators)



state 143

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' . switch_type_spec ')' '{' switch_body '}'   (rule 118)

    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xENUM	shift, and go to state 2
    xLONG	shift, and go to state 26
    xSHORT	shift, and go to state 27
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 191
    integer_type	go to state 192
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 193
    boolean_type	go to state 194
    switch_type_spec	go to state 195
    enum_type	go to state 196



state 144

    attr_dcl  ->  xATTRIBUTE . param_type_spec aux_6   (rule 144)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 150
    base_type_spec	go to state 153
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    string_type	go to state 154
    param_type_spec	go to state 197



state 145

    op_attribute  ->  xONEWAY .   (rule 160)

    $default	reduce using rule 160 (op_attribute)



state 146

    attr_dcl  ->  xREADONLY . xATTRIBUTE param_type_spec aux_6   (rule 145)

    xATTRIBUTE	shift, and go to state 198



state 147

    op_type_spec  ->  xVOID .   (rule 162)

    $default	reduce using rule 162 (op_type_spec)



state 148

    interface_dcl  ->  interface_header '{' interface_body '}' .   (rule 11)

    $default	reduce using rule 11 (interface_dcl)



state 149

    interface_body  ->  interface_body export .   (rule 16)

    $default	reduce using rule 16 (interface_body)



state 150

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    param_type_spec  ->  scoped_name .   (rule 181)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 181 (param_type_spec)



state 151

    export  ->  const_dcl . ';'   (rule 18)

    ';' 	shift, and go to state 199



state 152

    export  ->  type_dcl . ';'   (rule 17)

    ';' 	shift, and go to state 200



state 153

    param_type_spec  ->  base_type_spec .   (rule 179)

    $default	reduce using rule 179 (param_type_spec)



state 154

    param_type_spec  ->  string_type .   (rule 180)

    $default	reduce using rule 180 (param_type_spec)



state 155

    export  ->  attr_dcl . ';'   (rule 20)

    ';' 	shift, and go to state 201



state 156

    export  ->  except_dcl . ';'   (rule 19)

    ';' 	shift, and go to state 202



state 157

    export  ->  op_dcl . ';'   (rule 21)

    ';' 	shift, and go to state 203



state 158

    op_dcl  ->  op_attribute . op_type_spec xIDENTIFIER parameter_dcls   (rule 156)
    op_dcl  ->  op_attribute . op_type_spec xIDENTIFIER parameter_dcls raises_expr   (rule 157)
    op_dcl  ->  op_attribute . op_type_spec xIDENTIFIER parameter_dcls context_expr   (rule 158)
    op_dcl  ->  op_attribute . op_type_spec xIDENTIFIER parameter_dcls raises_expr context_expr   (rule 159)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    xVOID	shift, and go to state 147
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 150
    base_type_spec	go to state 153
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    string_type	go to state 154
    op_type_spec	go to state 204
    param_type_spec	go to state 160



state 159

    op_dcl  ->  op_type_spec . xIDENTIFIER parameter_dcls   (rule 152)
    op_dcl  ->  op_type_spec . xIDENTIFIER parameter_dcls raises_expr   (rule 153)
    op_dcl  ->  op_type_spec . xIDENTIFIER parameter_dcls context_expr   (rule 154)
    op_dcl  ->  op_type_spec . xIDENTIFIER parameter_dcls raises_expr context_expr   (rule 155)

    xIDENTIFIER	shift, and go to state 205



state 160

    op_type_spec  ->  param_type_spec .   (rule 161)

    $default	reduce using rule 161 (op_type_spec)



state 161

    primary_expr  ->  '(' const_exp . ')'   (rule 60)

    ')' 	shift, and go to state 206



state 162

    or_expr  ->  or_expr '|' . xor_expr   (rule 38)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    xor_expr	go to state 207
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 163

    xor_expr  ->  xor_expr '^' . and_expr   (rule 40)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    and_expr	go to state 208
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 164

    and_expr  ->  and_expr '&' . shift_expr   (rule 42)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    shift_expr	go to state 209
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 165

    shift_expr  ->  shift_expr DOUBLE_LT . add_expr   (rule 45)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    add_expr	go to state 210
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 166

    shift_expr  ->  shift_expr DOUBLE_GT . add_expr   (rule 44)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    add_expr	go to state 211
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 167

    add_expr  ->  add_expr '-' . mult_expr   (rule 48)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    mult_expr	go to state 212
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 168

    add_expr  ->  add_expr '+' . mult_expr   (rule 47)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    mult_expr	go to state 213
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 169

    mult_expr  ->  mult_expr '*' . unary_expr   (rule 50)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    unary_expr	go to state 214
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 170

    mult_expr  ->  mult_expr '/' . unary_expr   (rule 51)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    unary_expr	go to state 215
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 171

    mult_expr  ->  mult_expr '%' . unary_expr   (rule 52)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    unary_expr	go to state 216
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 172

    unary_expr  ->  unary_operator primary_expr .   (rule 53)

    $default	reduce using rule 53 (unary_expr)



state 173

    string_type  ->  xSTRING '<' positive_int_const '>' .   (rule 138)

    $default	reduce using rule 138 (string_type)



state 174

    const_dcl  ->  xCONST const_type xIDENTIFIER '=' const_exp .   (rule 29)

    $default	reduce using rule 29 (const_dcl)



state 175

    enum_type  ->  xENUM xIDENTIFIER '{' aux_4 '}' .   (rule 132)

    $default	reduce using rule 132 (enum_type)



state 176

    aux_4  ->  aux_4 ',' . enumerator   (rule 134)

    xIDENTIFIER	shift, and go to state 126

    enumerator	go to state 217



state 177

    member  ->  type_spec declarators . ';'   (rule 117)

    ';' 	shift, and go to state 218



state 178

    except_dcl  ->  xEXCEPTION xIDENTIFIER '{' aux_7 '}' .   (rule 149)

    $default	reduce using rule 149 (except_dcl)



state 179

    aux_7  ->  aux_7 member .   (rule 151)

    $default	reduce using rule 151 (aux_7)



state 180

    aux_1  ->  ',' . scoped_name   (rule 24)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 219



state 181

    inheritance_spec  ->  ':' scoped_name aux_1 .   (rule 23)
    aux_1  ->  aux_1 . ',' scoped_name   (rule 25)

    ',' 	shift, and go to state 220

    $default	reduce using rule 23 (inheritance_spec)



state 182

    module  ->  xMODULE xIDENTIFIER '{' definition '}' .   (rule 8)

    $default	reduce using rule 8 (module)



state 183

    struct_type  ->  xSTRUCT xIDENTIFIER '{' member_list '}' .   (rule 114)

    $default	reduce using rule 114 (struct_type)



state 184

    member_list  ->  member_list member .   (rule 116)

    $default	reduce using rule 116 (member_list)



state 185

    sequence_type  ->  xSEQUENCE '<' simple_type_spec ',' . positive_int_const '>'   (rule 136)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 111
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122
    positive_int_const	go to state 221



state 186

    sequence_type  ->  xSEQUENCE '<' simple_type_spec '>' .   (rule 137)

    $default	reduce using rule 137 (sequence_type)



state 187

    fixed_array_size  ->  '[' positive_int_const . ']'   (rule 143)

    ']' 	shift, and go to state 222



state 188

    aux_5  ->  aux_5 fixed_array_size .   (rule 142)

    $default	reduce using rule 142 (aux_5)



state 189

    aux_2  ->  ',' declarator .   (rule 92)

    $default	reduce using rule 92 (aux_2)



state 190

    aux_2  ->  aux_2 ',' . declarator   (rule 93)

    xIDENTIFIER	shift, and go to state 92

    declarator	go to state 223
    simple_declarator	go to state 95
    complex_declarator	go to state 96
    array_declarator	go to state 97



state 191

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    switch_type_spec  ->  scoped_name .   (rule 123)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 123 (switch_type_spec)



state 192

    switch_type_spec  ->  integer_type .   (rule 119)

    $default	reduce using rule 119 (switch_type_spec)



state 193

    switch_type_spec  ->  char_type .   (rule 120)

    $default	reduce using rule 120 (switch_type_spec)



state 194

    switch_type_spec  ->  boolean_type .   (rule 121)

    $default	reduce using rule 121 (switch_type_spec)



state 195

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' switch_type_spec . ')' '{' switch_body '}'   (rule 118)

    ')' 	shift, and go to state 224



state 196

    switch_type_spec  ->  enum_type .   (rule 122)

    $default	reduce using rule 122 (switch_type_spec)



state 197

    attr_dcl  ->  xATTRIBUTE param_type_spec . aux_6   (rule 144)

    xIDENTIFIER	shift, and go to state 225

    simple_declarator	go to state 226
    aux_6	go to state 227



state 198

    attr_dcl  ->  xREADONLY xATTRIBUTE . param_type_spec aux_6   (rule 145)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 150
    base_type_spec	go to state 153
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    string_type	go to state 154
    param_type_spec	go to state 228



state 199

    export  ->  const_dcl ';' .   (rule 18)

    $default	reduce using rule 18 (export)



state 200

    export  ->  type_dcl ';' .   (rule 17)

    $default	reduce using rule 17 (export)



state 201

    export  ->  attr_dcl ';' .   (rule 20)

    $default	reduce using rule 20 (export)



state 202

    export  ->  except_dcl ';' .   (rule 19)

    $default	reduce using rule 19 (export)



state 203

    export  ->  op_dcl ';' .   (rule 21)

    $default	reduce using rule 21 (export)



state 204

    op_dcl  ->  op_attribute op_type_spec . xIDENTIFIER parameter_dcls   (rule 156)
    op_dcl  ->  op_attribute op_type_spec . xIDENTIFIER parameter_dcls raises_expr   (rule 157)
    op_dcl  ->  op_attribute op_type_spec . xIDENTIFIER parameter_dcls context_expr   (rule 158)
    op_dcl  ->  op_attribute op_type_spec . xIDENTIFIER parameter_dcls raises_expr context_expr   (rule 159)

    xIDENTIFIER	shift, and go to state 229



state 205

    op_dcl  ->  op_type_spec xIDENTIFIER . parameter_dcls   (rule 152)
    op_dcl  ->  op_type_spec xIDENTIFIER . parameter_dcls raises_expr   (rule 153)
    op_dcl  ->  op_type_spec xIDENTIFIER . parameter_dcls context_expr   (rule 154)
    op_dcl  ->  op_type_spec xIDENTIFIER . parameter_dcls raises_expr context_expr   (rule 155)

    '(' 	shift, and go to state 230

    parameter_dcls	go to state 231



state 206

    primary_expr  ->  '(' const_exp ')' .   (rule 60)

    $default	reduce using rule 60 (primary_expr)



state 207

    or_expr  ->  or_expr '|' xor_expr .   (rule 38)
    xor_expr  ->  xor_expr . '^' and_expr   (rule 40)

    '^' 	shift, and go to state 163

    $default	reduce using rule 38 (or_expr)



state 208

    xor_expr  ->  xor_expr '^' and_expr .   (rule 40)
    and_expr  ->  and_expr . '&' shift_expr   (rule 42)

    '&' 	shift, and go to state 164

    $default	reduce using rule 40 (xor_expr)



state 209

    and_expr  ->  and_expr '&' shift_expr .   (rule 42)
    shift_expr  ->  shift_expr . DOUBLE_GT add_expr   (rule 44)
    shift_expr  ->  shift_expr . DOUBLE_LT add_expr   (rule 45)

    DOUBLE_LT	shift, and go to state 165
    DOUBLE_GT	shift, and go to state 166

    $default	reduce using rule 42 (and_expr)



state 210

    shift_expr  ->  shift_expr DOUBLE_LT add_expr .   (rule 45)
    add_expr  ->  add_expr . '+' mult_expr   (rule 47)
    add_expr  ->  add_expr . '-' mult_expr   (rule 48)

    '-' 	shift, and go to state 167
    '+' 	shift, and go to state 168

    $default	reduce using rule 45 (shift_expr)



state 211

    shift_expr  ->  shift_expr DOUBLE_GT add_expr .   (rule 44)
    add_expr  ->  add_expr . '+' mult_expr   (rule 47)
    add_expr  ->  add_expr . '-' mult_expr   (rule 48)

    '-' 	shift, and go to state 167
    '+' 	shift, and go to state 168

    $default	reduce using rule 44 (shift_expr)



state 212

    add_expr  ->  add_expr '-' mult_expr .   (rule 48)
    mult_expr  ->  mult_expr . '*' unary_expr   (rule 50)
    mult_expr  ->  mult_expr . '/' unary_expr   (rule 51)
    mult_expr  ->  mult_expr . '%' unary_expr   (rule 52)

    '*' 	shift, and go to state 169
    '/' 	shift, and go to state 170
    '%' 	shift, and go to state 171

    $default	reduce using rule 48 (add_expr)



state 213

    add_expr  ->  add_expr '+' mult_expr .   (rule 47)
    mult_expr  ->  mult_expr . '*' unary_expr   (rule 50)
    mult_expr  ->  mult_expr . '/' unary_expr   (rule 51)
    mult_expr  ->  mult_expr . '%' unary_expr   (rule 52)

    '*' 	shift, and go to state 169
    '/' 	shift, and go to state 170
    '%' 	shift, and go to state 171

    $default	reduce using rule 47 (add_expr)



state 214

    mult_expr  ->  mult_expr '*' unary_expr .   (rule 50)

    $default	reduce using rule 50 (mult_expr)



state 215

    mult_expr  ->  mult_expr '/' unary_expr .   (rule 51)

    $default	reduce using rule 51 (mult_expr)



state 216

    mult_expr  ->  mult_expr '%' unary_expr .   (rule 52)

    $default	reduce using rule 52 (mult_expr)



state 217

    aux_4  ->  aux_4 ',' enumerator .   (rule 134)

    $default	reduce using rule 134 (aux_4)



state 218

    member  ->  type_spec declarators ';' .   (rule 117)

    $default	reduce using rule 117 (member)



state 219

    aux_1  ->  ',' scoped_name .   (rule 24)
    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 24 (aux_1)



state 220

    aux_1  ->  aux_1 ',' . scoped_name   (rule 25)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 232



state 221

    sequence_type  ->  xSEQUENCE '<' simple_type_spec ',' positive_int_const . '>'   (rule 136)

    '>' 	shift, and go to state 233



state 222

    fixed_array_size  ->  '[' positive_int_const ']' .   (rule 143)

    $default	reduce using rule 143 (fixed_array_size)



state 223

    aux_2  ->  aux_2 ',' declarator .   (rule 93)

    $default	reduce using rule 93 (aux_2)



state 224

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' switch_type_spec ')' . '{' switch_body '}'   (rule 118)

    '{' 	shift, and go to state 234



state 225

    simple_declarator  ->  xIDENTIFIER .   (rule 96)

    $default	reduce using rule 96 (simple_declarator)



state 226

    aux_6  ->  simple_declarator .   (rule 146)

    $default	reduce using rule 146 (aux_6)



state 227

    attr_dcl  ->  xATTRIBUTE param_type_spec aux_6 .   (rule 144)
    aux_6  ->  aux_6 . ',' simple_declarator   (rule 147)

    ',' 	shift, and go to state 235

    $default	reduce using rule 144 (attr_dcl)



state 228

    attr_dcl  ->  xREADONLY xATTRIBUTE param_type_spec . aux_6   (rule 145)

    xIDENTIFIER	shift, and go to state 225

    simple_declarator	go to state 226
    aux_6	go to state 236



state 229

    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER . parameter_dcls   (rule 156)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER . parameter_dcls raises_expr   (rule 157)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER . parameter_dcls context_expr   (rule 158)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER . parameter_dcls raises_expr context_expr   (rule 159)

    '(' 	shift, and go to state 230

    parameter_dcls	go to state 237



state 230

    parameter_dcls  ->  '(' . aux_8 ')'   (rule 163)
    parameter_dcls  ->  '(' . ')'   (rule 164)

    xIN 	shift, and go to state 238
    xINOUT	shift, and go to state 239
    xOUT	shift, and go to state 240
    ')' 	shift, and go to state 241

    aux_8	go to state 242
    param_dcl	go to state 243
    param_attribute	go to state 244



state 231

    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls .   (rule 152)
    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls . raises_expr   (rule 153)
    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls . context_expr   (rule 154)
    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls . raises_expr context_expr   (rule 155)

    xCONTEXT	shift, and go to state 245
    xRAISES	shift, and go to state 246

    $default	reduce using rule 152 (op_dcl)

    raises_expr	go to state 247
    context_expr	go to state 248



state 232

    aux_1  ->  aux_1 ',' scoped_name .   (rule 25)
    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 25 (aux_1)



state 233

    sequence_type  ->  xSEQUENCE '<' simple_type_spec ',' positive_int_const '>' .   (rule 136)

    $default	reduce using rule 136 (sequence_type)



state 234

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' switch_type_spec ')' '{' . switch_body '}'   (rule 118)

    xCASE	shift, and go to state 249
    xDEFAULT	shift, and go to state 250

    switch_body	go to state 251
    case	go to state 252
    aux_3	go to state 253
    case_label	go to state 254



state 235

    aux_6  ->  aux_6 ',' . simple_declarator   (rule 147)

    xIDENTIFIER	shift, and go to state 225

    simple_declarator	go to state 255



state 236

    attr_dcl  ->  xREADONLY xATTRIBUTE param_type_spec aux_6 .   (rule 145)
    aux_6  ->  aux_6 . ',' simple_declarator   (rule 147)

    ',' 	shift, and go to state 235

    $default	reduce using rule 145 (attr_dcl)



state 237

    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls .   (rule 156)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls . raises_expr   (rule 157)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls . context_expr   (rule 158)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls . raises_expr context_expr   (rule 159)

    xCONTEXT	shift, and go to state 245
    xRAISES	shift, and go to state 246

    $default	reduce using rule 156 (op_dcl)

    raises_expr	go to state 256
    context_expr	go to state 257



state 238

    param_attribute  ->  xIN .   (rule 168)

    $default	reduce using rule 168 (param_attribute)



state 239

    param_attribute  ->  xINOUT .   (rule 170)

    $default	reduce using rule 170 (param_attribute)



state 240

    param_attribute  ->  xOUT .   (rule 169)

    $default	reduce using rule 169 (param_attribute)



state 241

    parameter_dcls  ->  '(' ')' .   (rule 164)

    $default	reduce using rule 164 (parameter_dcls)



state 242

    parameter_dcls  ->  '(' aux_8 . ')'   (rule 163)
    aux_8  ->  aux_8 . ',' param_dcl   (rule 166)

    ',' 	shift, and go to state 258
    ')' 	shift, and go to state 259



state 243

    aux_8  ->  param_dcl .   (rule 165)

    $default	reduce using rule 165 (aux_8)



state 244

    param_dcl  ->  param_attribute . param_type_spec simple_declarator   (rule 167)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCHAR	shift, and go to state 23
    xDOUBLE	shift, and go to state 24
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xUNSIGNED	shift, and go to state 29
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 150
    base_type_spec	go to state 153
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    string_type	go to state 154
    param_type_spec	go to state 260



state 245

    context_expr  ->  xCONTEXT . '(' STRING_LITERAL ')'   (rule 175)
    context_expr  ->  xCONTEXT . '(' STRING_LITERAL aux_10 ')'   (rule 176)

    '(' 	shift, and go to state 261



state 246

    raises_expr  ->  xRAISES . '(' scoped_name ')'   (rule 171)
    raises_expr  ->  xRAISES . '(' scoped_name aux_9 ')'   (rule 172)

    '(' 	shift, and go to state 262



state 247

    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls raises_expr .   (rule 153)
    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls raises_expr . context_expr   (rule 155)

    xCONTEXT	shift, and go to state 245

    $default	reduce using rule 153 (op_dcl)

    context_expr	go to state 263



state 248

    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls context_expr .   (rule 154)

    $default	reduce using rule 154 (op_dcl)



state 249

    case_label  ->  xCASE . const_exp ':'   (rule 129)

    xFALSE	shift, and go to state 100
    xTRUE	shift, and go to state 101
    DOUBLE_COLON	shift, and go to state 30
    FLOATING_PT_LITERAL	shift, and go to state 102
    CHARACTER_LITERAL	shift, and go to state 103
    STRING_LITERAL	shift, and go to state 104
    INTEGER_LITERAL	shift, and go to state 105
    xIDENTIFIER	shift, and go to state 31
    '-' 	shift, and go to state 106
    '+' 	shift, and go to state 107
    '~' 	shift, and go to state 108
    '(' 	shift, and go to state 109

    scoped_name	go to state 110
    const_exp	go to state 264
    or_expr	go to state 112
    xor_expr	go to state 113
    and_expr	go to state 114
    shift_expr	go to state 115
    add_expr	go to state 116
    mult_expr	go to state 117
    unary_expr	go to state 118
    unary_operator	go to state 119
    primary_expr	go to state 120
    literal	go to state 121
    boolean_literal	go to state 122



state 250

    case_label  ->  xDEFAULT . ':'   (rule 130)

    ':' 	shift, and go to state 265



state 251

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' switch_type_spec ')' '{' switch_body . '}'   (rule 118)
    switch_body  ->  switch_body . case   (rule 125)

    xCASE	shift, and go to state 249
    xDEFAULT	shift, and go to state 250
    '}' 	shift, and go to state 266

    case	go to state 267
    aux_3	go to state 253
    case_label	go to state 254



state 252

    switch_body  ->  case .   (rule 124)

    $default	reduce using rule 124 (switch_body)



state 253

    case  ->  aux_3 . element_spec ';'   (rule 126)
    aux_3  ->  aux_3 . case_label   (rule 128)

    xANY	shift, and go to state 50
    xBOOLEAN	shift, and go to state 22
    xCASE	shift, and go to state 249
    xCHAR	shift, and go to state 23
    xDEFAULT	shift, and go to state 250
    xDOUBLE	shift, and go to state 24
    xENUM	shift, and go to state 2
    xFLOAT	shift, and go to state 25
    xLONG	shift, and go to state 26
    xOCTET	shift, and go to state 51
    xSEQUENCE	shift, and go to state 52
    xSHORT	shift, and go to state 27
    xSTRING	shift, and go to state 28
    xSTRUCT	shift, and go to state 6
    xUNSIGNED	shift, and go to state 29
    xUNION	shift, and go to state 8
    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 53
    type_spec	go to state 268
    simple_type_spec	go to state 56
    base_type_spec	go to state 57
    template_type_spec	go to state 58
    constr_type_spec	go to state 59
    floating_pt_type	go to state 60
    integer_type	go to state 61
    signed_int	go to state 36
    signed_long_int	go to state 37
    signed_short_int	go to state 38
    unsigned_int	go to state 39
    unsigned_long_int	go to state 40
    unsigned_short_int	go to state 41
    char_type	go to state 62
    boolean_type	go to state 63
    octet_type	go to state 64
    any_type	go to state 65
    struct_type	go to state 66
    union_type	go to state 67
    case_label	go to state 269
    element_spec	go to state 270
    enum_type	go to state 68
    sequence_type	go to state 69
    string_type	go to state 70



state 254

    aux_3  ->  case_label .   (rule 127)

    $default	reduce using rule 127 (aux_3)



state 255

    aux_6  ->  aux_6 ',' simple_declarator .   (rule 147)

    $default	reduce using rule 147 (aux_6)



state 256

    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls raises_expr .   (rule 157)
    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls raises_expr . context_expr   (rule 159)

    xCONTEXT	shift, and go to state 245

    $default	reduce using rule 157 (op_dcl)

    context_expr	go to state 271



state 257

    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls context_expr .   (rule 158)

    $default	reduce using rule 158 (op_dcl)



state 258

    aux_8  ->  aux_8 ',' . param_dcl   (rule 166)

    xIN 	shift, and go to state 238
    xINOUT	shift, and go to state 239
    xOUT	shift, and go to state 240

    param_dcl	go to state 272
    param_attribute	go to state 244



state 259

    parameter_dcls  ->  '(' aux_8 ')' .   (rule 163)

    $default	reduce using rule 163 (parameter_dcls)



state 260

    param_dcl  ->  param_attribute param_type_spec . simple_declarator   (rule 167)

    xIDENTIFIER	shift, and go to state 225

    simple_declarator	go to state 273



state 261

    context_expr  ->  xCONTEXT '(' . STRING_LITERAL ')'   (rule 175)
    context_expr  ->  xCONTEXT '(' . STRING_LITERAL aux_10 ')'   (rule 176)

    STRING_LITERAL	shift, and go to state 274



state 262

    raises_expr  ->  xRAISES '(' . scoped_name ')'   (rule 171)
    raises_expr  ->  xRAISES '(' . scoped_name aux_9 ')'   (rule 172)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 275



state 263

    op_dcl  ->  op_type_spec xIDENTIFIER parameter_dcls raises_expr context_expr .   (rule 155)

    $default	reduce using rule 155 (op_dcl)



state 264

    case_label  ->  xCASE const_exp . ':'   (rule 129)

    ':' 	shift, and go to state 276



state 265

    case_label  ->  xDEFAULT ':' .   (rule 130)

    $default	reduce using rule 130 (case_label)



state 266

    union_type  ->  xUNION xIDENTIFIER xSWITCH '(' switch_type_spec ')' '{' switch_body '}' .   (rule 118)

    $default	reduce using rule 118 (union_type)



state 267

    switch_body  ->  switch_body case .   (rule 125)

    $default	reduce using rule 125 (switch_body)



state 268

    element_spec  ->  type_spec . declarator   (rule 131)

    xIDENTIFIER	shift, and go to state 92

    declarator	go to state 277
    simple_declarator	go to state 95
    complex_declarator	go to state 96
    array_declarator	go to state 97



state 269

    aux_3  ->  aux_3 case_label .   (rule 128)

    $default	reduce using rule 128 (aux_3)



state 270

    case  ->  aux_3 element_spec . ';'   (rule 126)

    ';' 	shift, and go to state 278



state 271

    op_dcl  ->  op_attribute op_type_spec xIDENTIFIER parameter_dcls raises_expr context_expr .   (rule 159)

    $default	reduce using rule 159 (op_dcl)



state 272

    aux_8  ->  aux_8 ',' param_dcl .   (rule 166)

    $default	reduce using rule 166 (aux_8)



state 273

    param_dcl  ->  param_attribute param_type_spec simple_declarator .   (rule 167)

    $default	reduce using rule 167 (param_dcl)



state 274

    context_expr  ->  xCONTEXT '(' STRING_LITERAL . ')'   (rule 175)
    context_expr  ->  xCONTEXT '(' STRING_LITERAL . aux_10 ')'   (rule 176)

    ',' 	shift, and go to state 279
    ')' 	shift, and go to state 280

    aux_10	go to state 281



state 275

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    raises_expr  ->  xRAISES '(' scoped_name . ')'   (rule 171)
    raises_expr  ->  xRAISES '(' scoped_name . aux_9 ')'   (rule 172)

    DOUBLE_COLON	shift, and go to state 83
    ',' 	shift, and go to state 282
    ')' 	shift, and go to state 283

    aux_9	go to state 284



state 276

    case_label  ->  xCASE const_exp ':' .   (rule 129)

    $default	reduce using rule 129 (case_label)



state 277

    element_spec  ->  type_spec declarator .   (rule 131)

    $default	reduce using rule 131 (element_spec)



state 278

    case  ->  aux_3 element_spec ';' .   (rule 126)

    $default	reduce using rule 126 (case)



state 279

    aux_10  ->  ',' . STRING_LITERAL   (rule 177)

    STRING_LITERAL	shift, and go to state 285



state 280

    context_expr  ->  xCONTEXT '(' STRING_LITERAL ')' .   (rule 175)

    $default	reduce using rule 175 (context_expr)



state 281

    context_expr  ->  xCONTEXT '(' STRING_LITERAL aux_10 . ')'   (rule 176)
    aux_10  ->  aux_10 . ',' STRING_LITERAL   (rule 178)

    ',' 	shift, and go to state 286
    ')' 	shift, and go to state 287



state 282

    aux_9  ->  ',' . scoped_name   (rule 173)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 288



state 283

    raises_expr  ->  xRAISES '(' scoped_name ')' .   (rule 171)

    $default	reduce using rule 171 (raises_expr)



state 284

    raises_expr  ->  xRAISES '(' scoped_name aux_9 . ')'   (rule 172)
    aux_9  ->  aux_9 . ',' scoped_name   (rule 174)

    ',' 	shift, and go to state 289
    ')' 	shift, and go to state 290



state 285

    aux_10  ->  ',' STRING_LITERAL .   (rule 177)

    $default	reduce using rule 177 (aux_10)



state 286

    aux_10  ->  aux_10 ',' . STRING_LITERAL   (rule 178)

    STRING_LITERAL	shift, and go to state 291



state 287

    context_expr  ->  xCONTEXT '(' STRING_LITERAL aux_10 ')' .   (rule 176)

    $default	reduce using rule 176 (context_expr)



state 288

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    aux_9  ->  ',' scoped_name .   (rule 173)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 173 (aux_9)



state 289

    aux_9  ->  aux_9 ',' . scoped_name   (rule 174)

    DOUBLE_COLON	shift, and go to state 30
    xIDENTIFIER	shift, and go to state 31

    scoped_name	go to state 292



state 290

    raises_expr  ->  xRAISES '(' scoped_name aux_9 ')' .   (rule 172)

    $default	reduce using rule 172 (raises_expr)



state 291

    aux_10  ->  aux_10 ',' STRING_LITERAL .   (rule 178)

    $default	reduce using rule 178 (aux_10)



state 292

    scoped_name  ->  scoped_name . DOUBLE_COLON xIDENTIFIER   (rule 28)
    aux_9  ->  aux_9 ',' scoped_name .   (rule 174)

    DOUBLE_COLON	shift, and go to state 83

    $default	reduce using rule 174 (aux_9)



state 293

    $   	shift, and go to state 294



state 294

    NO ACTIONS
