;;;; -*- Mode: Lisp; Package: CL-USER; Base: 10; Syntax: Common-Lisp -*-
;;;;
;;;; Module LICENSING-CLIENT: G2 standalone licensing client (GUI)

;;; Copyright (c) 2010-2013 Versata Software, Inc.
;;; All Rights Reserved.

;;; Author: Chun Tian (binghe) <binghe.lisp@gmail.com>

(in-package :cl-user)

(eval-when (:compile-toplevel :load-toplevel :execute)
  (require "comm"))

(defparameter *major-version* 3)
(defparameter *minor-version* 0)
(defparameter *revision* 0)

(defun show-startup-message (&optional (stream *standard-output*))
  (format stream "G2 Licensing Client ~D.~Dr~D"
          *major-version* *minor-version* *revision*))

(defun licensing-client ()
  (load-config)
  (load-patches)
  (capi:display (make-instance 'licensing-client)))

;;; Part 1: CLI version

(defparameter *ls-server-host*
  (or (environment-variable "LS_SERVER_HOST") "localhost"))
(defparameter *ls-server-port*
  (or (environment-variable "LS_SERVER_PORT") 7535))
(defparameter *ls-user*
  (or (environment-variable "LS_USER") "binghe"))
(defparameter *ls-password*
  (or (environment-variable "LS_PASSWORD") "lisp"))
(defparameter *ls-command* "help")
(defvar *lc-g2-output-directory* *default-pathname-defaults*)

(defparameter *timeout* 3)
(defparameter *verbose* nil)

(defvar *ls-stream* nil)
(defvar *editor-stream* t)
(defvar *ls-reply*)
(defvar *ls-reply-status*)

(defvar *ls-magic-1* "<<<--GensymLicensing-->>>")
(defvar *ls-magic-2* "Have a nice day.")

(defvar *ls-command-name* nil)
(defvar *ls-options* nil)
(defparameter *current-product* 'general)

(defun connect-to-server ()
  (when *ls-stream* (disconnect))
  (setq *ls-stream*
        (comm:open-tcp-stream *ls-server-host* *ls-server-port*
                              :direction :io
                              :element-type 'base-char
                              :errorp nil
                              :keepalive t
                              :timeout *timeout*
                              :read-timeout 1))
  (unless *ls-stream*
    (format *editor-stream* "Unable to connect to ~A:~A.~%" *ls-server-host* *ls-server-port*)
    (return-from connect-to-server nil))
  (await-reply))

(defun disconnect ()
  (when *ls-stream*
    (prog1 (close *ls-stream*)
      (setq *ls-stream* nil))))


(defvar *licensing-command-template-1* "~A ~A ~S ~A ~A ~D ~D ~D ~A"
  "licensing-type version machine-id start-date end-date process tw tw2 modules")

(defun initialize-environment (&optional test)
  (let ((options (copy-list (or test sys:*line-arguments-list*))))
    (pop options) ; drop the fist item: program itself
    (let ((commands
           (loop until (null options)
                 for token = (pop options)
                 do (cond ((string= token "-v")
                           (setq *verbose* t))
                          ((string= token "-p")
                           (setq *ls-password* (pop options)))
                          ((string= token "-u")
                           (setq *ls-user* (pop options)))
                          (t (return (cons token options))))
                 finally (return nil))))
      (if commands
		(if (string= "license" (first commands))
		  (setq 
		    *ls-command-name* "license"
			*ls-options* options
		    *ls-command* (format nil *licensing-command-template-1*
              "license" (nth 0 options) (nth 1 options)
              (nth 2 options) (nth 3 options) (nth 4 options)
			  (nth 5 options) (nth 6 options) (nth 7 options)))
          (setq 
		    *ls-command-name* (first commands)
			*ls-options* options
		    *ls-command* (format nil "~{~A~^ ~}" commands)))
        (when (delivered-image-p)
          (setq *ls-command* (or (read-line *terminal-io* nil nil) *ls-command*)))))))

(defun tell-server (q)
  (declare (type string q))
  (format *ls-stream* "~A~A~A" q #\Return #\Newline)
  (force-output *ls-stream*))

(defun await-reply ()
  (let ((return-streams
         (sys:wait-for-input-streams (list *ls-stream*) :timeout *timeout*)))
    (when return-streams
      (loop for line = (read-line *ls-stream* nil nil)
            collect line
            until (or (null line)
                      (string= line *ls-magic-1*)
                      (string= line *ls-magic-2*))))))

;;; `Compute-challenge-response-1' is used to convert a fragment of text
;;; and a number into a scrabled string containing most, but not all the
;;; information in the original.  This is used to encrypt passwords for
;;; storage in the user file (our mimic of a /etc/passwd), and to compute
;;; the response generated by a client to our challenge.

(defun compute-challenge-response-1 (text number)
  (let ((s1
	  (format nil "~A~A~A" number (string-upcase (string text)) number)))
    (loop with seed = 74
	  with sixty-four-nice-chars
	  = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789#@"
	  for i from 0 below (length s1)
	  as c = (char-code (char s1 i))
	  do
      (setf seed (logxor seed c))
      (setf (char s1 i) (char sixty-four-nice-chars (logand 63 seed))))
    s1))

;;; `encrypt-licensing-password' we store user password's in a damaged scramble of
;;; their original form.  This is used only when editing the user list.

(defun encrypt-licensing-password (password)
  (compute-challenge-response-1 password 0))

;;; `Compute-challenge-response' is used by clients to compute the response
;;; to the challenge we give them.  They take the clear text password,
;;; encrypt it (as we do) and then compute a response.

(defun compute-challenge-response (password number)
  (compute-challenge-response-1
    (compute-challenge-response-1 password 0)
    number))

;;; `Correct-response-p' is used to check a response recieved from the user.

(defun correct-response-p (encrypted-password number possible-response)
  (string=
    possible-response
    (compute-challenge-response-1 encrypted-password number)))

(defun authenticate-to-server ()
  (format *editor-stream* "~A~%" *ls-command*)
  (tell-server (format nil "(do-for-me ~A (~A))" *ls-user* *ls-command*))
  (let ((reply (await-reply)))
    (when reply
      (let* ((challenge-line (first reply))) ; i.e. "Challenge: 00000"
        (if (string= challenge-line "ERROR")
            (return-from authenticate-to-server nil)
          (let* ((challenge-number
                  (parse-integer (subseq challenge-line
                                         #.(length "Challenge: "))))
                 (response
                  (compute-challenge-response *ls-password* challenge-number)))
            (tell-server (format nil "(response ~S)" response))
            (await-reply)))))))

(defparameter bundle-template-ok-file-format-string
  ;; args: bundle-name, machine-id-string, authorized-products-list,
  ;;   expiration-date-spec, code-1 code-2 code-3 code-4 code-5
  "begin g2-ok-file
-- This is generated by Gensym Corporation for G2 Server ~A.
file-format-version: 2;
-- Machine Authorizations
begin machine
name: ~(~a~);
machine-id: ~s;
authorized-products: ~a;
expiration-date?: ~a;
authorization: (~a ~a ~a ~a ~a);
make-g2-secure?: false;
authorized-kb-packages: (")	

(defparameter bundle-gsi-ok-file-format-string
  ;; gensym site:gensym-software G2-ODBC V8 408149 4027477 8144383 4975900 221388181
  "gensym ~A ~A ~A ~A ~A ~A ~A ~A")

(defparameter bundle-gsi-ok-file-format-string-with-expriations
  ;; gensym site:gensym-software G2-ODBC V8 FROM 1 1 2010 TO 31 21 2011 408149 4027477 8144383 4975900 221388181
  "gensym ~A ~A ~A ~A ~A ~A ~A ~A")

;;; Part 2: GUI version

;; Program Inputs
;; * Server Host (default: localhost)
;; * Server Port (default: 7535)
;; * User
;; * Password
;; * Command
;; * Trace Log File (optional)

;;; Interface Definitions

(defvar *year-range* '(2011 . 2019))
(defvar *year-table*
  (loop for i from (car *year-range*) to (cdr *year-range*) collect i))

(defvar *month-table*
  '("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"))

(defvar *day-table*
  (loop for i from 1 to 31 collect i))

(capi:define-interface licensing-client-base ()
  ()
  (:panes
   (lc-host
    capi:text-input-pane
    :title "Host:")
   (lc-port
    capi:text-input-pane
    :title "Port:")
   (lc-user
    capi:text-input-pane
    :title "User:")
   (lc-pass
    capi:password-pane
    :title "Password:")
   (lc-output-directory
    capi:text-input-pane
    :title "Output Directory:"
    :file-completion t
    :directories-only t)
   (lc-browse-directory
    capi:push-button
    :text "..."
    :callback-type :interface
    :selection-callback 'choose-directory)
   (lc-generate
    capi:push-button
    :text "Generate!"
    :default-p t
    :callback-type :interface
    :selection-callback 'generate-ok-file))
  (:layouts
   (lc-base-layout
    capi:row-layout
    '(lc-host lc-port lc-user lc-pass))
   (lc-output-layout
    capi:row-layout
    '(lc-output-directory lc-browse-directory lc-generate)
    :y-adjust :center)))

(defparameter *lc-g2-versions*
  '(("5.0" . G2-V5)
    ("6.0/7.0" . G2-V6)
    ("8.0" . G2-V8)
    ("8.3" . G2-V83)
    ("2011" . G2-V2011)
    ("2015" . G2-V2015)))

(defparameter *lc-tw-versions*
  '(("6.0/7.0" . Telewindows-V6)
    ("8.0" . Telewindows-V8)
    ("2011" . Telewindows-V2011)
    ("2015" . Telewindows-V2015)))

(defvar *lc-g2-license-types* '("license" "temporary-license"))
(defvar *lc-g2-version* 0)
(defvar *lc-g2-license-type* 0)
(defvar *lc-g2-machine-id* "SITE:G2_DEVELOPMENT_INTERNAL")
(defvar *lc-g2-start-year*)
(defvar *lc-g2-start-month*)
(defvar *lc-g2-start-day*)
(defvar *lc-g2-end-year*)
(defvar *lc-g2-end-month*)
(defvar *lc-g2-end-day*)
(defvar *lc-g2-number-of-process* 2)
(defvar *lc-g2-maximum-of-tw* 50)
(defvar *lc-g2-maximum-of-tw2* 50)
(defvar *lc-g2-option-modules*)

(capi:define-interface licensing-client-g2 ()
  ()
  (:panes
   (lc-g2-version
    capi:option-pane
    :title "Version:"
    :items (mapcar #'car *lc-g2-versions*))
   (lc-g2-license-type
    capi:option-pane
    :title "License Type:"
    :items *lc-g2-license-types*
    :callback-type :interface
    :selection-callback 'update-status-of-g2-expiration)
   (lc-g2-machine-id
    capi:text-input-pane
    :title "Machine ID:")
   (lc-g2-expiration-date
    capi:title-pane
    :text "Expiration Date:")
   (lc-g2-today
    capi:button
    :text "Today"
    :callback-type :interface
    :selection-callback 'update-date-of-g2-expiration)
   (lc-g2-start-year
    capi:option-pane
    :items *year-table*)
   (lc-g2-start-month
    capi:option-pane
    :items *month-table*
    :title "From ")
   (lc-g2-start-day
    capi:option-pane
    :items *day-table*)
   (lc-g2-end-year
    capi:option-pane
    :items *year-table*)
   (lc-g2-end-month
    capi:option-pane
    :items *month-table*
    :title " to ")
   (lc-g2-end-day
    capi:option-pane
    :items *day-table*)
   (lc-g2-number-of-process
    capi:text-input-pane
    :title "Number of processes authorized:")
   (lc-g2-maximum-of-tw
    capi:text-input-pane
    :title "Maximum number of concurrent floating telewindows allowed:")
   (lc-g2-maximum-of-tw2
    capi:text-input-pane
    :title "Maximum number of concurrent floating tw2 allowed:")
   (lc-g2-optional-modules-1
    capi:check-button-panel
    :title "Product optional modules:"
    :title-position :top
    :items '("GSI" "GSPAN" "ICP" "GFI" "KFEP" "NUPEC" "G1" "JL" "JP" "AL"))
   (lc-g2-optional-modules-2
    capi:check-button-panel
    :items '("Chinese" "Japanese" "Korean"))
   (lc-g2-optional-modules-3
    capi:check-button-panel
    :items '("Online" "Offline" "Runtime" "Restricted-Use" "Embedded" "Ent")))
  (:layouts
   (lc-g2-main-layout
    capi:row-layout
    '(lc-g2-version lc-g2-license-type))
   (lc-g2-expiration-layout
    capi:column-layout
    '(lc-g2-expiration-date lc-g2-expiration-body-layout))
   (lc-g2-expiration-body-layout
    capi:row-layout
    '(lc-g2-start-month lc-g2-start-day lc-g2-start-year
      lc-g2-today
      lc-g2-end-month lc-g2-end-day lc-g2-end-year)
    :y-adjust :center)
   (lc-g2-layout
    capi:column-layout
    '(lc-g2-main-layout
      lc-g2-machine-id
      lc-g2-expiration-layout
      :separator
      lc-g2-number-of-process
      lc-g2-maximum-of-tw
      lc-g2-maximum-of-tw2
      lc-g2-optional-modules-1
      lc-g2-optional-modules-2
      lc-g2-optional-modules-3))))

(defvar *lc-tw-license-types* '("license" "temporary-license"))
(defvar *lc-tw-version* 0)
(defvar *lc-tw-license-type* 0)
(defvar *lc-tw-machine-id* "SITE:G2_DEVELOPMENT_INTERNAL")
(defvar *lc-tw-start-year*)
(defvar *lc-tw-start-month*)
(defvar *lc-tw-start-day*)
(defvar *lc-tw-end-year*)
(defvar *lc-tw-end-month*)
(defvar *lc-tw-end-day*)
(defvar *lc-tw-number-of-process*)
(defvar *lc-tw-option-modules*)

(capi:define-interface licensing-client-tw ()
  ()
  (:panes
   (lc-tw-version
    capi:option-pane
    :title "Version:"
    :items (mapcar #'car *lc-tw-versions*))
   (lc-tw-license-type
    capi:option-pane
    :title "License Type:"
    :items *lc-tw-license-types*
    :callback-type :interface
    :selection-callback 'update-status-of-tw-expiration)
   (lc-tw-machine-id
    capi:text-input-pane
    :title "Machine ID:")
   (lc-tw-expiration-date
    capi:title-pane
    :text "Expiration Date:")
   (lc-tw-today
    capi:button
    :text "Today"
    :callback-type :interface
    :selection-callback 'update-date-of-tw-expiration)
   (lc-tw-start-year
    capi:option-pane
    :items *year-table*)
   (lc-tw-start-month
    capi:option-pane
    :items *month-table*
    :title "From ")
   (lc-tw-start-day
    capi:option-pane
    :items *day-table*)
   (lc-tw-end-year
    capi:option-pane
    :items *year-table*)
   (lc-tw-end-month
    capi:option-pane
    :items *month-table*
    :title " to ")
   (lc-tw-end-day
    capi:option-pane
    :items *day-table*)
   (lc-tw-number-of-process
    capi:text-input-pane
    :title "Number of processes authorized:")
   (lc-tw-optional-modules
    capi:check-button-panel
    :items '("Restricted-Use" "Chinese" "Japanese" "Korean"))
   (lc-tw-output-directory
    capi:text-input-pane
    :title "Output Directory:"
    :file-completion t
    :directories-only t)
   (lc-tw-browse-directory
    capi:push-button
    :text "..."
    :callback-type :interface
    :selection-callback 'choose-directory)
   (lc-tw-generate
    capi:push-button
    :text "Generate!"
    :default-p t
    :callback-type :interface
    :selection-callback 'generate-ok-file))
  (:layouts
   (lc-tw-main-layout
    capi:row-layout
    '(lc-tw-version lc-tw-license-type))
   (lc-tw-expiration-layout
    capi:column-layout
    '(lc-tw-expiration-date lc-tw-expiration-body-layout))
   (lc-tw-expiration-body-layout
    capi:row-layout
    '(lc-tw-start-month lc-tw-start-day lc-tw-start-year
      lc-tw-today
      lc-tw-end-month lc-tw-end-day lc-tw-end-year)
    :y-adjust :center)
   (lc-tw-ok-layout
    capi:row-layout
    '(lc-tw-output-directory lc-tw-browse-directory lc-tw-generate)
    :y-adjust :center)
   (lc-tw-layout
    capi:column-layout
    '(lc-tw-main-layout
      lc-tw-machine-id
      lc-tw-expiration-layout
      :separator
      lc-tw-number-of-process
      lc-tw-optional-modules))))

(capi:define-interface licensing-client-gsi ()
  ()
  (:layouts
   (lc-gsi-layout
    capi:column-layout
    '())))

(capi:define-interface licensing-client (licensing-client-base
                                         licensing-client-g2
                                         licensing-client-tw
                                         licensing-client-gsi)
  ()
  (:panes
   (lc-command
    capi:text-input-pane
    :title "Command:"
    :title-position :top)
   (lc-display
    capi:collector-pane
    :title "Output:")
   (lc-title-output
    capi:title-pane
    :text "Output:"))
  (:layouts
   (lc-column-layout
    capi:column-layout
    '(lc-base-layout lc-tab-layout lc-output-layout))
   (lc-general-layout
    capi:column-layout
    '(lc-command lc-display))
   (lc-tab-layout
    capi:tab-layout nil
    :items '(("General" . lc-general-layout)
             ("G2" . lc-g2-layout)
             ("TW" . lc-tw-layout)
             ("GSI" . lc-gsi-layout))
    :print-function 'car
    :visible-child-function 'cdr
    :combine-child-constraints t
    :callback-type :item
    :selection-callback 'update-current-product))
  (:default-initargs
   :destroy-callback 'save-and-quit
   :layout 'lc-column-layout))

(defmethod capi:interface-display :before ((self licensing-client))
  (setf (capi:interface-title self)
        (format nil "G2 Licensing Client ~D.~Dr~D"
                *major-version* *minor-version* *revision*))
  (update-interface-from-config self))

(defmethod capi:interface-display :after ((self licensing-client))
  (setq *editor-stream*
        (capi:collector-pane-stream (slot-value self 'lc-display))))

(defmethod capi:interface-display :after ((self licensing-client-g2))
  (update-status-of-g2-expiration self)
  (update-date-of-g2-expiration self))

(defmethod capi:interface-display :after ((self licensing-client-tw))
  (update-status-of-tw-expiration self)
  (update-date-of-tw-expiration self))

(defun update-current-product (item)
  (setq *current-product* (intern (string-upcase (car item))))) ; G2/TW/GSI

(defun update-status-of-g2-expiration (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (flet ((set-g2-expiration (enabled-p)
             (setf (capi:option-pane-enabled (slot lc-g2-start-year)) enabled-p
                   (capi:option-pane-enabled (slot lc-g2-start-month)) enabled-p
                   (capi:option-pane-enabled (slot lc-g2-start-day)) enabled-p
                   (capi:option-pane-enabled (slot lc-g2-end-year)) enabled-p
                   (capi:option-pane-enabled (slot lc-g2-end-month)) enabled-p
                   (capi:option-pane-enabled (slot lc-g2-end-day)) enabled-p
                   (capi:button-enabled (slot lc-g2-today)) enabled-p)))
      (case (capi:choice-selection (slot lc-g2-license-type))
        (0 (set-g2-expiration nil))
        (1 (set-g2-expiration t))))))

(defun update-status-of-tw-expiration (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (flet ((set-tw-expiration (enabled-p)
             (setf (capi:option-pane-enabled (slot lc-tw-start-year)) enabled-p
                   (capi:option-pane-enabled (slot lc-tw-start-month)) enabled-p
                   (capi:option-pane-enabled (slot lc-tw-start-day)) enabled-p
                   (capi:option-pane-enabled (slot lc-tw-end-year)) enabled-p
                   (capi:option-pane-enabled (slot lc-tw-end-month)) enabled-p
                   (capi:option-pane-enabled (slot lc-tw-end-day)) enabled-p
                   (capi:button-enabled (slot lc-tw-today)) enabled-p)))
      (case (capi:choice-selection (slot lc-tw-license-type))
        (0 (set-tw-expiration nil))
        (1 (set-tw-expiration t))))))

(defun update-date-of-g2-expiration (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (multiple-value-bind (second minute hour date month year day-of-week
                          daylight-saving-time-p time-zone)
        (get-decoded-time)
      (declare (ignore second minute hour day-of-week daylight-saving-time-p time-zone))
      (setf (capi:choice-selection (slot lc-g2-start-year))
            (- year (car *year-range*))
            (capi:choice-selection (slot lc-g2-start-month))
            (1- month)
            (capi:choice-selection (slot lc-g2-start-day))
            (1- date)))
    (multiple-value-bind (second minute hour date month year day-of-week
                          daylight-saving-time-p time-zone)
        (decode-universal-time (+ (get-universal-time) #.(* 30 24 60 60))) ; +30 days
      (declare (ignore second minute hour day-of-week daylight-saving-time-p time-zone))
      (setf (capi:choice-selection (slot lc-g2-end-year))
            (- year (car *year-range*))
            (capi:choice-selection (slot lc-g2-end-month))
            (1- month)
            (capi:choice-selection (slot lc-g2-end-day))
            (1- date)))))

(defun update-date-of-tw-expiration (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (multiple-value-bind (second minute hour date month year day-of-week
                          daylight-saving-time-p time-zone)
        (get-decoded-time)
      (declare (ignore second minute hour day-of-week daylight-saving-time-p time-zone))
      (setf (capi:choice-selection (slot lc-tw-start-year))
            (- year (car *year-range*))
            (capi:choice-selection (slot lc-tw-start-month))
            (1- month)
            (capi:choice-selection (slot lc-tw-start-day))
            (1- date)))
    (multiple-value-bind (second minute hour date month year day-of-week
                          daylight-saving-time-p time-zone)
        (decode-universal-time (+ (get-universal-time) #.(* 30 24 60 60))) ; +30 days
      (declare (ignore second minute hour day-of-week daylight-saving-time-p time-zone))
      (setf (capi:choice-selection (slot lc-tw-end-year))
            (- year (car *year-range*))
            (capi:choice-selection (slot lc-tw-end-month))
            (1- month)
            (capi:choice-selection (slot lc-tw-end-day))
            (1- date)))))

(defun choose-directory (interface)
  (let ((p (capi:prompt-for-directory "OK File Location")))
    (when (pathnamep p)
      (setq *lc-g2-output-directory* p)
      (setf (capi:text-input-pane-text (slot-value interface 'lc-output-directory))
            (namestring p)))))

(defun ensure-output-directory (interface)
  (let ((interface-data
         (capi:text-input-pane-text (slot-value interface 'lc-output-directory)))
        (variable-data
         (namestring *lc-g2-output-directory*)))
    (unless (string= interface-data variable-data)
      (setf *lc-g2-output-directory*
            (ensure-directories-exist (pathname interface-data))))))

(defparameter *licensing-command-template* "~A ~A ~S ~A ~A ~A ~A ~A ~A"
  "licensing-type version machine-id start-date end-date process tw tw2 modules")

(defun ensure-g2-command (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (setq *lc-g2-option-modules*
          (concatenate 'list
                       (capi:choice-selected-items (slot lc-g2-optional-modules-1)) 
                       (capi:choice-selected-items (slot lc-g2-optional-modules-2)) 
                       (capi:choice-selected-items (slot lc-g2-optional-modules-3)))
          *lc-g2-start-day*   (1+ (capi:choice-selection (slot lc-g2-start-day)))
          *lc-g2-start-month* (1+ (capi:choice-selection (slot lc-g2-start-month)))
          *lc-g2-start-year*  (+ (car *year-range*)
                                 (capi:choice-selection (slot lc-g2-end-year)))
          *lc-g2-end-day*     (1+ (capi:choice-selection (slot lc-g2-end-day)))
          *lc-g2-end-month*   (1+ (capi:choice-selection (slot lc-g2-end-month)))
          *lc-g2-end-year*    (+ (car *year-range*)
                                 (capi:choice-selection (slot lc-g2-end-year)))
          *lc-g2-license-type* (capi:choice-selection (slot lc-g2-license-type)))
    (let* ((version (capi:choice-selection (slot lc-g2-version)))
           (machine (capi:text-input-pane-text (slot lc-g2-machine-id)))
           (start   (unless (zerop *lc-g2-license-type*) ; permenant
                      (list *lc-g2-start-day* *lc-g2-start-month* *lc-g2-start-year*)))
           (end     (unless (zerop *lc-g2-license-type*) ; permenant
                      (list *lc-g2-end-day* *lc-g2-end-month* *lc-g2-end-year*)))
           (n-p     (capi:text-input-pane-text (slot lc-g2-number-of-process)))
           (tw      (capi:text-input-pane-text (slot lc-g2-maximum-of-tw)))
           (tw2     (capi:text-input-pane-text (slot lc-g2-maximum-of-tw2)))
           (modules *lc-g2-option-modules*))
      (format nil *licensing-command-template*
              (nth *lc-g2-license-type* *lc-g2-license-types*)
              (cdr (nth version *lc-g2-versions*))
              machine
              start end
              n-p tw tw2
              modules))))

(defun ensure-tw-command (interface)
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (setq *lc-tw-option-modules*
          (concatenate 'list
                       (capi:choice-selected-items (slot lc-tw-optional-modules)))
          *lc-tw-start-day*   (1+ (capi:choice-selection (slot lc-tw-start-day)))
          *lc-tw-start-month* (1+ (capi:choice-selection (slot lc-tw-start-month)))
          *lc-tw-start-year*  (+ (car *year-range*)
                                 (capi:choice-selection (slot lc-tw-end-year)))
          *lc-tw-end-day*     (1+ (capi:choice-selection (slot lc-tw-end-day)))
          *lc-tw-end-month*   (1+ (capi:choice-selection (slot lc-tw-end-month)))
          *lc-tw-end-year*    (+ (car *year-range*)
                                 (capi:choice-selection (slot lc-tw-end-year)))
          *lc-tw-license-type* (capi:choice-selection (slot lc-tw-license-type))
          *lc-tw-number-of-process* (capi:text-input-pane-text (slot lc-tw-number-of-process)))
    (let* ((version (capi:choice-selection (slot lc-tw-version)))
           (machine (capi:text-input-pane-text (slot lc-tw-machine-id)))
           (start   (unless (zerop *lc-tw-license-type*) ; permenant
                      (list *lc-tw-start-day* *lc-tw-start-month* *lc-tw-start-year*)))
           (end     (unless (zerop *lc-tw-license-type*) ; permenant
                      (list *lc-tw-end-day* *lc-tw-end-month* *lc-tw-end-year*)))
           (n-p     *lc-tw-number-of-process*)
           (modules *lc-tw-option-modules*))
      (format nil *licensing-command-template*
              (nth *lc-tw-license-type* *lc-tw-license-types*)
              (cdr (nth version *lc-tw-versions*))
              machine
              start end
              (if (string= "" n-p) nil n-p) ; number-of-process
              nil nil
              modules))))

(defun generate-ok-file (interface)
  (update-config-from-interface interface)
  (ensure-output-directory interface)
  (let ((*ls-command*
         (case *current-product*
           (general (capi:text-input-pane-text (slot-value interface 'lc-command)))
           (g2 (ensure-g2-command interface))
           (tw (ensure-tw-command interface)))))
    (when (connect-to-server)
      (let ((reply (authenticate-to-server)))
        (if (and (string= "To Clorox a horse." (first reply))
                 (>= (length reply) 7))
            (case *current-product*
              (general (format *editor-stream* "~a~%" reply))
              (g2 (write-g2-server-ok-file reply))
              (tw (write-tw-ok-file reply)))
          (format *editor-stream* "ERROR: cannot understand the reply: ~A~%" reply))))))

(defparameter bundle-template-ok-file-format-string-1
  ;; args: bundle-name, machine-id-string, authorized-products-list,
  ;;   expiration-date-spec, code-1 code-2 code-3 code-4 code-5
  "begin g2-ok-file
-- This is generated by Gensym Corporation for G2 Server ~A.
file-format-version: 2;
-- Machine Authorizations
begin machine
  name: ~(~a~);
  machine-id: ~s;
  authorized-products: (~{~a~^ ~});
  expiration-date?: ~a;
  authorization: (~a ~a ~a ~a ~a);
  make-g2-secure?: false;
  authorized-kb-packages: (")

(defparameter bundle-template-expiration-template-format-string
  ;; args: 
  ;;   start-day symbolic-start-month start-year
  ;;   end-day symbolic-end-month start-year
  "(from ~d ~(~a~) ~d to ~d ~(~a~) ~d)")

(defparameter tw-expiration-template-format-string
  ;; args: 
  ;;   start-day symbolic-start-month start-year
  ;;   end-day symbolic-end-month start-year
  " from ~d ~(~a~) ~d to ~d ~(~a~) ~d")

(defparameter bundle-template-null-expiration-format-string
  ;; args: (none)
  "none")

(defparameter bundle-template-ok-file-format-string-2
  ;; args: process-limit, tw-floaters, tw2-floaters
  ");
  number-of-processes-authorized: ~d;
  maximum-number-of-concurrent-floating-telewindows-allowed: ~d;
  maximum-number-of-concurrent-floating-tw2-allowed: ~d;
end machine
-- There were no named users in the KB.
-- End of file marker
end g2-ok-file
")

(defparameter template-tw-ok-file-format-string-1
  ;; args: bundle-name, machine-id-string
  ;;       code-1, code-2, code-3, code-4, code-5
  "~a ~a ~d ~d ~d ~d ~d")

(defun write-g2-server-ok-file (reply)
  (let* ((filename "g2") ; old: (read-from-string (nth 6 reply))), meaningless
         (pathname (make-pathname :name filename :type "ok"
                                  :defaults *lc-g2-output-directory*)))
    (with-open-file (f pathname :direction :output
                       :element-type 'base-char
                       :if-exists :supersede)
      (format f bundle-template-ok-file-format-string-1
              (car (nth *lc-g2-version* *lc-g2-versions*))
              "gensym" ; name
              *lc-g2-machine-id* ; machine-id
              *lc-g2-option-modules*  ; authorized-products
              bundle-template-null-expiration-format-string
              (nth 1 reply)
              (nth 2 reply)
              (nth 3 reply)
              (nth 4 reply)
              (nth 5 reply))
      (format f bundle-template-ok-file-format-string-2
              *lc-g2-number-of-process*
              *lc-g2-maximum-of-tw*
              *lc-g2-maximum-of-tw2*))
    (capi:display-message "OK file ~A generated." pathname)))

(defun write-tw-ok-file (reply)
  (let* ((filename "tw")
         (pathname (make-pathname :name filename :type "ok"
                                  :defaults *lc-g2-output-directory*)))
    (with-open-file (f pathname :direction :output
                       :element-type 'base-char
                       :if-exists :supersede)
      (format f template-tw-ok-file-format-string-1
              "gensym" ; name
              *lc-tw-machine-id* ; machine-id
              (nth 1 reply)
              (nth 2 reply)
              (nth 3 reply)
              (nth 4 reply)
              (nth 5 reply))
      (when *lc-tw-option-modules*
        (format f " (~{~a~^ ~})" *lc-tw-option-modules*))
      (when (plusp *lc-tw-license-type*) ; temporary-license
        (format f tw-expiration-template-format-string
                *lc-tw-start-day*
                (nth (1- *lc-tw-start-month*) *month-table*)
                *lc-tw-start-year*
                *lc-tw-end-day*
                (nth (1- *lc-tw-end-month*) *month-table*)
                *lc-tw-end-year*))
      (when (string-not-equal "" *lc-tw-number-of-process*)
        (format f " ~a" *lc-tw-number-of-process*))
      (format f "~%"))
    (capi:display-message "OK file ~A generated." pathname)))

(defun write-gsi-server-ok-file (reply)
  (let* ((filename "gsi")
         (pathname (make-pathname :name filename :type "ok"
                                  :defaults *lc-g2-output-directory*)))
    (with-open-file (f pathname :direction :output
                       :element-type 'base-char
                       :if-exists :supersede)
      (format f bundle-gsi-ok-file-format-string
              (nth 1 *ls-options*)
              (nth 6 reply)
              (nth 7 reply)
              (nth 1 reply)
              (nth 2 reply)
              (nth 3 reply)
              (nth 4 reply)
              (nth 5 reply))
    (format *editor-stream* "OK file ~A generated.~%" pathname))))

;;; Configure System

(defun integer->string (int)
  (format nil "~D" int))

(defun string->integer (str)
  (parse-integer str :junk-allowed t))

(defgeneric update-interface-from-config (interface)
  (:method-combination progn))

(defmethod update-interface-from-config progn ((interface licensing-client-base))
  (with-slots (lc-host lc-port lc-user lc-pass lc-output-directory) interface
    (setf (capi:text-input-pane-text lc-host) *ls-server-host*
          (capi:text-input-pane-text lc-port) (integer->string *ls-server-port*)
          (capi:text-input-pane-text lc-user) *ls-user*
          (capi:text-input-pane-text lc-pass) *ls-password*)
    (setf (capi:text-input-pane-text lc-output-directory)
          (namestring (truename *lc-g2-output-directory*)))))

(defmethod update-interface-from-config progn ((interface licensing-client-g2))
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (when (boundp '*lc-g2-version*)
      (setf (capi:choice-selection (slot lc-g2-version))
            *lc-g2-version*))
    (when (boundp '*lc-g2-license-type*)
      (setf (capi:choice-selection (slot lc-g2-license-type))
            *lc-g2-license-type*))
    (when (boundp '*lc-g2-machine-id*)
      (setf (capi:text-input-pane-text (slot lc-g2-machine-id))
            *lc-g2-machine-id*))
    (when (boundp '*lc-g2-number-of-process*)
      (setf (capi:text-input-pane-text (slot lc-g2-number-of-process))
            (integer->string *lc-g2-number-of-process*)))
    (when (boundp '*lc-g2-maximum-of-tw*)
      (setf (capi:text-input-pane-text (slot lc-g2-maximum-of-tw))
            (integer->string *lc-g2-maximum-of-tw*)))
    (when (boundp '*lc-g2-maximum-of-tw2*)
      (setf (capi:text-input-pane-text (slot lc-g2-maximum-of-tw2))
            (integer->string *lc-g2-maximum-of-tw2*)))))

(defmethod update-interface-from-config progn ((interface licensing-client-tw))
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (when (boundp '*lc-tw-version*)
      (setf (capi:choice-selection (slot lc-tw-version))
            *lc-tw-version*))
    (when (boundp '*lc-tw-license-type*)
      (setf (capi:choice-selection (slot lc-tw-license-type))
            *lc-tw-license-type*))
    (when (boundp '*lc-tw-machine-id*)
      (setf (capi:text-input-pane-text (slot lc-tw-machine-id))
            *lc-tw-machine-id*))
    (when (boundp '*lc-tw-number-of-process*)
      (setf (capi:text-input-pane-text (slot lc-tw-number-of-process))
            (format nil "~A" *lc-tw-number-of-process*)))))

(defgeneric update-config-from-interface (interface)
  (:method-combination progn))

(defmethod update-config-from-interface progn ((interface licensing-client-base))
  (with-slots (lc-host lc-port lc-user lc-pass lc-output-directory) interface
    (setf *ls-server-host* (capi:text-input-pane-text lc-host)
          *ls-server-port* (string->integer (capi:text-input-pane-text lc-port))
          *ls-user* (capi:text-input-pane-text lc-user)
          *ls-password* (capi:text-input-pane-text lc-pass))
    (setf *lc-g2-output-directory*
          (pathname (capi:text-input-pane-text lc-output-directory)))))

(defmethod update-config-from-interface progn ((interface licensing-client-g2))
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (setf *lc-g2-version* (capi:choice-selection (slot lc-g2-version))
          *lc-g2-license-type* (capi:choice-selection (slot lc-g2-license-type))
          *lc-g2-machine-id* (capi:text-input-pane-text (slot lc-g2-machine-id)))
    (setf *lc-g2-number-of-process*
          (string->integer (capi:text-input-pane-text (slot lc-g2-number-of-process)))
          *lc-g2-maximum-of-tw*
          (string->integer (capi:text-input-pane-text (slot lc-g2-maximum-of-tw)))
          *lc-g2-maximum-of-tw2*
          (string->integer (capi:text-input-pane-text (slot lc-g2-maximum-of-tw2))))))

(defmethod update-config-from-interface progn ((interface licensing-client-tw))
  (macrolet ((slot (s) `(slot-value interface ',s)))
    (setf *lc-tw-version* (capi:choice-selection (slot lc-tw-version))
          *lc-tw-license-type* (capi:choice-selection (slot lc-tw-license-type))
          *lc-tw-machine-id* (capi:text-input-pane-text (slot lc-tw-machine-id)))
    (setf *lc-tw-number-of-process*
          (capi:text-input-pane-text (slot lc-tw-number-of-process)))))

(defvar *config-file* (compile-file-pathname "config"))

(defun save-and-quit (interface)
  (update-config-from-interface interface)
  (hcl:dump-forms-to-file *config-file*
    `((setq *ls-server-host* ,*ls-server-host*
            *ls-server-port* ,*ls-server-port*
            *ls-user* ,*ls-user*
            *ls-password* ,*ls-password*
            *lc-g2-version* ,*lc-g2-version*
            *lc-g2-license-type* ,*lc-g2-license-type*
            *lc-g2-machine-id* ,*lc-g2-machine-id*
            *lc-g2-output-directory* ,*lc-g2-output-directory*
            *lc-g2-number-of-process* ,*lc-g2-number-of-process*
            *lc-g2-maximum-of-tw* ,*lc-g2-maximum-of-tw*
            *lc-g2-maximum-of-tw2* ,*lc-g2-maximum-of-tw2*)
      (setq *lc-tw-version* ,*lc-tw-version*
            *lc-tw-license-type* ,*lc-tw-license-type*
            *lc-tw-machine-id* ,*lc-tw-machine-id*
            *lc-tw-number-of-process* ,*lc-tw-number-of-process*)))
  (when (hcl:delivered-image-p)
    (lw:quit)))

(defun load-config ()
  (when (probe-file *config-file*)
    (sys:load-data-file *config-file* :verbose nil :print nil)))

;;; Patch System

(defun patch-pathname (i)
  (make-pathname :name (format nil "~4,'0D" i)
                 :type sys:*binary-file-type*
                 :directory '(:relative "patch" "licensing-client")
                 :defaults *default-pathname-defaults*))

(defun list-patches ()
  (let ((patch-files nil))
    (loop for i from 1 do
       (let ((patch-file (patch-pathname i)))
         (if (probe-file patch-file)
             (push patch-file patch-files)
           (loop-finish))))
    (nreverse patch-files)))

(defun load-patches (&aux (counter 0))
  (dolist (i (list-patches))
    (handler-case (prog1 (load i :verbose nil :print nil)
                    (incf counter))
      (error (c)
        (format *editor-stream* "Error when loading a patch (~A)~%" i)))))
