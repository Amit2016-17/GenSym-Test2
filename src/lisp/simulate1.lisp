;; -*- Mode: Lisp; Package: AB; Base: 10; Syntax: Common-Lisp -*-
(in-package "AB")

;;;; Module SIMULATE1

;;; Copyright (c) 1986 - 2017 Gensym Corporation.
;;; All Rights Reserved.

;;; Andreas Hofmann



;;;; Overview

;;; The G2 simulator is a general purpose time-based simulator.  Both continuous
;;; and discrete simulations can be specified using differential, difference, and
;;; algebraic equations which are entered by the user.



;;;; G2 Simulation Features

;;; 1.  Unlike some other simulators, the G2 simulator does not calculate new
;;; values for variables using values from the previous cycle.  Doing this
;;; assumes that every variable is a state variable and can introduce incorrect
;;; dynamics into the simulation.  There is a need for dependent variables whose
;;; values are computed using values of other variables computed during the new
;;; cycle rather than the previous cycle.  In the G2 simulator, variables are
;;; clearly divided into two simulation categories: state, and dependent.
;;; Linear systems are usually described using this convention:

;;; x' = Ax + Bu,   y = cx
;;; where 
;;; x = [x1 x2 ... xn]T,  A is a matrix of constants, B = [b1 b2 ... bn]T, 
;;; and c = [c1 c2 ... cn]

;;; Non-linear systems can also be represented in this way.  The state variable
;;; approach is also used in SIMNON and most control engineers should be
;;; familiar with it.

;;; For this simulator, declaring a variable to be a state variable means that
;;; when it appears in a simulation expression, its previous value will be used.
;;; Thus, if the simulator is currently calculating simulated values for
;;; generation k, then if it comes across state variable x1, the value of x1 for
;;; generation k - 1 will be used.  Conversely, declaring a variable to be a
;;; dependent variable means that its current value will be used.  If the
;;; current value is not yet known, it must be calculated.  Input variables will
;;; usually be constants, functions of constants, or functions of externally
;;; supplied data.  In some cases, there may be a need to make input variables
;;; functions of state or dependent variables.  This is OK as long as the input
;;; variable has at least one well founded support.  The basic distinction of
;;; input variables from dependent variables is the fact that input variables
;;; are functions of something other than just dependent and state variables.
;;; These other values are "external" in the sense that they may be provided
;;; externally from the simulator or they may be generated by the simulator
;;; (random values, wave functions of time).  The "external" value may just be a
;;; constant in which case the distinction from dependent variables is once
;;; again blurred.

;;; Initial values have to be supplied only for state variables, not for 
;;; dependent variables.

;;; 2.  Different simulation time increments are possible.  The simulation
;;; parameter frame will contain the default simulation time increment.  The
;;; user can also specify individual time increments for each variable.  This
;;; means that portions of the simulation can be run at smaller or larger time
;;; steps than other portions of the simulation.

;;; 3.  The simulator can handle loops in simulation equations as long as each
;;; simulated variable has at least one well founded support.  Some TMS
;;; techniques are used here.  Variables have at most one applicable runtime
;;; equation so there is never any chance of conflicting values (as is the case
;;; with rule based systems).  The TMS techniques don't have to be as
;;; complicated as those for a true tms expert system.  Because there is no
;;; evidence combination here, partial values (value of x excluding a, value of
;;; x excluding b and c) don't have to be cached.

;;; 4.  Differential equations, distinct from difference equations are
;;; available.  Only ordinary first order differential equations are allowed.
;;; Higher order systems can always be constructed from systems of first order
;;; equations.  A fourth order Runge-Kutta integration algorithm has been
;;; implemented.

;;; 5.  Generic simulation equations allow for a very object oriented approach
;;; to simulation.  Components can be defined and then linked on a schematic to
;;; automatically define the entire system.  Connection of components is a
;;; complex issue mainly due to the resulting simultaneous non-linear equations
;;; that have to be solved.  Since the simulator does not currently solve
;;; simultaneous equations, there are some restrictions here and algebraic loops
;;; are not allowed.  The ultimate goal however is to allow specification of
;;; components and arbitrary connection of these components to simulate an
;;; entire system.  Analysis of this problem has driven the development of this 
;;; whole simulator.


;;;; Equation Caching and other Efficiency Issues

;;; In the simulator, specific equations are derived at initialization time rather
;;; than at runtime.  Thus, it is different from the inference engine in that more
;;; runtime information is cached, resulting in better speed.

;;; The specific equations for a simulation can be specified in terms of
;;; schematics and generic simulation formulas.  In the 1.0 simulator, the
;;; information in the schematic and generic simulation formulas was not actually
;;; combined into specific equations before the simulation was started.  This
;;; meant that the specific equations were actually being derived each time
;;; through the simulation cycle.  This is also the approach used in the inference
;;; engine.  While this simplifies issues of editing while running, it greatly
;;; reduces the speed of the simulator.  It also prevents use of more advanced
;;; numerical techniques which really require the actual specific equations.  The
;;; new approach can be summarized as better caching and sorting to increase
;;; speed.  For dependent variables that are sorted, there is no recursion to
;;; evaluate other variables (there is still recursion in sim-eval when evaluating
;;; an expression).  This approach will also lead to significant other
;;; improvements since it facilitates use of more advanced numerical techniques.
;;; Also, this paves the way for eventual compilation of individual formulas or
;;; groups of formulas, and compilation of the entire simulation into one
;;; function.  The caching technique augments rather than replaces the completely
;;; interpretive approach used in 1.0; the interpretive approach is still needed
;;; for roles that can't be cached and for displays if they are not cached.

;;; The issue of editing while running gets more complicated with this approach.
;;; Installation methods have to be more sophisticated.  When the specific
;;; equations are derived, links are set up between the equations and the objects,
;;; connections, and statements that effect them.  If any of these are edited
;;; while running, installation methods will cause the specific equations effected
;;; to be re-derived.  This is basically a caching - uncaching problem with the
;;; usual complexity associated with knowing when to uncache.  See the section
;;; "Editing While Simulator is Running" below for more details.

;;; Another important design feature which improves efficiency is that variables
;;; are grouped by their time increments for update.  Thus, rather than computing
;;; for each variable whether it should get updated during a cycle, the
;;; computation is done for the whole group.  This yields a big efficiency
;;; improvement given that there are typically many more variables than groups.

;;; Simulation evaluators return one value rather than multiple values as is
;;; done in the inference engine, resulting in better efficiency.


;; Notes on Equation Caching

;; Generating all the specific equations at initialization time does use up a lot
;; of runtime memory.  One way to solve this would be to use the generic
;; simulation formula with the designations replaced by local variables.  These
;; local variables could then be bound on an a managed array for each specific
;; equation.  Thus, a separate copy of the formula need not be made for each
;; specific equation; the generic formula is still used.  The only extra memory
;; needed for the specific equations is for the arrays.  Another way would be to
;; use the eventual official role caching mechanism but this may be too slow.  I
;; discussed this with Jim and we concluded that even in a very large simulation
;; of 10,000 variables, with each equation taking about 20 conses, the memory
;; occupied is still only 200,000 words or 800,000 bytes.  This would all have to
;; be cached in runtime memory to allow running without paging.  This is not so
;; bad since it would replace the schematic info (objects and connections) and
;; also generic simulation formulas that would otherwise have to be in runtime
;; memory to support role service.  On the other hand, these things will typically
;; have to be in runtime memory anyway for the inference engine.  In conclusion, I
;; guess that we should be able to have everything in (8 or 16 meg.) of runtime
;; memory so that we don't have to do any paging.  Note that there is also some
;; (relatively small) amount of overhead in conses for caches of runtime
;; structures effected when some thing is edited.

;; Note that the caching done here differs from role caching in that the formula
;; itself, as well as the roles, are cached.  Also, designations, even complex
;; ones consisting of chains of roles, are converted into the designated variable
;; which is cached.  Thus, the caching done in the simulator goes a step further
;; than just role caching.  For this reason decaching simulation formulas is not
;; as simple as decaching roles (see
;; decache-roles-for-entities-related-to-this-connection).  In the simulator, it
;; is necessary to maintain lists of variables effected by an object or statement
;; and decache the runtime formulas for these variables when an object or
;; statement is edited.  Another important difference is that in the simulator,
;; the runtime formula for a variables is immediately rederived after decaching
;; (if the variable is still being simulated) whereas roles are cached
;; opportunistically.

;; This approach also allows for giving better error messages before the
;; simulation is even started about things like loops.

;; A good benchmark kb is pointer-on-cart.  It has a good mix of state and
;; dependent variables, no ordering or algebraic loops, and does almost nothing
;; except simulation.  AGH>sim-bench-2 is derived from this.

;; When generating the runtime formulas, I should be able to note what the
;; variable types are (since I am evaluating the designations) and use typed
;; operators.  This is an important issue for when we compile to lisp but it is
;; possible to do this even now.

;; We have thought about using this general approach (converting generic things
;; into their specific instances) for the inference engine.  The main drawback to
;; doing this is that generic rules often do a lot of iteration.  Thus, one
;; generic rule can correspond to 1000 rule instances.  Keeping all of them would
;; put a huge drain on runtime memory.  This problem is not so severe with generic
;; simulation formulas.  These really have only one "iteration" clause, the "any"
;; on the left hand side.  Also, in simulation, it is necessary to use all the
;; equations each and every time step so caching them is much more time efficient
;; than re-deriving them each step.  Finally, the specific equations are needed
;; for more advanced numerical techniques although they would typically be
;; transformed into some kind of matrix runtime structure.




;;;; Editing While Simulator is Running


;;; Synchronous Handling of Changes by the Simulator

;;; Edits made while the simulator is running must be handled such that runtime
;;; structures affected by the edits are updated appropriately.  Support for this
;;; is provided by check-for-simulation-changes,
;;; handle-editing-changes-effecting-simulation, add-variable-to-simulation,
;;; remove-variable-from-simulation, and
;;; update-runtime-structures-according-to-edit.

;;; Edits are initially handled by slot putters and editing functions (see
;;; install).  These slot putters and editing functions do not necessarily
;;; immediately update runtime structures.  The general strategy is to update the
;;; runtime structures for the simulator in a synchronous manner; at the beginning
;;; of a simulation cycle rather than any time in the middle of it when it may be
;;; suspended.  Thus, edits made in the middle of a simulation cycle while the
;;; simulator is suspended are noted (see
;;; update-runtime-structures-according-to-edit).  Check-for-simulation-changes,
;;; called at the beginning of simulate-until-consistent-with-gensym-time, checks
;;; for changes.  If any have occurred, the simulation resumption stack is popped
;;; so that the current simulation cycle is abandoned.  Runtime structures are
;;; re-derived based on the changes and the simulation cycle is repeated.  If the
;;; simulator is about to start a new simulation cycle when
;;; simulate-until-consistent-with-gensym-time is called, the simulation
;;; resumption stack will be nil and there is no need to pop it.  The simulation
;;; cycle can simply be executed in this case, after runtime structures have been
;;; re-derived.

;;; The action of popping the simulation resumption stack amounts to a rollback of
;;; the simulation to the beginning of the current cycle.  It is a true rollback
;;; in that the simulator is side-effect free (outside of the simulation
;;; environment) until update-variables has been called at the end of
;;; simulate-one-cycle.  This is because during the simulation cycle, values
;;; computed for that cycle are put into the new-simulation-value slot of
;;; variable-simulation-runtime-structures rather than in the (current)
;;; simulation-value slot.  They are only transferred at the very end.

;; Actually, review set-external-variable-for-simulator.  It is an exception
;; to the above side-effect free rule in that it sets both current and simulated
;; values.

;; Update of variables must be done just before incrementing simulation time and
;; must be un-interruptable.  Not doing this would allow rollback to occur (if an
;; edit is made while the simulation is suspended) after some variables have been
;; updated which would leave the simulation in an inconsistent state.  Actually,
;; one way around this would be to not do a rollback if the edit change occurs
;; while suspended in the middle of update-variables.  The edit changes could just
;; be handled but would not be used until the next cycle.  The best way though is
;; to simplify/eliminate update-variables as explained in "ma:>agh>to-do.text".

;;; The only exception to synchronous handling of changes is in the case of
;;; removing variables from simulation, handled by remove-variable-from-simulation.
;;; If the variable is being deleted (by delete-frame), the simulation runtime
;;; structure for the variable will also be deleted (by the slot value reclaimer
;;; for simulation-runtime-information?).  Remove-variable-from-simulation checks
;;; for this by checking the frame-being-deleted flag of the variable.  If this is
;;; the case (the clean-up method for the variable is invoking
;;; remove-variable-from-simulation), then remove-variable-from-simulation removes
;;; the simulation runtime structure from current-model-runtime-info? immediately, even
;;; if the simulator is currently suspended in the middle of a simulation cycle.
;;; When the simulator is resumed, it will notice the change and repeat the
;;; simulation cycle.

;;; Handle-editing-changes-effecting-simulation is called by
;;; check-for-simulation-changes if changes have been detected.  It updates
;;; simulation runtime structures for variables in the lists in the
;;; variables-whose-runtime-structures-must-be-rederived slots of
;;; current-model-runtime-info?.  These lists are set up as a result of editing
;;; (see add-variable-to-simulation, remove-variable-from-simulation, and
;;; update-runtime-structures-according-to-edit).  As mentioned above, this
;;; approach is used so that the update of simulation runtime structures happens
;;; synchronously (at the beginning of the simulation cycle) rather than
;;; asyncronously (when the edit is made).  The lists are reclaimed and the
;;; special variables set to nil.

;;; Handle-editing-changes-effecting-simulation is not suspendable because
;;; add-to-structures-effected-by-edit-cache sets the frame serial number for the
;;; cache (see also add-to-structures-effected-by-edit-cache).



;;; Derivation of Runtime Formulas

;;; When a runtime simulation formula is derived, either by initialize-simulator,
;;; or handle-editing-changes-effecting-simulation, it is necessary to note all
;;; things that would cause this runtime formula to change if they were edited.
;;; "Things" includes, generic simulation formulas from which the runtime formulas
;;; are derived, as well as objects and connections encountered while evaluating
;;; roles in the kb simulation formula.

;;; Two approaches for noting things that affect runtime formulas are possible:
;;; 1)  the runtime formula (actually its corresponding variable simulation
;;;     runtime structure) can be noted in the things, or
;;; 2)  the things can be noted in the variable simulation runtime structure.
;;; The first approach is better because it avoids searching all runtime data
;;; structures whenever a thing is edited; the runtime data structures that must
;;; be re-derived are directly accessible from the thing that is edited.  The two
;;; approaches consume the same amount of memory.

;;; The slots runtime-structures-affected-by-this-entity,
;;; runtime-structures-affected-by-this-statement, and
;;; runtime-structures-affected-by-this-connection are used in entities,
;;; statements, and connections respectively to note the variable simulation
;;; runtime structures which they affect.  These slots are not saved so they do not
;;; affect the size of the kb.  Note that conses in these slots must still be
;;; reclaimed.  This is done by update-runtime-structures-according-to-edit, and
;;; clear-runtime-structures-caches (called by shutdown-simulator).

;;; Runtime formulas are derived by generate-runtime-formula, called by
;;; initialize-simulator (and handle-editing-changes-effecting-simulation).  They
;;; are stored in the runtime-formula slot of variable simulation runtime
;;; structures.  Generate-runtime-formula calls generate-formula-eval which is
;;; like sim-eval except that rather than returning values, it returns runtime
;;; formulas.  Generate-formula-eval must identify things that can effect the
;;; runtime formula.  To do this, the special variable
;;; things-that-affect-this-formula is bound by generate-runtime-formula.  Things
;;; that should go into this list are encountered when evaluating designations.
;;; Thus, variables designated by their names are put on this list by
;;; generate-formula-eval.  To evaluate more complicated designations,
;;; generate-formula-eval (like sim-eval) uses evaluate-designation which calls
;;; role servers.  Fortunately, all role servers that search the schematic via
;;; connections use search-for-directly-connected-entities.  Therefore, the work
;;; needed to identify things that effect the formula can be done almost
;;; completely within this function.  Furthermore, very little extra work is
;;; involved; the special variable flag
;;; note-things-encountered-during-role-service?  simply indicates to
;;; search-for-directly-connected-entities whether it should note things it
;;; encounters in things-that-affect-this-formula.  See generate-runtime-formula
;;; for further details.



;;; Noting What has to be Updated when the Edit is Made

;;; There are three categories of things that can be edited which effect
;;; simulation: generic simulation formulas, objects, and connections.  Editing
;;; includes adding and deleting such things as well as modifying them.  Whenever
;;; such an edit is made, the appropriate slot putter or edit function calls
;;; update-runtime-structures-according-to-edit, add-variable-to-simulation, or
;;; remove-variable-from-simulation.  These functions add variable simulation
;;; runtime structures affected by the edit to
;;; variables-whose-runtime-structures-must-be-rederived.  These slots are then
;;; used by check-for-simulation-changes to rollback the simulation if necessary
;;; and rederive runtime formulas.  Note that this only happens if the simulator
;;; is on.  If not, there is no need to keep track of edit changes since
;;; initialize-simulator will derive everything from scratch when the system is
;;; started.  Handle-editing-changes-effecting-simulation clears
;;; variables-whose-runtime-structures-must-be-rederived after it has processed
;;; the changes.


;; Note that when a formula is re-derived, all conses and data structures that
;; become garbage as a result of the uncaching are reclaimed.  Also, when a
;; formula is re-derived, things-that-affect-this-formula must be cached again for
;; the new derivation.

;; Note that because the simulation is rolled back to the previous time step if an
;; edit is made, the complexity related to resumption of the simulator after
;; suspension (even if paused for a long time) is managed and the simulation
;; doesn't change in the middle of a simulation cycle.

;; An important tactic for managing complexity here is to not worry about what
;; kind of edit was made.  As long as something is edited in any way, it should be
;; noted and formulas effected by it re-derived.  This is efficient even though it
;; may cause re-derivation of things that don't have to be.  It is much more
;; efficient than the extreme case of re-deriving everything when any edit is
;; made.

;; Note - need some controls to prevent turning the simulator on or off while the
;; system is running.

;; The memory overhead from deriving runtime formulas should not be too high.
;; Runtime data structures are already being kept for variables so the runtime
;; formulas are simply an addition to this.




;;;; Memory Management 

;;; Conses are used for the runtime simulation formulas.  These
;;; conses are all reclaimed.  Besides explicitly generated conses, there is
;;; quite a bit of floating point calculation which can result in number consing
;;; on some systems.  Temporary floating point numbers are handled by
;;; with-temporary...  wrappers.  The only permanent floating point numbers are
;;; in the variable-simulation-runtime-structure of a variable.  This is because
;;; the variable-simulation-runtime-structure holds the simulation state of a
;;; variable.  Each slot of this structure is set using store-managed-number and
;;; accessed using extract number.  Besides conses, there are a number of 
;;; structures that can be allocated during simulation.  See shutdown-simulator
;;; for complete documentation on reclamation of these structures as well as
;;; conses.

;;; Variable-simulation-runtime-structures are allocated by
;;; make-and-initialize-variable-simulation-runtime-structure.  This function also
;;; reclaims any existing (old) variable-simulation-runtime-structure in the
;;; variable.  Thus, these structures are reclaimed when they are replaced by new
;;; ones, so there is no need to reclaim them at some other time (such as when the
;;; simulator is reset).  The structures are, of course, reclaimed when the
;;; variable is deleted.  

;;; Note that slots of structures used in the simulator are all given initializations
;;; in their def-structure forms.  This eliminates the need to set the slot before
;;; the structure is reclaimed (but not the need to reclaim things in the slot that 
;;; have to be reclaimed).

;;; A number of system variables such as simulation time are initialized 
;;; (within the def-system-variable) to a compound-fixnum-simulation-time.
;;; This happens when the G2 process is made and these
;;; compound-fixnum-simulation-time structures are not effected by kb loading or
;;; starting and resetting the system.  

;;; A with-temporary... wrapper is currently wrapped for each variable being 
;;; calculated (see process-n-variables).
;;; This is a tight wrapping and takes care of number consing for all parts of 
;;; simulate-one-cycle except update-variables.  Wrapping this tightly doesn't have 
;;; a serious negative effect on efficiency (see test results for 7/25/88) in 
;;; agh>new-simulator-test-results.

;;; The temporary area is currently allocated to 32k bytes which allows for 4k
;;; number conses.  Allocating more conses than this limit within a temporary
;;; context will cause serious problems in Lucid, typically a machine crash.  It
;;; is extremely unlikely that this number of number conses would be allocated
;;; within one with-temporary... wrapper since the memory allocated within such
;;; a wrapper is de-allocated upon exit.  Still it is conceivable that a very
;;; complicated function called recursively enough times could cause an overflow
;;; and currently, there is no check to prevent this.

;;; A higher wrapper could be put in process-n-variables around the loop.
;;; This would ensure wrapping for n variables.  Thus, if we ever decide to not wrap 
;;; for each variable, it would be necessary to ensure that n variables don't overrun the
;;; temporary area.  If n is on the order of 10 or so, there should be no problem
;;; (except in an extreme case such as the one mentioned above).  It would also be
;;; be necessary to put wrappers around calls to user defined functions,
;;; history functions, and sim-eval-get-value-of-variable.

;;; In any case, it should not be necessary to remove the tight wrapper 
;;; since it is already efficient.  The only overhead involved with the wrapper for
;;; Lucid is binding two special variables, and then zeroing memory that was allocated
;;; upon exit.  When typed arithmetic is used, the garbage generated will be 
;;; reduced anyway so less (or no) memory will have to be zeroed upon exit.



;;;; G2 Parameters in Simulator

;;; G2 parameters, as well as g2 variables can be used in the simulator.
;;; Unlike variables, parameters do not have separate values for the 
;;; inference engine and for the simulator.  Thus, for the case of parameters,
;;; update-variable does put-current-value to immediately set the value
;;; of the parameter to the value computed by the simulator during the
;;; previous cycle.  Note that this is done even if the simulator falls
;;; behind gensym time (in real-time mode).  

;;; It is also possible that a parameter may be set in the middle of a
;;; simulation cycle by a rule resulting in possible data inconsistency
;;; problems.  This can be avoided by not running rules and data servers
;;; at the same priority (which is the default case).  If rules and
;;; data servers must be run at the same priority, the state variable
;;; approach of next value = current value can be used.

;;; If the simulator fails to compute a value for a parameter, it posts
;;; a warning and simply leaves the parameter unmodified.  It does not
;;; put any kind of "no value" indicator into the parameter (see
;;; update-variable).

;; See also SEB on G2 parameters for simulation for more details.

;; Note that in the simulation code, the name "variable" often means
;; "variable-or-parameter".  It hasn't been switched over in 
;; cases where doing so would make names too long.





;;;; Cons Storage Allocation

(defconser simulate)





;;;; Installation 



;;;; Forward References

(declare-forward-reference state-variable-p function)
(declare-forward-reference dependent-variable-p function)
(declare-forward-reference discrete-state-variable-p function)
(declare-forward-reference continuous-state-variable-p function)
(declare-forward-reference update-variable function)
(declare-forward-reference simulate-one-cycle function)
(declare-forward-reference initialize-externally-simulated-portion-of-model 
			   function)
(declare-forward-reference shutdown-externally-simulated-portion-of-model
			   function)
(declare-forward-reference externally-simulated-variable-p function)
(declare-forward-reference install-externally-simulated-variable function)
(declare-forward-reference update-variables function)
(declare-forward-reference current-external-simulator-configuration function)
(declare-forward-reference current-default-simulation-time-increment function)
(declare-forward-reference get-model-to-which-item-belongs function)
(declare-forward-reference simulation-procedure-and-external-simulation-finished?
			   function)
(declare-forward-reference sim-eval-for-stack-until-value-found function)
(declare-forward-reference sim-eval-for-stack-without-chaining function)
(declare-forward-reference get-model-queue-for-model function)
(declare-forward-reference current-model-is-paused? function)
(declare-forward-reference model-runtime-info-function? function)        ;SIMULATE5
(declare-forward-reference restart-simulator-after-procedure-1 function) ;SIMULATE5
(declare-forward-reference dont-wait-for-model-to-finish-function? function)
(declare-forward-reference current-simulation-runtime-structure variable)
(declare-forward-reference dont-backward-chain-in-sim-eval? variable)
(declare-forward-reference within-stack-eval-p function)
(declare-forward-reference exit-last-simulation-variable-context function)
(declare-forward-reference get-model-runtime-info-for-variable function)

(declare-forward-reference generate-standard-error-message function)


(declare-forward-reference add-model-which-has-something-to-simulate function)
(declare-forward-reference update-anything-to-simulate-in-model? function)

(declare-forward-reference model-paused? function)


(declare-forward-reference calculate-new-values-for-dependent-variables
			   function)

(declare-forward-reference anything-to-simulate? function)
(declare-forward-reference stack-expiration variable)

(declare-forward-reference registered-and-active-default-error-handler-p function)
(declare-forward-reference invoke-user-defined-default-error-handler function)





;;;; Simulation Sets

;;; A simulation set is defined using define-simulation-set.  Simulation sets are
;;; implemented as doubly linked lists using pointers in structures corresponding
;;; to elements of the set.  This facility is used because add-to-set and
;;; delete-from-set can be too slow for the sophisticated installation schemes
;;; used in the simulator.

;;; There are three simulation sets defined for the simulator: installation-set,
;;; external-set, and rederive-set.  The set installation-set comprises the
;;; model-continuous-state-variable-info, model-discrete-state-variable-info, and
;;; model-dependent-variable-info slots of all model-runtime-info structures.  The
;;; set rederive-set comprises the
;;; variables-whose-runtime-structures-must-be-rederived slot of all
;;; model-runtime-info structures.  The set external-set comprises the
;;; externally-simulated-entities slot of all model-runtime-info structures.

;;; Note that an element can appear only once in a simulation set.  The add-to
;;; function deletes the element from any simulation-set in which it may exist
;;; before adding it.  This restriction could eventually be lifted if appropriate,
;;; by allowing multiple structures for elements.

;;; A simulation set segment is made by calling the make function which returns a
;;; dummy structure to be used as the header for the set.  The place which holds
;;; the simulation set segment should be set to the result of the make function.
;;; A simulation set segment is reclaimed by calling the reclaim function, which
;;; reclaims the header structure.



(defmacro define-simulation-set
	  (set-name set-structure set-structure-accessor next previous
	   element-accessor)
  (let* ((set-constructor-name
	   (intern (format nil "MAKE-~a" set-name)))
	 (set-structure-constructor-name
	   (intern (format nil "MAKE-~a" set-structure)))
	 (set-reclaimer-name
	   (intern (format nil "RECLAIM-~a" set-name)))
	 (set-structure-reclaimer-name
	   (intern (format nil "RECLAIM-~a" set-structure)))
	 (clear-function-name
	   (intern (format nil "CLEAR-~a" set-name)))
	 (empty-predicate-name
	   (intern (format nil "~a-EMPTY?" set-name)))
	 (add-function-name
	   (intern (format nil "ADD-TO-~a" set-name)))
	 (delete-function-name
	   (intern (format nil "DELETE-FROM-~a" set-name)))
	 (insert-function-name
	   (intern (format nil "INSERT-IN-~a" set-name)))
	 (iterator-name
	   (intern (format nil "FOR-EACH-ELEMENT-IN-~a" set-name))))
    `(progn
       (defun ,add-function-name (,set-name element)
	 (let ((element-set-structure?
		 (,set-structure-accessor element)))
	   (when element-set-structure?
	     (,delete-function-name element)
	     (let ((first-element? (,next ,set-name)))
	       (setf (,next ,set-name) element-set-structure?
		     (,previous element-set-structure?) ,set-name)
	       (when first-element?
		 (setf (,previous first-element?) element-set-structure?
		       (,next element-set-structure?) first-element?))))))

       (defun ,delete-function-name (element)
	 (let* ((element-set-structure?
		  (,set-structure-accessor element))
		(previous-structure-or-header?
		  (when element-set-structure?
		    (,previous element-set-structure?)))
		(next-structure? (,next element-set-structure?)))
	   (when previous-structure-or-header?
	     (setf (,next previous-structure-or-header?) next-structure?))
	   (when next-structure?
	     (setf (,previous next-structure?)
		   previous-structure-or-header?))
	   (setf (,previous element-set-structure?) nil
		 (,next element-set-structure?) nil)))

       (defun ,set-constructor-name ()
	 (,set-structure-constructor-name))

       (defun ,set-reclaimer-name (,set-name)
	 (let ((first-element? (,next ,set-name)))
	   (when first-element?
	     (setf (,previous first-element?) nil)))
	 (,set-structure-reclaimer-name ,set-name))

       (defun ,clear-function-name (,set-name)
	 (let ((first-element? (,next ,set-name)))
	   (when first-element?
	     (setf (,previous first-element?) nil
		   (,next ,set-name) nil))))

       (defun ,empty-predicate-name (,set-name)
	 (not (,next ,set-name)))

       ;; The insert function is like the add function except that it takes a set
       ;; structure arg which points to the position in the set after which the
       ;; element should be inserted.  Note that this does not allow inserting an
       ;; element as the first in the set; the add function should be used to do
       ;; this.
       (defun ,insert-function-name (insert-pointer element)
	 (let ((element-set-structure? (,set-structure-accessor element))
	       insert-before-pointer?)
	   (when element-set-structure?
	     (,delete-function-name element)
	     (setq insert-before-pointer? (,next insert-pointer))
	     (setf (,next insert-pointer) element-set-structure?
		   (,previous element-set-structure?) insert-pointer)
	     (when insert-before-pointer?
	       (setf (,next element-set-structure?) insert-before-pointer?
		     (,previous insert-before-pointer?) element-set-structure?)))))

       (defun ,iterator-name (,set-name function-for-element)
	 (let ((first-element? (,next ,set-name)))
	   (when first-element?
	     (loop as element-set-structure?
		      = first-element?
		      then (,next element-set-structure?)
		   until (null element-set-structure?)
		   as element
		      = (,element-accessor element-set-structure?)
		   do
	       (funcall-symbol function-for-element element)))))
       )))

;; All args to define-simulation-set are assumed to be symbols.

;; Note that this technique allows for easily maintaining a set (ensuring that
;; element doesn't appear more than once) while allowing for easy clearing (clear
;; function simply breaks first pointer and does not have to iterate over each
;; element).



(define-simulation-set 
  installation-set simulation-info simulation-info?
  installation-set-next? installation-set-previous? 
  variable-for-simulation-info)

(define-simulation-set 
  rederive-set simulation-info simulation-info?
  rederive-set-next? rederive-set-previous?
  variable-for-simulation-info)





;;;; External-simulation capability ...

;(def-capability external-simulation (entity)
;  ((external-simulation-object-structure 
;     nil (lookup-slot) (system) 
;     (do-not-put-in-attribute-tables) (do-not-save))
;   (external-simulation-definition-for-entity
;     nil (lookup-slot) (system) 
;     (do-not-put-in-attribute-tables) (do-not-save))
;   (external-set-pointers?
;     nil (lookup-slot) (system) 
;     (do-not-put-in-attribute-tables) (do-not-save)))
;  nil)




;; It is necessary in the installation code to check whether an
;; entity has this capability before setting one of the capability
;; slots.  This is done by calling external-simulation-p.
;; Note that there are a number of places in runtime code where the 
;; external-simulation-definition-for-entity slot of an entity is accessed
;; (via get-slot-value).  In these cases, there is no need to check
;; external-simulation-p since the entities are always in 
;; externally-simulated-entities and therefore always have this capability.

;; Currently, if the external-simulation capability is added to the object
;; definition after the entity has been instantiated, the 
;; external-simulation-definition-for-entity slot will not be updated.
;; This is a relatively low priority installation issue.
;; This could possibly be resolved by using a slot putter for 
;; external-simulation-definition-for-entity!

;; Note that when the external-simulation capability is removed from
;; the object definition while there are instances, any 
;; external-simulation-definition frame in the 
;; external-simulation-definition-for-entity slot is deleted.  
;; Something less drastic could be implemented, again using a slot
;; putter for external-simulation-definition-for-entity!



;(defun external-simulation-function-p (entity)
;  (external-simulation-p entity))

(def-structure (external-set-pointers)
  (external-set-next? nil)
  (external-set-previous? nil)
  (entity-in-external-set nil))

(define-simulation-set
  external-set external-set-pointers get-external-set-pointers?
  external-set-next? external-set-previous?
  entity-in-external-set)

(defun get-external-set-pointers? (entity)
       (get-slot-value entity 'external-set-pointers?))

(defun make-external-set-pointers-if-necessary (entity)
  (when (null (get-external-set-pointers? entity))
    (let ((new-external-set-pointers (make-external-set-pointers)))
      (set-slot-value entity 'external-set-pointers? new-external-set-pointers)
      (setf (entity-in-external-set new-external-set-pointers) entity)
      new-external-set-pointers)))

(def-slot-value-reclaimer external-set-pointers? 
			  (external-set-pointers? entity)
  (delete-from-external-set entity)
  (reclaim-external-set-pointers external-set-pointers?))





;;;; Model Runtime Information

;;; Runtime information for models is kept in model-runtime-info structures which
;;; are separate from model definitions.  The reason for having separate
;;; structures (as opposed to keeping this information in non-saved slots in
;;; model-definition frames) is that one of these is necessary for the main g2
;;; simulation.  To be consistent with previous releases, the main g2 simulation
;;; should not require a model-definition, even a dummy one, since it could be
;;; picked up by inspect.  Thus, the model-runtime-info structure for the main g2
;;; simulation is kept in the special variable main-model-runtime-info, and
;;; model-runtime-info structures for models are kept in the model-runtime-info
;;; slot of model-definitions.

;;; Model-runtime-info structures contain installation and runtime information for
;;; a model.  The special variable main-model-runtime-info  is initialized to a
;;; model-runtime-info structure.  This structure is used for the main g2
;;; simulation (non-model-specific).  Model-runtime-info structures are also
;;; allocated when initializing the model-runtime-info?  slot of
;;; model-definitions, and are reclaimed when the model-definitions are reclaimed.

;;; The special variable current-model-definition?  is bound to the
;;; model-definition currently being simulated, or nil for the case of the main g2
;;; simulation.  This is used by variable-belongs-to-current-model?  to filter
;;; variables for the current model.

;;; Current-model-runtime-info?  and current-model-definition?  are bound by
;;; with-current-model for each data server function which can call the simulator.
;;; Thus, these special variables are always bound inside any of the simulation
;;; code.

;;; Slots of a Model-runtime-info Structure

;;; The slots model-continuous-state-variable-info,
;;; model-discrete-state-variable-info, and model-dependent-variable-info are set
;;; as part of installation.  They contain, as simulation sets, all state and
;;; dependent variables.  Externally-simulated-entities is also maintained by
;;; installation functions.  It is used by runtime functions to decide which
;;; entities should be simulated externally.

;;; Simulator-step-flag indicates the step of the simulator in a simulation cycle.
;;; It is initially nil.  When calculating new values for discrete state
;;; variables, it will be bound to
;;; 'calculating-new-values-for-discrete-state-variables.  When calculating new
;;; values for dependent variables, it will be bound to
;;; 'calculating-new-values-for-dependent-variables.  It will have other values
;;; when the euler or rk4 integration algorithms are used to calculate k values
;;; and new values for continuous state variables.  Specifically, for the euler
;;; algorithm, the values are: 'euler-calculate-k-values
;;; 'euler-calculate-new-values For the Runge-Kutta algorithm, the values are:
;;; 'rk4-calculate-k-values 'rk4-calculate-new-values The value can also be
;;; 'exact-calculate-new-values when an exact solution is given for a continuous
;;; state variable.  Rk4-step is non nil only for rk4 integration and can have
;;; values 1 to 4.

;;; Simulation-resumption-stack holds the resumption stack for the simulator.
;;; This allows the simulator to be suspendable (see suspendable tasks in
;;; UTILITIES).  It is updated each call to
;;; simulate-until-consistent-with-gensym-time.  It is initialized to nil in
;;; initialize-simulator.

;;; Note that default-initial-simulation-time is initialized to a
;;; compound-fixnum-simulation-time representing 0.  It is never modified, only
;;; accessed.

;;; Simulation-error? is set to nil by initialize-simulator.  It can be set
;;; to various symbols by simulation error handlers indicating an error.
;;; If it is non-nil, simulate-until-consistent-with-gensym-time will
;;; do nothing.



(def-structure (compound-fixnum-simulation-time
		 (:reclaimer real-reclaim-compound-fixnum-simulation-time))
  (macro-time 0)
  (micro-time 0))

;; Compound-fixnum-simulation-time is defined here because make and reclaim macros
;; used when making and reclaiming model-runtime-info.  See section on compound
;; fixnum simulation times below.



(defun reclaim-compound-fixnum-simulation-time (compound-time?)
  (when (and compound-time?
	     (compound-fixnum-simulation-time-p compound-time?))
    (real-reclaim-compound-fixnum-simulation-time compound-time?)))



(def-structure model-runtime-info

  (simulator-up-to-date? nil)

  (simulator-step-flag nil)
  (rk4-step nil)

  (default-initial-simulation-time
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)
  (current-simulation-time
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)
  (new-simulation-time
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)
  (simulation-base-time
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)
  (shortest-simulation-time-increment
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)
  (runtime-default-simulation-time-increment
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)

  (simulation-resumption-stack nil)
  (simulation-error? nil)
  (simulation-procedure-invocation-for-model? nil)
  (simulation-procedure-finished? nil)
  (external-simulator-interface-icp-socket nil)
  (external-simulation-initialization-completed? nil)
  (status-of-work-on-external-simulation nil)
  (waiting-for-external-simulator? nil)
  (simulator-currently-has-nothing-to-do? nil)

  (model-continuous-state-variable-info
    (make-installation-set) :reclaimer reclaim-installation-set)
  (model-discrete-state-variable-info
    (make-installation-set) :reclaimer reclaim-installation-set)
  (model-dependent-variable-info
    (make-installation-set) :reclaimer reclaim-installation-set)
  (model-sort-boundary-for-dependent-variable-info nil)

  (model-variable-group-update-info nil)

  (variables-whose-runtime-structures-must-be-rederived 
    (make-rederive-set) :reclaimer reclaim-rederive-set)
  (simulated-variable-removed? nil)

  (externally-simulated-entities
    (make-external-set) :reclaimer reclaim-external-set)
  (externally-simulated-entities-to-process nil)
  (model-definition-for-model? nil)
  (model-runtime-status nil)
  (variables-that-need-simulated-values 
    nil :reclaimer clear-variables-that-need-simulated-values-1)
  (value-tainted-by-ordering-loop? nil)
  (tainted-variables
    nil :reclaimer clear-tainted-variables-1)
  (shortest-override-time-increment
    (make-compound-fixnum-simulation-time)
    :reclaimer reclaim-compound-fixnum-simulation-time)

  (speedup-tagnames nil)
  (speedup-tagnames-tail nil)
  (input-tagnames? nil)
  (speedup-output-vector-cache
    nil :reclaimer reclaim-simulate-list)
  (speedup-output-vector-cache-tail nil)
  )



(defun initialize-main-model-runtime-info ()
  (make-model-runtime-info))

(defun initialize-model-runtime-info (&optional model-definition?)
  (let ((model-runtime-info (make-model-runtime-info)))
    (setf (model-definition-for-model? model-runtime-info)
	  (or model-definition? frame-being-made))
    model-runtime-info))

(def-system-variable main-model-runtime-info simulate1 
  (:funcall initialize-main-model-runtime-info))

(def-system-variable current-model-runtime-info? simulate1 nil)

(def-system-variable current-model-definition? simulate1 nil)

(def-substitution-macro variable-belongs-to-current-model? (variable)
  (let ((simulation-info? (simulation-info? variable)))
    (when simulation-info?
      (eq (model-definition? simulation-info?)
	  current-model-definition?))))

;; Note that this works correctly for the case of the main g2 simulation where
;; current-model-definition?  is bound to nil.  Any variables not designated in
;; any model definition will have nil for (model-definition?  simulation-info) and
;; will therefore belong to the main g2 simulation.



(defmacro with-current-model (model-runtime-info? model-definition? &body body)
  `(let (current-model-runtime-info? current-model-definition?)
     (cond 
       (,model-runtime-info?
	(setq current-model-runtime-info? ,model-runtime-info?
	      current-model-definition? ,model-definition?))
       (t
	(when (and (simulator-on? simulation-parameters)
		   (not (g1-authorized-p)))
	  (setq current-model-runtime-info? main-model-runtime-info
		current-model-definition? nil))))
     (when current-model-runtime-info?
       ,@body)))

;; This assumes that model-runtime-info?  and model-definition?  are always
;; symbols.



(defmacro with-current-model-and-queue (model-runtime-info? model-definition? &body body)
  `(with-current-model 
     ,model-runtime-info? ,model-definition?
     (let ((current-model-queue?
	     (get-model-queue-for-model current-model-runtime-info?)))
       ,@body)))



(defmacro with-current-model-for-item (item &body body)
  `(let* (current-model-runtime-info? current-model-definition?
	  (model-definition-for-item?
	    (get-model-to-which-item-belongs ,item t)))
     (if model-definition-for-item?
	 (setq current-model-definition? model-definition-for-item?
	       current-model-runtime-info? 
	       (model-runtime-info? model-definition-for-item?))
	 (setq current-model-definition? nil
	       current-model-runtime-info? main-model-runtime-info))
     ,@body))


(def-slot-putter integration-algorithm (frame new-value)
  (when (and (eq (integration-algorithm frame) 'rk4)
	     (not (eq new-value 'rk4))
	     (eq frame simulation-parameters))
    (setf (rk4-step main-model-runtime-info) nil))
  (setf (integration-algorithm frame) new-value))



;;;; Variables to Simulate

;;; The slots model-continuous-state-variable-info,
;;; model-discrete-state-variable-info, and model-dependent-variable-info are kept
;;; up to date by add-variable-to-simulation-model which is called by various
;;; installation methods.

;;; The installation for variables to simulate is complicated (see also
;;; install).  The following has to be done:  
;;; 1.  When a variable is
;;; entered as the value of an attribute of an entity, put-attribute-value
;;; will, if there is no simulation frame for the variable and if there
;;; exist generic simulation formulas for the variable, put the variable
;;; on the list of variables to be simulated.  It will also set
;;; simulation category and initial value slots of the variable (see also
;;; put-attribute-value).  
;;; 2.  When a variable is removed as the value of an
;;; attribute of an entity, reclaim-attribute-value removes it from the
;;; list of variables to be simulated.  
;;; 3.  When a
;;; generic-simulation-formula is entered, the slot putter for the
;;; box-translation-and-text slot searches for variables which can use
;;; the simulation formula and adds them to the list of variables to be
;;; simulated, updating the simulation category and initial value slots
;;; as well (see also slot putter for box-translation-and-text for
;;; generic-simulation-formula).  
;;; 4.  When a
;;; generic-simulation-formula is deleted, the slot value reclaimer
;;; for the box-translation-and-text slot searches for variables that use
;;; the simulation formula and removes them from the list of variables to
;;; be simulated if there are no other simulation formulas for the
;;; variable.  
;;; 5.  When a simulation frame is entered as the value of the
;;; simulation-details  slot of a variable, the slot putter will put the
;;; variable on the list of variables to be simulated.  The simulation
;;; category and initial value slots, in this case, are updated by
;;; editing the simulation-formulas? slot of the simulation-subtable.  
;;; 6.  When a simulation frame is removed as the value of the
;;; simulation-details slot of a variable, the slot value reclaimer for
;;; simulation-details slot will remove the variable from the list of
;;; variables to be simulated unless the variable has generic simulation
;;; frames for it.

(defun add-variable-to-simulation-model (variable-or-parameter)
  (cond 
    ((continuous-state-variable-p variable-or-parameter)
     (add-to-installation-set 
       (model-continuous-state-variable-info current-model-runtime-info?)
       variable-or-parameter))
    ((discrete-state-variable-p variable-or-parameter)
     (add-to-installation-set 
       (model-discrete-state-variable-info current-model-runtime-info?)
       variable-or-parameter))
    ((dependent-variable-p variable-or-parameter)
     (add-to-installation-set 
       (model-dependent-variable-info current-model-runtime-info?)
       variable-or-parameter)))
  (add-model-which-has-something-to-simulate current-model-runtime-info?))

(defun add-externally-simulated-entity-to-simulation-model (entity)
  (add-to-external-set 
    (externally-simulated-entities current-model-runtime-info?) entity)
  (add-model-which-has-something-to-simulate current-model-runtime-info?))

(defun remove-variable-from-simulation-model (variable-or-parameter)
  (delete-from-installation-set variable-or-parameter)
  (update-anything-to-simulate-in-model? current-model-runtime-info?))

(defun remove-externally-simulated-entity-from-simulation-model (entity)
  (delete-from-external-set entity)
  (update-anything-to-simulate-in-model? current-model-runtime-info?))

(defun for-each-variable-in-model (function-for-variable)
  (for-each-element-in-installation-set
    (model-continuous-state-variable-info current-model-runtime-info?)
    function-for-variable)
  (for-each-element-in-installation-set
    (model-discrete-state-variable-info current-model-runtime-info?)
    function-for-variable)
  (for-each-element-in-installation-set
    (model-dependent-variable-info current-model-runtime-info?)
    function-for-variable))



	

;;;; Simulation Error Handlers

;;; Def-simulation-error-handler is used to define error handlers for
;;; errors occurring outside stack-eval.

;;; Errors within stack eval are handled by calling stack-error.
;;; Stack-error does a throw to the stack-error catch in stack-eval,
;;; which calls signal-error-to-computation-instance, which then calls
;;; handle-simulator-stack-error.  Handle-simulator-stack-error sets
;;; (simulation-error?  current-model-runtime-info?).  This is checked
;;; by sim-eval-for-stack-1 after exit from call to stack-eval.  If
;;; (simulation-error?  current-model-runtime-info?) is non-nil,
;;; sim-eval-for-stack-1 calls signal-simulation-error-after-stack-eval.
;;; Signal-simulation-error-after-stack-eval does all the same things
;;; done by the code generated by def-simulation-error-handler
;;; (including a throw to 'simulation-error-catch) except that it does
;;; not set (simulation-error?  current-model-runtime-info?)



(def-system-variable within-simulate-until-consistent-with-gensym-time
		     SIMULATE1 nil)

(def-system-variable initializing-simulator? simulate1 nil)

(def-system-variable initializing-state-variables? simulate1 nil)



(defmacro def-simulation-error-handler (error-name args &body forms)
  `(progn
     (defun ,error-name ,args
       (setf (simulation-error? current-model-runtime-info?) ',error-name)
       (when (simulation-procedure-invocation-for-model?
	       current-model-runtime-info?)
	 (abort-procedure-invocation 
	   (simulation-procedure-invocation-for-model?
	     current-model-runtime-info?))
	 (setf (simulation-procedure-invocation-for-model?
		 current-model-runtime-info?) nil))
       (progn
	 ,@forms)
       (when (or within-simulate-until-consistent-with-gensym-time
		 initializing-simulator?)
	 (throw 'simulation-error-catch t)))))

;; It is necessary to check within-simulate-until-consistent-with-gensym-time
;; before throwing because errors may occur in icp message handlers for external
;; simulator messages.  The message handlers are called from process-icp-sockets,
;; outside of simulate-until-consistent-with-gensym-time, and a throw from these
;; to 'simulation-error-catch will not be caught.

;; T is returned so that simulate-until-consistent-with-gensym-time returns
;; t indicating that simulation is up to date.

;; Note that there is no need for an unwind protect for this throw.  No further
;; simulation will be done until a reset, at which time, all data structures are
;; reset.



(defun signal-simulation-error-after-stack-eval ()
  (when (simulation-procedure-invocation-for-model?
	  current-model-runtime-info?)
    (abort-procedure-invocation 
      (simulation-procedure-invocation-for-model?
	current-model-runtime-info?))
    (setf (simulation-procedure-invocation-for-model?
	    current-model-runtime-info?) nil))
  (when (or within-simulate-until-consistent-with-gensym-time
	    initializing-simulator?)
    (throw 'simulation-error-catch t)))



(def-simulation-error-handler post-simulation-warning-for-no-value
			      (variable)
  (warning-message* 
    1 "Simulation problem.  Can't get value for ~NF." variable))

(def-simulation-error-handler simulation-type-error (variable value)
  (warning-message* 
    1
    "An attempt to put the value ~s into ~NF ~
     which has type ~NT failed because of type mismatch."
    (if (no-simulation-value-p value) 'no-value value)
    variable
    (type-specification-of-variable-or-parameter-value variable)))

(defun post-simulation-warning-for-not-parameter (variable)
  (warning-message*
    1
    "Simulation problem.  The initialization expression \"the current parameter value\" ~
     is not valid because ~NF is not a parameter."
    variable))



(defun simulation-type-error-from-within-or-without-stack-eval 
       (variable value)
  (cond
    ((within-stack-eval-p)
     (when (model-runtime-info-p current-model-runtime-info?)
       (setf (simulation-error? current-model-runtime-info?) 
	     'simulation-type-error))
     (write-stack-error cached-top-of-stack
       (tformat
	 "An attempt to put the value ~s into ~NF ~
          which has type ~NT failed because of type mismatch."
	 (if (no-simulation-value-p value) 'no-value value)
	 variable
	 (type-specification-of-variable-or-parameter-value variable))))
    (t
     (simulation-type-error variable value))))

;; Type errors can occur within or without stack-eval.
;; Simulation-type-error-from-within-or-without-stack-eval handles both
;; cases.



(defun handle-simulator-stack-error
    (variable-or-parameter computation-frame
			   computation-component-particulars error error-level
			   error-text-string current-program-counter local-stack top-of-stack
			   byte-code-body local-var-vector)
  (cond
    ((eq (simulation-error? current-model-runtime-info?) 
	 'unknown-encountered)
     (reclaim-error-text error-text-string)
     (setf (simulation-error? current-model-runtime-info?) nil))
    (t
     (let ((standard-message
	     (generate-standard-error-message
	       error error-text-string computation-frame
	       computation-component-particulars variable-or-parameter
	       byte-code-body (byte-code-body-constant-vector byte-code-body)
	       current-program-counter local-stack top-of-stack
	       local-var-vector)))
       ;; Invoke default error handler if registered and active
       (cond
	 ((and (registered-and-active-default-error-handler-p)
	       (invoke-user-defined-default-error-handler error
						     standard-message)))
	 (t
	  (warning-message error-level
	      "~nw~%~%Exiting execution of this formula.  No value was computed for ~
          ~NF, and simulation has been halted for its model."
	    standard-message
	    variable-or-parameter)
	  (reclaim-error-text standard-message)
	  ))
       (reclaim-error-text error-text-string))

     (when (null (simulation-error? current-model-runtime-info?))
       (setf (simulation-error? current-model-runtime-info?) 
	     'simulation-stack-error))))

  (when (and current-computation-instance
	     current-simulation-runtime-structure)
    (let ((local-var-vector?
	    (runtime-cache? current-simulation-runtime-structure)))
      (when local-var-vector?
	(let ((dont-backward-chain-in-sim-eval? t))
	  (setq current-computation-instance nil)
	  ;; Current-computation-instance is set to nil before
	  ;; call to exit-last-simulation-variable-context
	  ;; so that (within-stack-eval-p) is false.
	  (exit-last-simulation-variable-context 
	    nil local-var-vector?))))))






;;;; Documentation for data servers.

;;; Each data server should have exactly one data-server defstruct per
;;; process. It should be the value of a system variable. It should also
;;; be pushed onto list-of-all-data-servers as per the example.

;;; The data-server specified functions for requesting data, a function to supply
;;; data once per clock tick, a boolean variable to determine if the data
;;; supplier should be called to accept data, and a function to initialize the
;;; data server initially and when the resetting is done.

;;; The data-server-map of a variable may have as its value (1) the symbol
;;; 'computation or any data-server , (2) an alist of such.

;;; Some assumptions:

;;; (1) Any time after initialization, the other functions may be called.
 
;;; (2) It is safe to do any of them at any time. For example, you can stop
;;; data collection even though you never started it.

;;; (3) A single shot request asks for a value promptly. It should not cause a
;;; previous request for regular data collection to be discontinued or even have
;;; its phase altered.

;;; (3) What initialization is depends on the data server and the mode
;;; (*data-source-mode*). The mode will not be changed without first
;;; doing a reset. So the initialization function might do something
;;; only if the mode is one that concerns the particular server. If a
;;; server is to be brought into action without interfering with other
;;; servers or resetting, than the initialize function might be called
;;; without doing a reset. We have to work this out.

;;; Note that *data-server-mode* is obsolete, and the data server now only
;;; depends on the symbol stored in the data-server-map slot of a variable.  The
;;; comments in the paragraph above should be updated to not reference modes.
;;; -jra 3/16/88

;;; The simulator data server is created by calling the function def-data-server.

;;; Add-simulator-as-data-server ...

(def-data-server
  'simulator-data-server
  'collect-one-shot-data-for-simulator
  'begin-collecting-data-for-simulator
  'stop-collecting-data-for-simulator
  'simulate-until-consistent-with-gensym-time
  nil
  'initialize-simulator-as-data-server
  'set-external-variable-for-simulator
  'shutdown-simulator
  'post-on-message-board
  nil
  nil
  'need-calls-to-simulate-until-consistent-with-gensym-time)



;;;; Compound fixnum simulation times

;;; A compound-fixnum-simulation-time is a structure containing 
;;; macro-time and micro-time slots.  These slots both contain fixnum
;;; integers.  Currently, macro-time corresponds to seconds and micro-time
;;; corresponds to fractions of seconds.

;; These structures are necessary because a single number (such as a short float)
;; does not have the required precision;  it will wrap around very quickly if 
;; time steps are small, or else require that time steps be large.

;; A number of operations on
;; such structures are defined.  These abstractions will allow for
;; the structures to change format in the future.  Eventually, gensym time
;; will probably be more than just the single fixnum it is now (to avoid
;; wrap around).  It seems that eventually, 3 fixnums will be needed:
;; Two to represent seconds (to provide virtually unlimited time before 
;; wrap around) and one for fractions of a second.
;; Currently, the macro-time of a compound-fixnum-simulation-time will 
;; wrap around after 6 months (as does gensym time).

;; Send some sort of error message if overflow does occur.

;; An important issue with compound times is how they should be saved in
;; histories.  (Also, see related comment below.)  For now, only the macro time
;; (a fixnum) of compound-fixnum-simulation-time will be saved.  This means that
;; the minimum granularity for simulation histories is 1 second.  This should be
;; O.K. for now.  Eventually, there may be some applications that require the
;; capability to save a more precise time in histories.  A simple solution, if
;; these histories are isolated cases, would be to just save several fixnums in
;; parallel vectors of special "precise" histories.  A more sophisticated and
;; memory-efficient scheme would be to store only the least significant fixnum
;; and then keep offset or wrap around information in a special slot of the
;; history ring buffer.
;;
;; Note that as of version 4.0, histories can now use other timestamp
;; granularities other than 1 second.  This is defined in the history spec of
;; the variable or simulation-subtable.  Therefore, history timestamps can now
;; be accurate to the given granularity (which can be subsecond).  - cpm, 6/2/94

;;; In the simulator, the following locations contain compound-fixnum-simulation-times:
;;;     (default-initial-simulation-time current-model-runtime-info?)
;;;     (current-simulation-time current-model-runtime-info?)
;;;     (simulation-base-time current-model-runtime-info?)
;;;     (shortest-simulation-time-increment current-model-runtime-info?)
;;;     (runtime-default-simulation-time-increment current-model-runtime-info?)
;;;   the slots in the simulation runtime structure
;;;     last-time-value-sent-to-inference-engine
;;;   the slots in simulation-update-table
;;;     time-of-last-update

;;; Note that the values for these locations are all derived at run time;  they are not
;;; part of any knowledge base.

;;; The following locations do not contain compound-fixnum-simulation-times;  they keep
;;; times as short floats:
;;;   the slots in the simulation-subtable class
;;;     time-increment-for-update?
;;;   the slots in the simulation-parameters system frame or model definition
;;;     default-simulation-time-increment

;;; This is because these are typically slots which are saved and defstructs cannot 
;;; currently be saved.  Thus, compound-fixnum-simulation-times are runtime structures
;;; and are not part of the knowledge base.

;; There is no need for interval-at-which-to-send-value-to-inference-engine
;; (a slot in variable-simulation-runtime-structure) to be a compound fixnum.
;; It is an interval and will therefore always be an integer representing
;; seconds.

;; Also, slot value compilers for default-simulation-time-increment and
;; time-increment-for-update? should ensure that the time increments are
;; not less than the current minimum (10 microseconds).
;; - done

;; Note on time increments -
;; Time increments can now be specified in three ways:
;; 1.  default-simulation-time-increment slot of simulation-parameters or model-definitions
;; 2.  in generic simulation formulas
;; 3.  time-increment-for-update? slot of simulation-subtable
;; Way 3 will overide 2, 2 will overide 1.
;; Upon initialization, these values (gensym-floats) are transfered to
;; runtime-default-time-increment-for-update (special variable)
;; in compound-fixnum-simulation-time form.  This means that while the 
;; user specified slots are editable while running, their values won't effect
;; the run until the next initialize-simulator.  
;; Eventually, the installation methods for these slots should also check 
;; if running, and if so, update 
;; runtime-default-time-increment-for-update, and shortest-time-increment-for-update
;; if necessary.




(def-system-variable minimum-simulation-time-increment simulate1
  (:funcall initialize-minimum-simulation-time-increment))


(defun initialize-minimum-simulation-time-increment ()
  (/e 1.0 (coerce-to-gensym-float
	    fraction-modulus-of-compound-fixnum-simulation-time)))



;;; Store-number-into-compound-fixnum-simulation-time takes a 
;;; compound-fixnum-simulation-time structure and a number as arguments.
;;; If number is integer, macro-time of compound-fixnum-simulation-time 
;;; is set to number.  If number is a float, macro-time is set to 
;;; the integer portion and micro-time is set to the fractional portion.

(defmacro store-number-into-compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time number)
  (let ((value-of-compound-fixnum-simulation-time (gensym))
	(value-of-number (gensym)))
    `(let ((,value-of-compound-fixnum-simulation-time
	    ,compound-fixnum-simulation-time)
	   (,value-of-number ,number))
       (cond
	 ((integerp ,value-of-number)
	  (setf (macro-time ,value-of-compound-fixnum-simulation-time) ,value-of-number)
	  (setf (micro-time ,value-of-compound-fixnum-simulation-time) 0))
	 (t					; if float
	  (multiple-value-bind
	    (integer-portion fraction-portion)
	      (truncate (coerce-to-gensym-float ,value-of-number))
	    (setf (macro-time ,value-of-compound-fixnum-simulation-time) integer-portion)
	    (setf (micro-time ,value-of-compound-fixnum-simulation-time)
		  (round (* fraction-portion 
			    fraction-modulus-of-compound-fixnum-simulation-time)))))))))

;; Since the second argument returned by truncate is a float, this must
;; be done within a temporary consing context.
;; Note that currently, the fraction is stored as an integer with 5
;; decimal digits of precision.  This should provide for sufficient
;; granularity (up to tens of micro-seconds) for all our applications.
;; There is however some round-off error possible due to the
;; truncate and the round.  Fraction-portion may have some round-off error due to
;; the truncate.  This round-off error can be recovered by the round.
;; It should be possible to get more precision than 5 decimal digits
;; by using the negative portions of fixnums as well, assuming fixnums
;; are at least 24 bits.

;; Note that if the argument to truncate is a short float rather than a long float,
;; its second value will be a short float rather than a long float.  Thus, always
;; use short floats as arguments to truncate.



;;; Extract-number-from-compound-fixnum-simulation-time will construct
;;; a managed-float from macro-time and micro-time.  

(def-system-variable simulation-time-managed-float SIMULATE1
  (:funcall initialize-simulation-time-managed-float))

(defun initialize-simulation-time-managed-float ()
  (allocate-managed-float-box))

(defmacro extract-number-from-compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time)
  (let ((value-of-compound-fixnum-simulation-time (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time
	     ,compound-fixnum-simulation-time)
	    (integer-portion 
	      (macro-time ,value-of-compound-fixnum-simulation-time))
	    (micro-time
	      (micro-time ,value-of-compound-fixnum-simulation-time)))
       (cond 
	 ((=f micro-time 0)
	  (mutate-managed-float-value
	    simulation-time-managed-float
	    (coerce-fixnum-to-gensym-float integer-portion)))
	 (t
	  (mutate-managed-float-value
	    simulation-time-managed-float
	    (+e (coerce-fixnum-to-gensym-float integer-portion)
		(/e (coerce-fixnum-to-gensym-float micro-time)
		    (coerce-fixnum-to-gensym-float 
		      fraction-modulus-of-compound-fixnum-simulation-time))))))
       simulation-time-managed-float)))

(defmacro extract-gensym-float-from-compound-fixnum-simulation-time
    (compound-fixnum-simulation-time)
  (let ((value-of-compound-fixnum-simulation-time (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time
	       ,compound-fixnum-simulation-time)
	    (integer-portion 
	      (macro-time ,value-of-compound-fixnum-simulation-time))
	    (micro-time
	      (micro-time ,value-of-compound-fixnum-simulation-time)))
       (cond 
	 ((=f micro-time 0)
	  (coerce-fixnum-to-gensym-float integer-portion))
	 (t
	  (+e (coerce-fixnum-to-gensym-float integer-portion)
	      (/e (coerce-fixnum-to-gensym-float micro-time)
		  (coerce-fixnum-to-gensym-float 
		    fraction-modulus-of-compound-fixnum-simulation-time))))))))

(defmacro extract-macro-number-from-compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time)
  `(macro-time ,compound-fixnum-simulation-time))


(defmacro extract-micro-number-from-compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time)
  `(micro-time ,compound-fixnum-simulation-time))


(defmacro extract-micro-number-from-simulation-time-as-float
    (compound-fixnum-simulation-time)
  (let ((micro-time-var (gensym)))
    `(let ((,micro-time-var (micro-time ,compound-fixnum-simulation-time)))
       (if (=f ,micro-time-var 0)
	   0.0d0
	   (/e (coerce-fixnum-to-gensym-float ,micro-time-var)
	       (coerce-fixnum-to-gensym-float 
		 fraction-modulus-of-compound-fixnum-simulation-time))))))


;;; Transfer-value-of-compound-fixnum-simulation-times 

(defmacro transfer-value-of-compound-fixnum-simulation-times
	  (compound-fixnum-simulation-time-dest
	   compound-fixnum-simulation-time-source)
  (let ((value-of-compound-fixnum-simulation-time-dest (gensym))
	(value-of-compound-fixnum-simulation-time-source (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-dest
	     ,compound-fixnum-simulation-time-dest)
	    (,value-of-compound-fixnum-simulation-time-source
	     ,compound-fixnum-simulation-time-source))
       (setf (micro-time ,value-of-compound-fixnum-simulation-time-dest)
	     (micro-time ,value-of-compound-fixnum-simulation-time-source)
	     (macro-time ,value-of-compound-fixnum-simulation-time-dest)
	     (macro-time ,value-of-compound-fixnum-simulation-time-source)))))


;;; Add-to-compound-fixnum-simulation-time takes three 
;;; compound fixnum simulation times as arguments and leaves the
;;; result of the addition of the second and the third in the first.

(defmacro add-compound-fixnum-simulation-times
	  (accumulator-compound-fixnum-simulation-time
	   compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-accumulator-compound-fixnum-simulation-time (gensym))
	(value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-accumulator-compound-fixnum-simulation-time
	     ,accumulator-compound-fixnum-simulation-time)
	    (,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (cond
	 ((/=f micro-time-2 0)
	  (setq micro-time-1			; used as temporary accumulator here
		(+f micro-time-1 micro-time-2))
	  (cond
	    ((>=f micro-time-1
		  fraction-modulus-of-compound-fixnum-simulation-time)
	     (setf (micro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		   (-f micro-time-1
		       fraction-modulus-of-compound-fixnum-simulation-time))
	     (setq macro-time-1
		   (+f macro-time-1 1)))
	    (t
	     (setf (micro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		   micro-time-1))))
	 ((setf (micro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		micro-time-1)))
       (setf (macro-time ,value-of-accumulator-compound-fixnum-simulation-time)
	     (+f macro-time-1 macro-time-2)))))


;;; Subtract-from-compound-fixnum-simulation-time takes three
;;; compound fixnum simulation times as arguments and leaves the
;;; result of the subtraction of the third from the second in the first.

(defmacro subtract-compound-fixnum-simulation-times
	  (accumulator-compound-fixnum-simulation-time
	   compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-accumulator-compound-fixnum-simulation-time (gensym))
	(value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-accumulator-compound-fixnum-simulation-time
	     ,accumulator-compound-fixnum-simulation-time)
	    (,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2))
	    (result-negative-p nil))

       (when
	 (or (>f macro-time-2 macro-time-1)
	     (and (=f macro-time-1 macro-time-2)
		  (>f micro-time-2 micro-time-1)))
	 (psetq macro-time-1 macro-time-2
		macro-time-2 macro-time-1
		micro-time-1 micro-time-2
		micro-time-2 micro-time-1)
	 (setq result-negative-p t))
       ;; If time 2 is greater than time 1, result will be negative.

       (when (/=f micro-time-2 0)
	 (cond
	   ((>f micro-time-2 micro-time-1)
	    (setq macro-time-1
		  (-f macro-time-1 1)
		  micro-time-1
		  (-f (+f micro-time-1
			  fraction-modulus-of-compound-fixnum-simulation-time)
		      micro-time-2)))
	   (t
	    (setq micro-time-1
		  (-f micro-time-1 micro-time-2)))))
       (setq macro-time-1
	     (-f macro-time-1 macro-time-2))

       (if result-negative-p
	   (setf (micro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		 (*f micro-time-1 -1)
		 (macro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		 (*f macro-time-1 -1))
	   (setf (micro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		 micro-time-1
		 (macro-time ,value-of-accumulator-compound-fixnum-simulation-time)
		 macro-time-1)))))


;;; >compound-fixnum-simulation-time will return t if the
;;; first compound-fixnum-simulation-time is greater than the second.

(defmacro >compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (cond
	 ((>f macro-time-1 macro-time-2) t)
	 ((=f macro-time-1 macro-time-2)
	  (>f micro-time-1 micro-time-2))))))


(defmacro >=compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (cond
	 ((>f macro-time-1 macro-time-2) t)
	 ((=f macro-time-1 macro-time-2)
	  (>=f micro-time-1 micro-time-2))))))


;;; <compound-fixnum-simulation-time will return t if the
;;; first compound-fixnum-simulation-time is less than the second.

(defmacro <compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (cond
	 ((<f macro-time-1 macro-time-2) t)
	 ((=f macro-time-1 macro-time-2)
	  (<f micro-time-1 micro-time-2))))))


(defmacro <=compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (cond
	 ((<f macro-time-1 macro-time-2) t)
	 ((=f macro-time-1 macro-time-2)
	  (<=f micro-time-1 micro-time-2))))))


;;; =compound-fixnum-simulation-time will return t if the
;;; first compound-fixnum-simulation-time is equal to the second.

(defmacro =compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2)
	    (macro-time-1
	      (macro-time ,value-of-compound-fixnum-simulation-time-1))
	    (micro-time-1
	      (micro-time ,value-of-compound-fixnum-simulation-time-1))
	    (macro-time-2
	      (macro-time ,value-of-compound-fixnum-simulation-time-2))
	    (micro-time-2
	      (micro-time ,value-of-compound-fixnum-simulation-time-2)))
       (and (=f macro-time-1 macro-time-2)
	    (=f micro-time-1 micro-time-2)))))


;;; Min-compound-fixnum-simulation-time will return the smaller of the
;;; two compound fixnum simulation times.  If equal, the first will be returned.

(defmacro min-compound-fixnum-simulation-time
	  (compound-fixnum-simulation-time-1
	   compound-fixnum-simulation-time-2)
  (let ((value-of-compound-fixnum-simulation-time-1 (gensym))
	(value-of-compound-fixnum-simulation-time-2 (gensym)))
    `(let* ((,value-of-compound-fixnum-simulation-time-1
	     ,compound-fixnum-simulation-time-1)
	    (,value-of-compound-fixnum-simulation-time-2
	     ,compound-fixnum-simulation-time-2))
       (if (<compound-fixnum-simulation-time
	     ,value-of-compound-fixnum-simulation-time-1
	     ,value-of-compound-fixnum-simulation-time-2)
	   ,value-of-compound-fixnum-simulation-time-1	   
	   ,value-of-compound-fixnum-simulation-time-2))))

;; A max function could also be implemented in a similar way




;;;; Global Simulation Variables



(def-system-variable number-of-variables-to-process-at-a-time
		     simulate1 100)

(def-system-variable *task-for-display-of-simulation-time*
		     simulate1 nil)



(defvar ran-out-of-time?)

(defvar number-of-simulated-variables-processed)



(defun initialize-compound-simulation-time ()
  (make-compound-fixnum-simulation-time))

(def-system-variable simulation-time-accumulator simulate1 
  (:funcall initialize-compound-simulation-time))



(def-kb-specific-variable synchronous-model-queue SIMULATE1
  (:funcall initialize-model-queue)
   nil
   reclaim-model-queue-function)

(def-kb-specific-variable as-fast-as-possible-model-queue SIMULATE1
  (:funcall initialize-model-queue)
  nil
  reclaim-model-queue-function)

(def-system-variable current-model-queue? SIMULATE1 nil)

(def-system-variable processing-as-fast-as-possible-models? SIMULATE1 nil)

(def-system-variable simulator-initialized-as-data-server? SIMULATE1 nil)





;;;; Integration of Simulator with Main Run Loop (Run-scheduler)

;;; The simulator is initialized by initialize-simulator.  The main simulator
;;; function is simulate-one-cycle.  Simulate-one-cycle will update simulated
;;; values for all variables that should be updated during this cycle.  There are
;;; a number of important constraints which determine how the simulator should be
;;; integrated with the rest of the system.

;;; The simulator should never fail to get a value.  Therefore, the concept of
;;; deactivating portions of the simulator is not valid.  This means that
;;; simulation should continue, even if a variable is in-active from the
;;; standpoint of the inference engine.  The reason for this is that it is just
;;; wrong to "skip" portions of a simulation, an integration, for example.  This
;;; doesn't mean that all simulated variables have to be updated every cycle.  It
;;; is possible to specify different update intervals by the
;;; time-increment-for-update?  slot of the simulation-subtable?  which will overide
;;; the default simulation time increment of the simulator.  The bottom line is
;;; that every value which should be updated at some simulation time must be
;;; updated.

;;; All simulated variables that have to be updated in a cycle should be before
;;; the inference engine does anything.  This doesn't mean that the simulation
;;; itself can't be broken into parts of finer granularity than simulate-one-cycle
;;; so that the scheduled task will take less time.

;;; These constraints suggest that the simulator will not be run in real time, for
;;; the most part.  Gensym-time, rather than being based on a real time clock,
;;; will be incremented when the simulator is done and all inferencing for the
;;; cycle is done.


;;; Relation between current-simulation-time and gensym-time

;;; Simulate-one-cycle should be called enough times each tick of gensym-time to
;;; keep the simulator up to date with gensym time.  When the simulator is
;;; initialized, (current-simulation-time current-model-runtime-info?) is set to
;;; default-initial-simulation-time (which is 0), and (simulation-base-time
;;; current-model-runtime-info?) is set to gensym-time.  For each tick of
;;; gensym-time, simulate-one-cycle should be called until current-simulation-time
;;; + simulation-base-time = gensym-time.  The function
;;; simulate-until-consistent-with-gensym-time should be used to accomplish this.
;;; This mechanism ensures that simulate-one-cycle won't be called extra times
;;; (more than one time per gensym tick).  This allows for differences in
;;; simulation time increment and the basic gensym-time increment.  For example,
;;; if the gensym-time increment is one second and the simulation time increment
;;; is 0.1 second, then simulate-one-cycle must be called 10 times for every tick
;;; of gensym-time.  Furthermore, as mentioned above, The inference engine should
;;; not do anything until all simulation for the current gensym-time is completed.
;;; Note that these constraints are valid whether gensym-time is based on a real
;;; clock or is simply incremented when everything is finished.

;;; The above described mechanism could also conceivably be used to allow the
;;; simulator to "catch up" if more than one gensym tick has occurred since the
;;; last time the simulator was called.  The simulator does have to catch up since
;;; it can't skip any simulation time cycles.  Furthermore, if the simulator
;;; doesn't catch up, the inference engine will be using old or "delayed"
;;; simulated data if it is allowed to use this data at all.  This issue requires
;;; further review.

;;; The clock will be turned off when going into the break loop (gensym-time will
;;; stop).


;;; The flag (simulator-on?  simulation-parameters) is currently the only way to
;;; turn the simulator on or off.  It defaults to t and in this case, the
;;; simulator will run when the system is started.  If this flag is set to nil,
;;; the simulator will not run.  





;;; Simulate-until-consistent-with-gensym-time will call simulate-one-cycle until
;;; either current-simulation-time + simulation-base-time = gensym-time, or it
;;; runs out of time allotted to simulator.  It will return nil if it runs out of
;;; time, t otherwise.  If simulator is not on, it will do nothing and return t.
;;; The value returned indicates to run-scheduler whether the simulator needs more
;;; time.

;;; (Simulator-up-to-date?  current-model-runtime-info?) is cleared before the loop
;;; calling simulate-one-cycle and is set after the loop (when the simulator is up
;;; to date).

;;; Simulate-until-consistent-with-gensym-time will do nothing if simulator is not
;;; on or external simulation initialization is not complete.

;;; A model queue is a structure containing a group of models to be run together
;;; synchronously.  This is useful since it allows models to pass values to each
;;; other.  The slot models-in-queue contains a list of models for the queue.  The
;;; slot models-in-queue-to-process points to the cons in models-in-queue, the car
;;; of which is the model to be processed next.  As a model's simulation time
;;; becomes consistent with the time in the simulation-time-for-models-in-queue
;;; slot, the models-in-queue-to-process pointer is updated to the next model,
;;; until all models in the queue are up to date.  The slot
;;; shortest-time-increment-for-models-in-queue contains the shortest of the time
;;; increments for models in the queue.  The all-models-in-queue-waiting?  slot is
;;; set to indicate to the scheduler that there is no work to do until some
;;; simulation procedure or external simulation returns values.

;;; The global variable synchronous-model-queue contains a model queue of models
;;; running synchronously with gensym time.  The global variable
;;; as-fast-as-possible-model-queue contains a model queue of models running
;;; asynchronously with gensym time (as fast as possible).
;;; Add-model-to-simulation is used by initialize-simulator-1 to add models to
;;; these queues.  The models are added to the end of the queues.  This results in
;;; models being executed in the order in which they are added to the queues.
;;; Remove-model-from-simulation is used by shutdown-simulator-1 to remove models
;;; from the queues.  Note that if the arg to remove-model-from-simulation is
;;; main-model-runtime-info, all models are removed from queues (since the system
;;; is being shut down).






(def-structure model-queue
  (models-in-queue nil)
  (models-in-queue-to-process nil)
  (simulation-time-for-models-in-queue
    nil :reclaimer reclaim-compound-fixnum-simulation-time)
  (shortest-time-increment-for-models-in-queue 
    nil :reclaimer reclaim-compound-fixnum-simulation-time)
  (all-models-in-queue-waiting? nil)
  (simulation-base-time-for-models-in-queue
    nil :reclaimer reclaim-compound-fixnum-simulation-time))

(defun initialize-model-queue ()
  (make-model-queue))

(defun reclaim-model-queue-function (a-model-queue)
  (reclaim-model-queue a-model-queue))



(defun add-model-to-simulation (model-runtime-info)
  (loop as tail = nil then head
	as head = (models-in-queue current-model-queue?)
		then (cdr head)
	as model-runtime-info-in-queue = (car head)
	until (null head)
	do
    (when (eq model-runtime-info-in-queue model-runtime-info)
      (return (values)))
	finally
	  (if (null tail)
	      (setf (models-in-queue current-model-queue?)
		    (simulate-list model-runtime-info))
	      (setf (cdr tail) (simulate-list model-runtime-info)))))

(defun remove-model-from-simulation (model-runtime-info)
  (setf (model-runtime-status model-runtime-info) nil)
  (cond 
    ((eq model-runtime-info main-model-runtime-info)
     (setf (models-in-queue-to-process current-model-queue?) nil)
     (setf (all-models-in-queue-waiting? current-model-queue?) nil)
     (let ((models-to-shutdown
	     (copy-list-using-simulate-conses 
	       (models-in-queue current-model-queue?))))
       (loop for model-to-shutdown in models-to-shutdown
	     do (when (not (eq model-to-shutdown model-runtime-info))
		  (shutdown-simulator 
		    model-to-shutdown
		    (model-definition-for-model? model-runtime-info))))
       (reclaim-simulate-list models-to-shutdown))
     (delete-from-set (models-in-queue current-model-queue?)
		      model-runtime-info simulate))
    (t
     (when (eq model-runtime-info
	       (car (models-in-queue-to-process current-model-queue?)))
       (cond 
	 ((null (cdr (models-in-queue-to-process current-model-queue?)))
	  ;; At end of queue.  Go back to beginning.  If model to
	  ;; remove is still at head of list, then go past it.
	  (initialize-current-model-queue)
	  (when (eq model-runtime-info
		    (car (models-in-queue-to-process current-model-queue?)))
	    (setf (models-in-queue-to-process current-model-queue?)
		  (cdr (models-in-queue-to-process current-model-queue?)))
	    ;; (models-in-queue-to-process current-model-queue?) should be
	    ;; nil at this point.
	    ))
	 (t
	  (setf (models-in-queue-to-process current-model-queue?)
		(cdr (models-in-queue-to-process current-model-queue?))))))
     (delete-from-set (models-in-queue current-model-queue?)
		      model-runtime-info simulate))))

;; Delete-from-set automatically updates the location if the first cons
;; is the one that is removed.  Therefore, there is no need to specially
;; handle the case of (eq model-runtime-info (car (models-in-queue
;; current-model-queue?))).



(defun initialize-current-model-queue ()
  (setf (all-models-in-queue-waiting? current-model-queue?) t)
  (setf (models-in-queue-to-process current-model-queue?)
	(models-in-queue current-model-queue?)))



;;; Simulate-until-consistent-with-gensym-time processes each model in each
;;; model-queue until they are all up to date or waiting for external simulation
;;; or simulation procedures to finish, or until it runs out of time.
;;; Models-in-queue-to-process is used to keep track of which model to work on.
;;; Note that unlike other data servers, the simulator takes care of rescheduling
;;; itself.  Thus, simulate-until-consistent-with-gensym-time always returns t
;;; when it is called the first time at the beginning of a cycle from the
;;; scheduler.  Thus, the scheduler will not reschedule it and the simulator is
;;; completely responsible for rescheduling itself.  Rescheduling of
;;; simulate-until-consistent-with-gensym-time is done if it runs out of time, or
;;; when a procedure or external simulation finishes (see
;;; end-simulation-procedure-or-external-simulation-cycle).

;;; Rather than updating each model to gensym time completely,
;;; simulate-until-consistent-with-gensym-time proceeds in increments of
;;; (shortest-time-increment-for-models-in-queue current-model-queue?).  This
;;; way, models can pass data to each other (recall that models are added to
;;; model queues in order.



(defmacro any-models-running? () `(models-in-queue synchronous-model-queue))

(defun any-models-running-function? () (any-models-running?))



(defmacro update-simulation-time-for-all-models ()
  `(when (or processing-as-fast-as-possible-models?
	     (<e (extract-gensym-float-from-compound-fixnum-simulation-time
		  (simulation-time-for-models-in-queue current-model-queue?))
		(time-since-base-time-as-gensym-float)))
     (add-compound-fixnum-simulation-times
       (simulation-time-for-models-in-queue current-model-queue?)
       (simulation-time-for-models-in-queue current-model-queue?)
       (shortest-time-increment-for-models-in-queue current-model-queue?))
     t))


(defun-simple all-models-paused? (list-of-model-runtime-infos)
  (let ((result? t))
    (loop for runtime-info in list-of-model-runtime-infos
	  while result?
	  do
      (unless (model-paused? runtime-info)
	(setq result? nil)))
    result?))




;;; The function `need-calls-to-simulate-until-consistent-with-gensym-time'
;;; determines whether or not the simulator data server needs to be called at 1
;;; second intervals to execute it's simulations.  Note that if the value of
;;; this function changes from NIL to T due to changes in the simulator data
;;; structures, then schedule-data-server-accept-data-calls must be called.  It
;;; is currently called from the slot putter for simulator-on?.

(defun-simple need-calls-to-simulate-until-consistent-with-gensym-time ()
  (simulator-on? simulation-parameters))




;;; `simulate-until-consistent-with-gensym-time' returns a t when its caught
;;; up. Now if you're in as-fast-as-possible mode you're never caught up, unless
;;; all the models in the queue are paused. This is the reason for
;;; the "(or all-models-paused? clause below -rdf, 4/3/95

(defun simulate-until-consistent-with-gensym-time ()
  (cond
    ((and (simulator-on? simulation-parameters)
	  (not (g1-authorized-p)))
     (setf (clock-get inhibit-non-real-time-clock-ticks?) nil)
     (when (not simulator-initialized-as-data-server?)
       (initialize-simulator)
       (setq simulator-initialized-as-data-server? t))
     (let ((number-of-simulated-variables-processed 0)
	   (current-computation-flags current-computation-flags))
       (setf (role-serve-inactive-objects?) t)
       (let ((processing-as-fast-as-possible-models? t))
	 (when (and (simulate-until-consistent-with-gensym-time-1 
		      as-fast-as-possible-model-queue)
		    inhibit-non-real-time-clock-ticks?)
	   (return-from simulate-until-consistent-with-gensym-time t)))
       (and (or (null (models-in-queue as-fast-as-possible-model-queue))
		(all-models-paused? (models-in-queue
				      as-fast-as-possible-model-queue)))
	    (simulate-until-consistent-with-gensym-time-1 
	      synchronous-model-queue))))
    (t t)))

;; Both queues need to be done in order for this to return t (indicating that
;; simulation is done).

(defun simulate-until-consistent-with-gensym-time-1 (model-queue)
  (cond
    ((models-in-queue model-queue)
     (let ((current-model-queue? model-queue))
       (when (null (models-in-queue-to-process current-model-queue?))
	 (initialize-current-model-queue)
	 (when (simulation-time-for-models-in-queue current-model-queue?)
	   (update-simulation-time-for-all-models)))
       (loop with ran-out-of-time? = nil
	     with model-consistent-or-waiting?
	     as current-model-to-process 
	     = (car (models-in-queue-to-process current-model-queue?))
	     
	     do
	 (when (eq (model-runtime-status current-model-to-process) 
		   'needs-to-be-initialized)
	   (if (eq current-model-to-process main-model-runtime-info)
	       (initialize-simulator)
	       (initialize-simulator 
		 current-model-to-process 
		 (model-definition-for-model? current-model-to-process))))
	 (cond
	   ;; if the above initialization didn't "take", don't proceed
	   ((eq (model-runtime-status current-model-to-process) 
		'needs-to-be-initialized)
	    (return t))
	   ((eq (model-runtime-status current-model-to-process)  
		'needs-to-be-shutdown)
	    (if (eq current-model-to-process main-model-runtime-info)
		(shutdown-simulator)
		(shutdown-simulator 
		  current-model-to-process 
		  (model-definition-for-model? current-model-to-process)))
	    (when (null (models-in-queue-to-process current-model-queue?))
	      (return t)))
	   (t
	    ;; otherwise g2 can hang if the model is paused while running in
	    ;; as-fast-as-possible? mode
	    (when (model-paused? current-model-to-process)
	      (return t))
	    ;; Fix for bug HQ-755483.  In simulated time mode G2 was not always
	    ;; completing all simulation work in each clock tick.  This was
	    ;; because there was a time-slice-expired-p check here which caused
	    ;; this function to return t. The time slice expired-p check now
	    ;; causes this function to return nil.
	    ;; Returning t indicates that all the simulation work has been
	    ;; completed in this time slice.
	    ;; Returning nil indicates that there is still simulation work to
	    ;; be completed.
	    (when (time-slice-expired-p)
	      (return nil))
	    (setq model-consistent-or-waiting? 
		  (simulate-model-until-consistent current-model-to-process))
	    
	    (cond
	      ((null model-consistent-or-waiting?)
	       (return nil))			       ; ran out of time
	      ((and (eq model-consistent-or-waiting? 'waiting)
		    (not (dont-wait-for-model-to-finish-function?
			   current-model-to-process)))
	       (setf (clock-get inhibit-non-real-time-clock-ticks?) t)
	       (return t))
	      (t
	       (setf (models-in-queue-to-process current-model-queue?)
		     (cdr (models-in-queue-to-process current-model-queue?)))
	       (when (not (eq model-consistent-or-waiting? 'waiting))
		 (setf (all-models-in-queue-waiting? current-model-queue?) nil))
	       (when (null (models-in-queue-to-process current-model-queue?))
		 (when (all-models-in-queue-waiting? current-model-queue?) 
		   (setf (clock-get inhibit-non-real-time-clock-ticks?) t)
		   (return t))
		 (if (update-simulation-time-for-all-models)
		     (initialize-current-model-queue)
		     (return t))))))))))
    (t  ; if no models in queue, all done
     t)))





;;; Simulate-model-until-consistent can return one of three things: t if the model
;;; is consistent with simulation-time-for-models-in-queue, nil if it ran out of time,
;;; or 'waiting if the model is waiting for a procedure or external simulation.

(defun-allowing-unwind simulate-model-until-consistent (model-runtime-info)
   
  (with-current-model
    model-runtime-info (model-definition-for-model? model-runtime-info)
    (cond
      ((and (not (simulation-error? current-model-runtime-info?))
	    (not (current-model-is-paused?))
	    (external-simulation-initialization-completed?
	      current-model-runtime-info?))
       (let ((within-simulate-until-consistent-with-gensym-time t))
	 (catch 
	   'simulation-error-catch
	   (simulate-model-until-consistent-internal))))
      (t
       t))))

(defun simulate-model-until-consistent-internal ()
  (cond
    ((or current-model-runtime-info?
	 (current-external-simulator-configuration))
     (with-temporary-creation
       simulate-model-until-consistent-internal
       (check-for-simulation-changes)
       (cond
	 ((waiting-for-external-simulator? current-model-runtime-info?)
	  (return-from simulate-model-until-consistent-internal 'waiting))
	 (t
	  (loop do
	    (add-compound-fixnum-simulation-times
	      simulation-time-accumulator
	      (current-simulation-time current-model-runtime-info?)
	      (simulation-base-time current-model-runtime-info?))
	    
	    (cond
	      ((<compound-fixnum-simulation-time
		 simulation-time-accumulator
		 (simulation-time-for-models-in-queue current-model-queue?))
	       (when (not (simulation-procedure-and-external-simulation-finished?))
		 (return-from simulate-model-until-consistent-internal 'waiting)))
	      (t
	       (setf (simulator-up-to-date? current-model-runtime-info?) t)
	       (return-from simulate-model-until-consistent-internal t)))
	    (loop do
	      (setf (simulation-resumption-stack current-model-runtime-info?)
		    (if (simulation-resumption-stack current-model-runtime-info?)
			(resume-task (simulation-resumption-stack
				       current-model-runtime-info?))
			(work-on-suspendable-task
			  'simulate-one-cycle
			  nil nil nil nil)))
	      ;; If simulation-resumption-stack is not nil at this point,
	      ;; then there is more work to do.  If ran-out-of-time?  is
	      ;; non-nil, then the time allotted to the simulator has
	      ;; expired and it is necessary to return control to the g2
	      ;; scheduler.
	      (when (null (simulation-resumption-stack
			    current-model-runtime-info?))
		(return t))
	      (when ran-out-of-time? 
		(return-from simulate-model-until-consistent-internal nil))))))))
    (t
     (warning-message 1
		      "The simulator is not initialized and will not do anything. ~
                       Restarting is recommended."))))


;; If ran-out-of-time? is nil, return t, else nil.  Returning t indicates to 
;; run-schedule-cycle that the data server is finished.

;; Note that whether the simulator is up to date has nothing to do with the
;; simulation time increments of variables.  Thus, even if a variable has a long
;; simulation time increment and its simulated value hasn't changed for a while,
;; it is still valid to data serve this value if the simulator as a whole is up to
;; date.

;; Consider having the simulator not check at all whether the simulator is 
;; up to date and just return values.  This is probably wrong but it is the
;; way some real-life data servers might behave.  If this were done, it
;; would be necessary to use the collection-time? argument of put-current-value
;; to indicate to the inference engine at what time the value was computed.
;; Actually, this capability is provided by parameters.





;;;; Simulation Frame Definitions

;;; A variable can have a simulation-subtable in its simulation-details slot
;;; to allow for specific simulation (see also VARIABLES).

;; The class definition for simulation-subtable has been moved to VARIABLES
;; because some of the slot accessor macros are needed in that file.

(def-absent-slot-putter simulation-computation-methods (frame formulas)
  (set-slot-value frame 'simulation-formulas? formulas))

;; Class definition for generic-simulation-formula moved to VARIABLES
;; due to needed accessor definitions.





;;;; Initialization

;;; Initialize-simulator sets up all runtime structures for running the simulator.
;;; This includes setting up pointers between things that may be edited and the
;;; runtime structures that they effect.  Add-variable-to-simulation,
;;; remove-variable-from-simulation, and handle-editing-changes-effecting-simulation
;;; allow for editing the simulation while running.  Runtime structures effected
;;; by edits are re-derived as appropriate.

;;; Initialize-simulator allocates things but never reclaims anything; 
;;; shutdown-simulator takes care of all reclamation.

;;; The important rule for variable simulation runtime structures is that they
;;; only exist for variables being simulated.  Thus, the
;;; simulation-runtime-information?  slot of a variable only contains one of these
;;; structures if the simulator is running and the variable has a simulation-info
;;; structure.  Initialize-simulator allocates these structures for each variable
;;; being simulated, and shutdown-simulator reclaims them.  Variables can be added
;;; and removed from the simulation while running, via add-variable-to-simulation
;;; and remove-variable-from-simulation.  These functions cause the structures to
;;; be allocated and reclaimed although this is done synchronously at the
;;; beginning of the simulation cycle.  If the simulation is suspended in the
;;; middle of a cycle and an edit is made while suspended, then
;;; simulate-until-consistent-with-gensym-time will rollback the simulation to the
;;; beginning of the time step, handle the changes, and repeat that time step (see
;;; check-for-simulation-changes).

;;; There are two important assumptions for running simulations correctly:
;;; 1.  the simulator should never have trouble getting a value for a variable,
;;; 2.  the simulator should never get conflicting values for the same variable
;;; from different equations (different generic equations).  The second condition
;;; can not exist because variables have at most one simulation formula.  If the
;;; first condition exists, there is a serious problem with the simulation.
;;; However, the simulation will continue as best it can and will not bomb out.
;;; In order to notify the user of these problems, notes are posted to the
;;; operator logbook.

;;; Since state variables always have initial values, these notes will never apply
;;; to state variables, only dependent variables.  These notes will also be posted
;;; if new variables are introduced while the simulator is running (see
;;; simulate-one-cycle).






;;; Current-model-runtime-info?  is set to a model-runtime-info structure when the
;;; simulator is initialized.  This structure has the slots:
;;; model-continuous-state-variable-info, model-discrete-state-variable-info, and
;;; model-dependent-variable-info.  These slots contain variable simulation sets.
;;; The variable-simulation-runtime-structures have the slot runtime-formula where
;;; the efficient runtime form of the (possibly generic) formula entered by the
;;; user can be cached.  These structures also have the slot supporting-structures
;;; which is a list of the variable-simulation-runtime-structures in the runtime
;;; formula corresponding to dependent variables.  These are used to sort the
;;; dependent variable info list.  Current-model-runtime-info?  also has the slot
;;; model-sort-boundary-for-dependent-variable-info which points to the last
;;; sorted entry in the model-dependent-variable-info slot.  Entries after this
;;; one could not be sorted.  These entries correspond to variables that are in
;;; ordering or algebraic loops.

;;; Initialize-simulator is not suspendable because
;;; add-to-structures-effected-by-edit-cache sets the frame serial number
;;; for the cache (see also add-to-structures-effected-by-edit-cache).

;; Existence and uniqueness of ordering - 
;; The sorting done here is not exactly like the numerical sorting done by
;; algorithms like heapsort since often, more than one correct ordering exists.
;; The only time there is one unique ordering is when every variable depends on
;; another dependent variable and there are no loops.  Note that when a variable
;; is in an ordering or algebraic loop, no correct ordering for that variable
;; exists in the loop.



(defun initialize-simulator-as-data-server ()
  (let (anything-to-simulate?)
    (with-current-model-and-queue nil nil
      (setq anything-to-simulate?
	    (anything-to-simulate? current-model-runtime-info?)))
    (if anything-to-simulate?
	(let ((data-server (data-server 'simulator-data-server)))
	  (setf (server-is-in-use data-server) t)
	  (setq simulator-initialized-as-data-server? nil)
	  (schedule-task-to-accept-data data-server))
	(setq simulator-initialized-as-data-server? t))))

(defun initialize-simulator (&optional model-runtime-info? model-definition?)
  (with-current-model-and-queue
    model-runtime-info? model-definition?
    (initialize-simulator-1)))

(defun-allowing-unwind initialize-simulator-1 ()
  (when (anything-to-simulate? current-model-runtime-info?)
    (let ((number-of-simulated-variables-processed 0)
	  (current-computation-flags current-computation-flags))
      (setf (role-serve-inactive-objects?) t)
      
      (add-model-to-simulation current-model-runtime-info?)
      
      (setf (model-runtime-status current-model-runtime-info?) 'running)
      (setf (simulated-variable-removed? current-model-runtime-info?) nil)

      (unless warmbooting?
	(clear-variables-that-need-simulated-values))
      
      (setf (simulation-procedure-finished? current-model-runtime-info?) t)
      (setf (waiting-for-external-simulator? current-model-runtime-info?) nil)
      (setf (simulation-error? current-model-runtime-info?) nil)
      (setf (simulation-resumption-stack current-model-runtime-info?) nil)
      (setf (rk4-step current-model-runtime-info?) nil)
      
      (setf (server-is-in-use (data-server 'simulator-data-server)) t)
      
      (with-temporary-gensym-float-creation initialize-simulator-1
	(store-number-into-compound-fixnum-simulation-time
	  (runtime-default-simulation-time-increment current-model-runtime-info?)
	  (current-default-simulation-time-increment))
	(store-number-into-compound-fixnum-simulation-time
	  (shortest-override-time-increment current-model-runtime-info?)
	  -1))
      (transfer-value-of-compound-fixnum-simulation-times
	(shortest-simulation-time-increment current-model-runtime-info?)
	(runtime-default-simulation-time-increment current-model-runtime-info?))
      
      (initialize-variables-for-model)
      
      ;; Initialize simulation time.
      (transfer-value-of-compound-fixnum-simulation-times
	(current-simulation-time current-model-runtime-info?)
	(default-initial-simulation-time current-model-runtime-info?))
      (transfer-value-of-compound-fixnum-simulation-times
	(new-simulation-time current-model-runtime-info?)
	(default-initial-simulation-time current-model-runtime-info?))
      (store-number-into-compound-fixnum-simulation-time
	(simulation-base-time current-model-runtime-info?)
	(ffloore (time-since-base-time-as-gensym-float)))
      
      ;; Initialize all variables.
      ;; During initialization, state variables are handled as a special
      ;; case.  Their values are calculated first and the initial value 
      ;; is used.
      (catch 
	'simulation-error-catch
	(let ((initializing-simulator? t))
	  (setf (simulator-step-flag current-model-runtime-info?)
		'calculating-dependent-variables)
	  (unless warmbooting?
	    (compute-initial-values-for-all-state-variables))
	  (calculate-new-values-for-dependent-variables
	    (installation-set-next?
	      (model-dependent-variable-info current-model-runtime-info?))
	    nil 
	    nil)
	  (update-variables)))
      
      ;; Initialize external portion of simulation.  Note that this is done
      ;; after initialization of internal variables so that those values can
      ;; be used for initialization of the external portion.
      
      (initialize-externally-simulated-portion-of-model)
      ;; Note that at this point, the output vector variables for the external
      ;; simulation do not have values.  It may be necessary for the external
      ;; simulation to set these output values when initializing.
      
      (add-shortest-simulation-time-increment-for-all-models 
	(shortest-simulation-time-increment current-model-runtime-info?)) 
      )))

;; I may have to wrap with-temporary-gensym-float around initialize-simulator
;; to catch number conses which result from evaluating temporary constants.

;; Initial value expressions for state variables could be cached as well to 
;; speed up initialization.

;; Currently, after initialization, time of next update for each variable is
;; 0 + shortest-simulation-time-increment rather than just 0.  This means that
;; for the first call to simulate-one-cycle, nothing gets updated.  This
;; isn't a big problem but it should be fixed at some point!





(defun initialize-variables-for-model ()
  (for-each-variable-in-model
    'make-and-initialize-variable-simulation-runtime-structure)
  (for-each-variable-in-model
    'initialize-runtime-simulation-information-for-variable)
  ;; Note that the above loops have to be separate because
  ;; variable-simulation-runtime-structures must exist for all variables when
  ;; initialize-runtime-simulation-information-for-variable is called.
  
  ;; The dependent variable structures have to be sorted here to eliminate recursion.
  ;; Algebraic and ordering loops could also be identified here.
  (when (not (installation-set-empty?
	       (model-dependent-variable-info current-model-runtime-info?)))
    (sort-dependent-variable-info))

  )


(defun make-and-initialize-variable-simulation-runtime-structure 
    (variable-or-parameter)
  (with-temporary-gensym-float-creation make-and-initialize
    (let* ((simulation-subtable?
	     (when (variable-p variable-or-parameter)
	       (simulation-details variable-or-parameter)))
	   (simulation-subtable-time-increment-for-update?
	     (if simulation-subtable?
		 (slot-value-number-value 
		   (time-increment-for-update? simulation-subtable?))))
	   (override-time-increment-for-update?
	     (or simulation-subtable-time-increment-for-update?
		 (slot-value-number-value
		   (formula-specified-time-increment-for-update?
		     variable-or-parameter))))
	   (variable-simulation-runtime-structure
	     (let ((old-runtime-structure?
		     (simulation-runtime-information? variable-or-parameter))
		   (new-runtime-structure
		     (make-variable-simulation-runtime-structure)))
	       (when old-runtime-structure?
		 (when warmbooting?
		   (setf (new-simulation-value new-runtime-structure)
			 (copy-for-slot-value (new-simulation-value old-runtime-structure?)))
		   (setf (simulation-value new-runtime-structure)
			 (copy-for-slot-value (simulation-value old-runtime-structure?))))
		 (reclaim-variable-simulation-runtime-structure
		   old-runtime-structure?))
	       (setf (corresponding-variable new-runtime-structure) 
		     variable-or-parameter)
	       (set-simulation-runtime-information?
		 variable-or-parameter new-runtime-structure)
	       new-runtime-structure)))
      
      (setf (interval-at-which-to-send-value-to-inference-engine
	      variable-simulation-runtime-structure) nil)
      (set-up-update-timing-for-variable 
	variable-simulation-runtime-structure
	override-time-increment-for-update?)
      (unless warmbooting?
	(setf (simulation-value variable-simulation-runtime-structure)
	      simulation-no-value)
	(setf (new-simulation-value variable-simulation-runtime-structure)
	      simulation-no-value))

      ;; It is important not to leave these slots as nil (to which they are 
      ;; initialized) since the evaluators such as first-that-has-a-value 
      ;; take nil to be a valid value.

      (setf (variable-needs-simulated-value? 
	      variable-simulation-runtime-structure) nil)
      
      variable-simulation-runtime-structure)))

(defun initialize-runtime-simulation-information-for-variable (variable)
  (let ((variable-simulation-runtime-structure
	  (simulation-runtime-information? variable)))
    (generate-and-set-runtime-formula
      variable variable-simulation-runtime-structure))
  (begin-collecting-data-for-simulated-variable-if-appropriate variable))



;;; Generate-and-set-runtime-formula computes three values: a runtime formula, a
;;; runtime cache, and a list of things that effect the formula.  If any of these
;;; things are edited, the runtime cache must be rederived.
;;; Generate-and-set-runtime-formula binds the special variable
;;; note-things-encountered-during-role-service?  to t to indicate to role servers
;;; that entities and connections encountered during role service be added to the
;;; set things-that-affect-this-formula, another special variable.
;;; Serve-first-value-of-role adds the entity that is the domain to this set if
;;; the role is a slot name.
;;; Search-for-directly-connected-entities-for-connection adds entities and
;;; connections encountered during the search to this set.  Generate-formula-eval
;;; adds any variables encountered via symbols (either local names or names of kb
;;; objects) to this set.  If a generic-simulation-formula is used to compute the
;;; runtime formula, then it is added to the set.  If a specific simulation
;;; formula is used, then the variable itself is added to the set.

;;; The runtime-formula slot of the variable-simulation-runtime-structure is set
;;; to point to the byte-code-body within the generic or specific simulation
;;; formula.  There is no danger of data corruption since the runtime structure
;;; will be re-derived if the generic or specific simulation formula is deleted.

;;; The basic idea here is to evaluate designations and cache the result.
;;; Rederiving a runtime cache when one of the things that effects it is edited
;;; amounts to recaching.  Not all designations can be cached like this.  Only
;;; designations which contain exclusively attribute roles, item names, and
;;; connection roles (connected-to, at-port, at-an-input, at-an-output,
;;; at-input-end, at-output-end, and at-either-end) can be cached.

;;; The connection roles all use search-for-directly-connected-entities.  It is
;;; easy to note objects and connections encountered in this search so it is easy
;;; to cache and uncache these roles.  At some point, it may be desireable to
;;; cache more roles although certain roles (nearest, for example) present serious
;;; problems related to knowing when to decache.

;;; If the role is an attribute, it is handled as a special case by
;;; serve-first-value-of-role; no role server function is called.  Such roles are
;;; cached and the entity that is the domain is noted for purposes of decaching.

;;; Note that the set of entities encountered during role service (during
;;; connection searching for example) and the set of entities served by role
;;; service are not necessarily the same.  The latter is usually a subset of the
;;; former.  However, all entities encountered must be noted.

;;; The runtime formula is derived from the specific simulation formula for the
;;; variable if one exists, or the most specific generic simulation formula that
;;; applies to the variable.  Thus, more specific formulas overide more generic
;;; ones and there is one unique runtime formula for the variable at any time (see
;;; also get-simulation-specifier-to-use,
;;; generic-simulation-formula-for-variable-or-parameter).

(defun generate-and-set-runtime-formula
       (variable variable-simulation-runtime-structure)
  (let ((things-that-affect-runtime-formula
	  (generate-and-set-runtime-formula-1
	    variable variable-simulation-runtime-structure)))
    (note-runtime-structure-in-things-that-affect-it
      variable things-that-affect-runtime-formula nil)
    (reclaim-eval-list things-that-affect-runtime-formula)))

(defun generate-and-set-runtime-formula-1
    (variable variable-simulation-runtime-structure)
  ;; Find specific or generic formula.
  (let ((current-computation-flags current-computation-flags))
    (setf (role-serve-inactive-objects?) t)
    (let* ((note-things-encountered-during-role-service? t)
	   (things-that-affect-this-formula nil)
	   (simulation-specifier-to-use
	     (get-simulation-specifier-to-use variable)))
      (cond
	((simulation-subtable-p simulation-specifier-to-use)
	 (add-to-set things-that-affect-this-formula variable))
	((generic-simulation-formula-p simulation-specifier-to-use)
	 (add-to-set things-that-affect-this-formula 
		     simulation-specifier-to-use)))

      ;; Then "evaluate" to generate specific cache.
      (setf (simulation-formula variable-simulation-runtime-structure)
	    simulation-specifier-to-use)
      (initialize-simulation-environment-vector
	variable simulation-specifier-to-use)
      things-that-affect-this-formula)))



;;; Initialize-simulation-environment-vector allocates a
;;; simulation-environment-vector if necessary.  It then puts the focal entity
;;; into the environment vector, sets the recaching needed flag in the environment
;;; vector, sets the runtime-formula slot of the runtime-structure, and calls
;;; stack-eval to cache the cacheable bindings in the environment vector.
;;; Finally, it computes the supporting variables for the cacheable bindings and
;;; returns the byte-code-body for the simulation-formula.  Note that designations
;;; within quantifiers and aggregators are not cached since these forms do
;;; iteration.  See also compile-simulation-formula-for-stack.


(defun initialize-simulation-environment-vector (variable simulation-formula)
  (let* ((runtime-structure
	   (simulation-runtime-information? variable))
	 (byte-code-body
	   (cond
	     ((frame-of-class-p simulation-formula 'generic-simulation-formula)
	      (generic-simulation-formula-byte-code-body simulation-formula))
	     ((frame-of-class-p simulation-formula 'simulation-subtable)
	      (simulation-subtable-byte-code-body simulation-formula))))
	 (simulation-environment-vector
	   (get-or-make-simulation-runtime-cache 
	     (var-count (byte-code-body-environment-description byte-code-body))
	     runtime-structure nil))
	 (initial-value-byte-code-body?
	   (cond
	     ((generic-simulation-formula-p simulation-formula)
	      (generic-simulation-initial-value-byte-code-body
		simulation-formula))
	     ((simulation-subtable-p simulation-formula)
	      (simulation-subtable-initial-value-byte-code-body
		simulation-formula))))
	 (initial-value-simulation-environment-vector?
	   (when initial-value-byte-code-body?
	     (get-or-make-simulation-runtime-cache 
	       (var-count (byte-code-body-environment-description
			 initial-value-byte-code-body?))
	       runtime-structure t)))
	 (focal-entity? (get-formula-focal-entity-for-variable variable))
	 (dependent-variable? (dependent-variable-p variable)))
    (when initial-value-simulation-environment-vector?
      (when focal-entity?
	(setf (svref initial-value-simulation-environment-vector? 3) 
	      focal-entity?))
      (set-recaching-needed-flag 
	initial-value-simulation-environment-vector? nil))     ; recaching not needed
    (when dependent-variable?
      (reclaim-eval-list 
	(supporting-structures runtime-structure))
      (setf (supporting-structures runtime-structure) nil))
    (when focal-entity?
      (setf (svref simulation-environment-vector 3) focal-entity?)) 
    (set-recaching-needed-flag 
      simulation-environment-vector t)  ; recaching needed

    (setf (runtime-formula runtime-structure) byte-code-body)
    
    ;; stack eval to cache bindings;  
    ;; note that initializing-simulator, initializing-state-variables? are nil at this point
    (sim-eval-for-stack-without-chaining variable)

    (set-recaching-needed-flag 
      simulation-environment-vector nil)  ; recaching not needed

    (when dependent-variable?
      (loop with binding-cache-start-index = (if focal-entity? 4 3)
	    with evaluated-designation
	    for index from binding-cache-start-index 
		      below (+f binding-cache-start-index
				(evaluation-integer-value 
				  (svref simulation-environment-vector 2)))
	    do
	(setq evaluated-designation (svref simulation-environment-vector index))
	(note-supporting-variables
	  evaluated-designation runtime-structure)))))

(defun set-recaching-needed-flag 
       (simulation-environment-vector recaching-needed?)
  (let ((existing-flag?
	  (svref simulation-environment-vector 0)))
    (when existing-flag?
      (reclaim-evaluation-truth-value existing-flag?))
    (setf (svref simulation-environment-vector 0)
	  (make-evaluation-truth-value
	    (if recaching-needed? truth falsity)))))



(defun note-supporting-variables 
       (cached-designation runtime-structure)
  (when (and (of-class-p cached-designation 'variable-or-parameter)
	     (variable-belongs-to-current-model? cached-designation))
    (add-to-set (supporting-structures runtime-structure)
		cached-designation)))



;;; Roles-in-designation-can-be-cached? checks to make sure that all roles in
;;; the argument expression can be cached (see discussion preceding 
;;; generate-runtime-formula).  If all roles can be cached, t is returned,
;;; else nil.

(defun roles-in-designation-can-be-cached? (designation runtime-cache)
  (cond
    ((null designation)  ; let for local name in there exists expression
     nil)
    ((consp designation)
     (case (car designation)
       (the
	(let ((role (second designation))
	      (domain? (third designation)))
	  (cond
	    ((consp role)
	     ;; domain? should not be nil here
	     (if (role-can-be-cached? (car role))
		 (roles-in-designation-can-be-cached? domain? runtime-cache)))
	    
	    ;; At this point, role is a symbol and domain? is non-nil.
	    ;; It is assumed that if the role has no role server, it is
	    ;; an attribute name, in which case it can be cached
	    ;; (or at least it is ok to attempt an evaluate-designation).
	    ((or (not (role-server-exists-p role))	       ; attribute name
		 (role-can-be-cached? role))
	     (roles-in-designation-can-be-cached? domain? runtime-cache))
	    (t
	     ;; Role can't be cached.
	     nil))))))
    (t
     ;; If not a cons, then a domain symbol which designates a
     ;; global kb object (cacheable).
     t)))

;; It is significant that roles-in-designation-can-be-cached?  is called before
;; entity evaluate.  This way, roles that can't be cached are filtered out and
;; evaluate-designation is never called for these designations.  If it were,
;; objects and connections encountered during the role service would be added to
;; things-that-affect-this-formula which would cause needless activity when these
;; objects and connections are edited while running.  This is also the reason that
;; role filtering can't be done within evaluate-designation itself.

;; Giver-of-value is actually a quantifier like "the".  Designations containing
;; giver-of-value are not currently cached.

;; See also evaluate-designation, serve-unique-value-of-role, and serve-first-value-of-role
;; for specs on role serving.

;; Note that the simulator only deals with forward role servers, never
;; inverse role servers.



(defparameter list-of-roles-that-can-be-cached
	      '(connected-to at-port at-an-input at-an-output
			     at-input-end at-output-end at-either-end))

(defun role-can-be-cached? (role-name)
  (memq role-name list-of-roles-that-can-be-cached))

;; Note that it is better (safer) to filter by roles that can be cached rather
;; than by ones that can't.  This way, as new roles are added, they won't
;; be cached unless they are explicitly on this list.  Note also that
;; role-can-be-cached? does not deal with roles that are attributes.
;; These are handled separately by roles-in-designation-can-be-cached?
;; and are cached.



;;; Note-runtime-structure-in-things-that-affect-it caches the variable in the
;;; runtime-structures-affected-by-this...  slot of each of the things in
;;; things-that-affect-runtime-formula.  This slot is of the form
;;; (frame-serial-number .  structures).

;;; I believe that this comment is obsolete, and that these slots now hold
;;; edit-cache structures. -alatto, 3/26/99

;;; The frame serial number is needed in the
;;; case where structures are frames (variables in this case) which may have been
;;; deleted.  It is therefore necessary to check if the frame has been reprocessed
;;; before doing anything with it.  This is the reason why variables rather than
;;; variable-simulation-runtime-structures are cached here; variables are frames
;;; so it is possible to check if they have been reprocessed.  Since there is a
;;; one-to-one correspondence between variables and
;;; variable-simulation-runtime-structures with pointers going both ways, it
;;; really makes no difference which is cached.  In the end, it is the
;;; runtime-formula, contained in the variable-simulation-runtime-structure, which
;;; is rederived.

(defun note-runtime-structure-in-things-that-affect-it
       (variable things-that-affect-runtime-formula affects-installation?)
  (loop for thing in things-that-affect-runtime-formula
	as edit-cache? = (get-or-make-edit-cache thing)
	do
    (when edit-cache?
      (add-to-structures-affected-by-edit-cache 
	edit-cache? variable affects-installation?))))

(defun get-or-make-edit-cache (thing)
  (cond
    ((framep thing)
     (cond
       ((frame-of-class-p thing 'entity)
	(setf (runtime-structures-affected-by-this-entity thing)
	      (get-or-make-edit-cache-1
		(runtime-structures-affected-by-this-entity thing))))
       ((frame-of-class-p thing 'statement)
	(setf (runtime-structures-affected-by-this-statement thing)
	      (get-or-make-edit-cache-1
		(runtime-structures-affected-by-this-statement thing))))
       ((frame-of-class-p thing 'connection)
	(get-or-make-edit-cache (connection-for-this-connection-frame thing)))))
    ((connection-p thing)
     (setf (runtime-structures-affected-by-this-connection thing)
	   (get-or-make-edit-cache-1
	     (runtime-structures-affected-by-this-connection thing))))))

(defun get-or-make-edit-cache-1 (edit-cache?)
  (or edit-cache? (make-edit-cache)))

(defun add-to-structures-affected-by-edit-cache 
       (edit-cache runtime-structure-to-add affects-installation?)
  (purge-deleted-frames-and-add-new-one 
    edit-cache affects-installation? runtime-structure-to-add)
  (frame-serial-number-setf (edit-cache-frame-serial-number edit-cache) (current-frame-serial-number)))

(defun purge-deleted-frames-and-add-new-one
       (edit-cache affects-installation? runtime-structure-to-add)
  (loop with frame-serial-number-for-cache
	  = (edit-cache-frame-serial-number edit-cache)
	with trailing-pointer? = nil
	with leading-pointer = (if affects-installation?
				   (variables-to-reinstall edit-cache)
				   (variables-to-rederive edit-cache))
	with cons-to-reclaim
	with exists-in-cache? = nil
	as runtime-structure-to-check? = (car leading-pointer)
	while runtime-structure-to-check?
	do
    (if (eq runtime-structure-to-check? runtime-structure-to-add)
	(setq exists-in-cache? t))
    (cond
      ((frame-has-been-reprocessed-p
	 runtime-structure-to-check? frame-serial-number-for-cache)
       (if trailing-pointer?
	   (setf (cdr trailing-pointer?) (cdr leading-pointer))
	   (if affects-installation?
	       (setf (variables-to-reinstall edit-cache) (cdr leading-pointer))
	       (setf (variables-to-rederive edit-cache) (cdr leading-pointer))))
       (setq cons-to-reclaim leading-pointer)
       (setq leading-pointer (cdr leading-pointer))
       (reclaim-eval-cons cons-to-reclaim))
      (t
       (setq trailing-pointer? leading-pointer
	     leading-pointer (cdr leading-pointer))))
	finally
	  (if (not exists-in-cache?)
	      (if affects-installation?
		  (setf (variables-to-reinstall edit-cache) 
			(eval-cons runtime-structure-to-add
				   (variables-to-reinstall edit-cache)))
		  (setf (variables-to-rederive edit-cache) 
			(eval-cons runtime-structure-to-add
				   (variables-to-rederive edit-cache)))))))

;; Note that this purge is necessary because
;; add-to-structures-affected-by-edit-cache changes
;; edit-cache-frame-serial-number.  However, the purge does not guarantee that
;; there will never be deleted frames in the cache.
;; Update-runtime-structures-according-to-edit filters this cache for frames that
;; have been deleted, thus ensuring that no action is taken for deleted frames.
;; An alternative to doing the purge from add-to-structures-affected-by-edit-cache
;; whenever something is added is to have cleanup methods for variables remove a
;; variable from the edit caches whenever a variable is deleted.  This would
;; require pointers from variables to corresponding edit caches.



;;; Sort-dependent-variable-info performs an in-place sort of the variables in the
;;; simulation set (model-dependent-variable-info current-model-runtime-info?).
;;; Variables that can be sorted are arranged in order at the beginning of this
;;; set such that when the simulation value of any structure has to be computed,
;;; the values of all other structures required in this computation have already
;;; been computed.  This eliminates any recursion in sim-eval for sorted
;;; variables.  Dependent variables that can't be sorted (due to loops) are put at
;;; the end of this list.  The boundary is marked by
;;; (model-sort-boundary-for-dependent-variable-info current-model-runtime-info?)
;;; which points to the cons for the last sorted structure.  If nothing can be
;;; sorted, this will be nil.

;;; Sort-dependent-variable-info clears the sort flag for each variable, and then
;;; calls sort-dependent-variable until there are no more variables to sort.
;;; Sort-dependent-variable adds variables before or after the sort boundary as
;;; appropriate.

(defun sort-dependent-variable-info ()
  (for-each-element-in-installation-set
    (model-dependent-variable-info current-model-runtime-info?)
    'reset-sort-flag)
  (setf (model-sort-boundary-for-dependent-variable-info
	  current-model-runtime-info?) nil)
  (sort-dependent-variable-info-1))

(defun reset-sort-flag (variable)
  (let ((runtime-structure (simulation-runtime-information? variable)))
    (when runtime-structure
      (setf (sort-flag runtime-structure) nil))))



(defvar next-element-to-be-sorted?)

(defun sort-dependent-variable-info-1 ()
  (loop with next-element-to-be-sorted?
	= (installation-set-next? 
	    (model-dependent-variable-info current-model-runtime-info?))
	while next-element-to-be-sorted?
	as runtime-info? = (runtime-info? next-element-to-be-sorted?)
	do
      (sort-dependent-variable runtime-info?)))



;;; Sort-dependent-variable adds variables before or after the sort boundary as
;;; appropriate and sets the sort flag of the variable to 'sorted or 'unsorted.
;;; The sort flag is initially nil but can be temporarily set to 'being-sorted
;;; when sort-dependent-variable is called recursively for a supporting runtime
;;; structure.  If the sort flag of a supporting structure is 'being-sorted, a
;;; loop has been encountered and the argument runtime structure can't be sorted.
;;; Sort-dependent-variable does not return a meaningful value.

;;; Dependent variables must ultimately depend on state variables or constant
;;; expressions if they are to be sorted.  Note that dependent variables with
;;; constant expressions and state variables have no support structures.  Thus, a
;;; variable with no support structures can always be sorted.

(defun sort-dependent-variable (runtime-structure)
  (let ((add-to-sorted-list? nil))
    (setq add-to-sorted-list?
	  (loop for supporting-variable
		    in (supporting-structures runtime-structure)
		as supporting-structure
		   = (simulation-runtime-information? supporting-variable)
		do
	    (when (dependent-variable-p supporting-variable)
	      (when (null (sort-flag supporting-structure))
		;; If supporting-structure has not been sorted yet, call 
		;; sort-dependent-variable recursively.  This will ensure that 
		;; the sort flag is set to some non-nil value.
		(setf (sort-flag runtime-structure) 'being-sorted)
		(sort-dependent-variable supporting-structure))
	      (when (or (eq (sort-flag supporting-structure) 'unsorted)
			(eq (sort-flag supporting-structure) 'being-sorted))
		;; If supporting-structure can't be sorted, then
		;; variable can't be sorted.
		;; If sort flag is 'being-sorted, then loop has been encountered
		;; and variable can't be sorted.
		(return nil)))
		finally 
		  ;; If all supporting structures are sorted, variable can be sorted.
		  (return t)))
    (cond
      (add-to-sorted-list?
       (setf (sort-flag runtime-structure) 'sorted)
       (add-variable-to-sorted-or-unsorted-portion-of-set runtime-structure t))
      (t
       (when (not (eq (sort-flag runtime-structure) 'unsorted))
	 ;; This check is needed because sort-dependent-variable can be called
	 ;; recursively.  If this check were omitted, the 
	 ;; runtime-structure could be put in the unsorted
	 ;; portion which could cause serious problems since this goes into the
	 ;; model-dependent-variable-info slot of current-model-runtime-info?.
	 (setf (sort-flag runtime-structure) 'unsorted)
	 (add-variable-to-sorted-or-unsorted-portion-of-set 
	   runtime-structure nil))))))


(defun add-variable-to-sorted-or-unsorted-portion-of-set 
       (runtime-structure sorted?)
  (let* ((variable (corresponding-variable runtime-structure))
	 (simulation-info (simulation-info? variable))
	 (sort-boundary?
	   (model-sort-boundary-for-dependent-variable-info
	     current-model-runtime-info?)))
    (when (eq simulation-info next-element-to-be-sorted?)
      (setq next-element-to-be-sorted?
	    (installation-set-next? next-element-to-be-sorted?)))
    (if sort-boundary?
	(insert-in-installation-set sort-boundary? variable)
	(add-to-installation-set
	  (model-dependent-variable-info current-model-runtime-info?)
	  variable))				       ; puts variable at beginning of set
    (when sorted?
      (setf (model-sort-boundary-for-dependent-variable-info
	      current-model-runtime-info?)
	    simulation-info))))



;;; Store-new-simulation-value sets the new-simulation-value slot to new-value
;;; and also sets the new-value-computed-for-current-simulation-cycle? flag.
;;; All functions which set the new-simulation-value (the calculate-new-values...
;;; functions and the sim-eval-calculate-new-value... functions) use this facility.
;;; The initialization function compute-initial-values-for-all-state-variables
;;; also uses it.

(defmacro store-simulated-value-if-compatible
	  (variable place-for-value value)
  (let ((value-of-variable (gensym))
	(value-of-value (gensym)))
    `(let* ((,value-of-variable ,variable)
	    (,value-of-value ,value)
	    (type-specification
	      (type-specification-of-variable-or-parameter-value 
		,value-of-variable)))
       (cond
	 ((and (eq type-specification 'float) (fixnump ,value-of-value))
	  ;; If we need a float and have an integer, coerce it here.
	  (store-managed-number-or-value
	    ,place-for-value 
	    (coerce-to-gensym-float (the fixnum ,value-of-value))))
	 ((type-and-datum-compatible-p 
	    type-specification ,value-of-value)
	  (store-managed-number-or-value
	    ,place-for-value ,value-of-value))
	 (t
	  (simulation-type-error-from-within-or-without-stack-eval
	    ,value-of-variable ,value-of-value))))))

(defmacro store-simulated-evaluation-value-if-compatible
	  (variable place-for-value evaluation-value)
  (let ((value-of-variable (gensym))
	(value-of-evaluation-value (gensym)))
    `(let* ((,value-of-variable ,variable)
	    (,value-of-evaluation-value ,evaluation-value)
	    (type-specification
	      (type-specification-of-variable-or-parameter-value 
		,value-of-variable)))
       (cond
	 ((and (eq type-specification 'float) 
	       (evaluation-integer-p ,value-of-evaluation-value))
	  ;; If we need a float and have an integer, coerce it here.
	  (store-managed-number-or-value
	    ,place-for-value 
	    (coerce-to-gensym-float 
	      (evaluation-integer-value ,value-of-evaluation-value))))
	 ((type-specification-type-p
	    ,value-of-evaluation-value type-specification)
	  (reclaim-managed-number-or-value ,place-for-value)
	  (setf ,place-for-value
		(copy-managed-number-or-value ,value-of-evaluation-value)))
	 (t
	  (simulation-type-error-from-within-or-without-stack-eval
	    ,value-of-variable (evaluation-value-value ,value-of-evaluation-value)))))))

(defmacro store-new-simulation-value 
	  (variable-simulation-runtime-structure new-value)
  (let ((value-of-structure (gensym)))
    `(let* ((,value-of-structure ,variable-simulation-runtime-structure))
       (store-simulated-value-if-compatible
	 (corresponding-variable ,value-of-structure)
	 (new-simulation-value ,value-of-structure) ,new-value)
       (setf (new-value-computed-for-current-simulation-cycle?
	       ,value-of-structure) t))))

(defmacro store-new-simulation-evaluation-value 
	  (variable-simulation-runtime-structure new-evaluation-value)
  (let ((value-of-structure (gensym)))
    `(let* ((,value-of-structure ,variable-simulation-runtime-structure))
       (store-simulated-evaluation-value-if-compatible
	 (corresponding-variable ,value-of-structure)
	 (new-simulation-value ,value-of-structure) ,new-evaluation-value)
       (setf (new-value-computed-for-current-simulation-cycle?
	       ,value-of-structure) t))))



(defun compute-initial-values-for-all-state-variables ()
  (let ((initializing-state-variables? t))
    (for-each-element-in-installation-set
      (model-continuous-state-variable-info current-model-runtime-info?)
      'compute-and-initialize-state-variable)
    (for-each-element-in-installation-set
      (model-discrete-state-variable-info current-model-runtime-info?)
      'compute-and-initialize-state-variable)))

(defun compute-and-initialize-state-variable (state-variable)
  (let ((runtime-structure? (simulation-runtime-information? state-variable)))
    (when runtime-structure?
      (setf (update-variable-this-cycle? runtime-structure?) t)
      (with-temporary-gensym-float-creation compute-and-initialize
	(compute-initial-value-for-state-variable 
	  state-variable runtime-structure?)))))



;;; Compute-initial-value-for-state-variable computes and sets the value which
;;; is computed in the following way.  If the non-default-initial-value? slot
;;; of the variable is non-nil (a number), then it is used.  If it is
;;; nil, the initial-simulated-value? slot of the variable is used.  This slot is
;;; set by the slot putters for specific and generic simulation formulas.
;;; If this slot is 'use-initial-value-expression-in-generic-simulation-formula,
;;; then the initial value expression in the generic simulation formula is 
;;; evaluated and the result is the returned.  This is the case when the 
;;; variable has no specific simulation formula and the initial value specified
;;; in the generic simulation formula is an expression, not just a number.
;;; If the initial-simulated-value? slot is not
;;; 'use-initial-value-expression-in-generic-simulation-formula, 
;;; then the expression in the slot itself is evaluated and the result 
;;; returned.  

;;; Note that the initial value expression is evaluated as an algebraic
;;; expression.  Note also that for generic simulation formulas, references
;;; can be made in the initial value expression to the attribute or class
;;; on the left side of the formula but not to anything on the right side
;;; of the formula.  Thus, it is legal to say
;;; "d/dt the output-pressure of any tank = the input-pressure of the tank
;;;   - the pressure-drop of the valve of the tank, with initial value
;;;  the initial-pressure of the tank"
;;; but it is not legal to say
;;; "d/dt the output-pressure of any tank = the input-pressure of the tank
;;;   - the pressure-drop of the valve of the tank, with initial value
;;;  the initial-pressure of the valve".
;;; The compiler will flag an illegal reference if this is done.
;;; The problem is that the simulation expression and the initial value 
;;; expression are two separate expressions evaluated separately at runtime.
;;; Thus, bindings from one can not be used in the other.  It would be 
;;; like having an expression in a rule refer to a name in another 
;;; separate rule.

;;; If initial-value-expression-from-formulas is (current-parameter-value),
;;; then if the variable-or-parameter argument is a parameter, the value
;;; returned will be the current value of the parameter if it is active
;;; or the initial value of the parameter if it is not.  If 
;;; variable-or-parameter is not a parameter, simulation-no-value is 
;;; returned and a warning is posted.

;; It is actually possible to lift the above restriction but it is a project 
;; and, perhaps, shouldn't be done unless there is a more compelling reason to
;; do it.  So far, there is no other case where an expression refers to 
;; another expression that is not being evaluated.  In the case of initial
;; value expressions, it is always possible to get around this by referring
;; to the attribute of class name on the left side of the formula. 
;; In any case, the way to lift this restriction
;; would be to combine the references from the second expression with those
;; of the first, then subtract out the references for designations from the
;; first expression.  The references from the second expression could then be
;; subtracted out leaving a small reference tree that provides all references
;; needed for the second expression.  Finally, the usual first pass compile
;; could be performed for the second expression using the providing reference
;; tree as a starting point.

(defun compute-initial-value-for-state-variable 
       (variable-or-parameter runtime-structure)
  (when (need-to-stack-eval-to-get-initial-value-for-state-variable? 
	  variable-or-parameter runtime-structure)
    (sim-eval-for-stack-until-value-found variable-or-parameter)))

(defun need-to-stack-eval-to-get-initial-value-for-state-variable? 
       (variable-or-parameter runtime-structure)
  (let* ((non-default-initial-value?
	   (when (variable-p variable-or-parameter)
	     (slot-value-number-value
	       (non-default-initial-simulated-value? variable-or-parameter))))
	 (initial-value-expression-from-formulas
	   (initial-simulated-value? variable-or-parameter))
	 )
    (cond
      (non-default-initial-value?
       ;; Consider allowing expressions here as well as numbers.
       (store-new-simulation-value 
	 runtime-structure non-default-initial-value?)
       nil)
      ((eq initial-value-expression-from-formulas
	   'use-initial-value-expression-in-generic-simulation-formula)
       (let* ((generic-simulation-formula
		(get-simulation-specifier-to-use variable-or-parameter))
	      (initial-value-expression
		(simulation-formula-initial-value? generic-simulation-formula)))
	 (if (generic-simulation-formula-p generic-simulation-formula)
	     (cond
	       ((and (consp initial-value-expression)
		     (if (eq (car initial-value-expression) 'let)
			 (if (consp (third initial-value-expression))
			     (eq (car (third initial-value-expression))
				 'current-parameter-value))
			 (eq (car initial-value-expression)
			     'current-parameter-value)))
		;; Get value from parameter.
		(store-new-simulation-value 
		  runtime-structure
		  (cond 
		    ((parameter-p variable-or-parameter)
		     (get-value-of-parameter-for-simulator 
		       variable-or-parameter))
		    (t
		     ;; post warning
		     (post-simulation-warning-for-not-parameter
		       variable-or-parameter)
		     simulation-no-value)))
		nil)
	       (t
		(get-formula-focal-entity-for-variable 
		  variable-or-parameter)))

	     #+development
	     (cerror "" "specifier not generic simulation formula"))))
      (t t))))





;;;; Edit Handling


(defun check-for-simulation-changes ()
  (when (simulation-changes-p)
    (clear-simulation-resumption-stack)
    (when (simulation-procedure-invocation-for-model?
	    current-model-runtime-info?)
      (abort-procedure-invocation 
	(simulation-procedure-invocation-for-model?
	  current-model-runtime-info?))
      (setf (simulation-procedure-invocation-for-model?
	      current-model-runtime-info?) nil))
    (when (and (simulating-externally-p)
	       (not (or (eq (status-of-work-on-external-simulation
			      current-model-runtime-info?)
			    'work-completed-for-this-cycle)
			(eq (status-of-work-on-external-simulation
			      current-model-runtime-info?)
			    'no-work-done-yet-for-this-cycle))))
      (setf (waiting-for-external-simulator? current-model-runtime-info?) t))
    (handle-editing-changes-effecting-simulation)
    (setf (simulated-variable-removed? current-model-runtime-info?) nil)
    (re-initialize-variables-for-one-simulation-cycle)))



(defun simulating-externally-p ()
  (external-simulator-interface-icp-socket
    current-model-runtime-info?))



(defun simulation-changes-p ()
  (or (simulated-variable-removed? current-model-runtime-info?)
      (not (rederive-set-empty?
	     (variables-whose-runtime-structures-must-be-rederived 
	       current-model-runtime-info?)))))



;;; Re-initialize-variables-for-one-simulation-cycle performs all resets necessary
;;; to repeat a simulation step that has been interrupted except for clearing the
;;; simulation resumption stack.  It actually does not have to do very much
;;; because clearing the simulation resumption stack implicitly resets almost
;;; everything.  This is due to the fact that when the resumption stack is clear,
;;; resumeable functions such as simulate-one-cycle are called with the
;;; resumption?  arg set to nil.  This causes these functions to initialize global
;;; flags and compute values for slots like
;;; update-variable-this-cycle.

;;; It turns out that the only thing that
;;; re-initialize-variables-for-one-simulation-cycle has to do is set the
;;; new-value-computed-for-current-simulation-cycle slot of each
;;; variable-simulation-runtime-structure in the simulation to nil.

(defun re-initialize-variables-for-one-simulation-cycle ()
  (for-each-variable-in-model
    'reset-new-value-computed-slot))

(defun reset-new-value-computed-slot (variable-or-parameter)
  (let ((runtime-structure? 
	  (simulation-runtime-information? variable-or-parameter)))
    (when runtime-structure?
      (setf (new-value-computed-for-current-simulation-cycle?
	      runtime-structure?) nil))))



;;; Clear-simulation-resumption-stack reclaims simulation-resumption-stack and
;;; leaves it set to nil.  Simulation-resumption-stack is a list of the form

;;; (suspendable-function objects other-args ...).

;;; The list is made up of conses allocated from recycled-resumption-conses.
;;; Therefore, the list is reclaimed by putting these conses back on
;;; recycled-resumption-conses.  Objects is not reclaimed since this is not a copy
;;; of but rather a pointer to a list in the simulator (in
;;; current-model-runtime-info?).  Other-args is not used in the simulator and
;;; will always be nil in simulation-resumption-stack.

(defun clear-simulation-resumption-stack ()
  (when (simulation-resumption-stack current-model-runtime-info?)
    (loop with cdddr-of-resumption-stack 
	    = (cdddr (simulation-resumption-stack current-model-runtime-info?))
	  do
      (setf (first (simulation-resumption-stack current-model-runtime-info?)) nil
	    (second (simulation-resumption-stack current-model-runtime-info?)) nil
	    (third (simulation-resumption-stack current-model-runtime-info?)) nil)
      ;; This shouldn't actually be necessary.
      
      (setf (cdddr (simulation-resumption-stack current-model-runtime-info?)) recycled-resumption-conses
	    recycled-resumption-conses (simulation-resumption-stack current-model-runtime-info?)
	    (simulation-resumption-stack current-model-runtime-info?) cdddr-of-resumption-stack)
      ;; Reclamation here is a bit simpler than in work-on-suspendable-task
      ;; since other-args is not used in simulation-resumption-stack.
      
	  while (simulation-resumption-stack current-model-runtime-info?)
	  do
      (setq cdddr-of-resumption-stack
	    (cdddr (simulation-resumption-stack current-model-runtime-info?))))))

;; Note that clear-simulation-resumption-stack should not be used as a general clear
;; function for suspendable tasks due to the above mentioned simulator-specific
;; assumptions.  Consider making a general version if suspendable tasks are used
;; by something other than the simulator.  If this is done, also review use of
;; recycled-resumption-conses rather than using general defconser mechanism!
;; Also, the reclamation of other-args when reclaiming a resumption stack entry in
;; work-on-suspendable-task is questionable unless other-args always consists of
;; conses allocated from recycled-resumption-conses.



(defun handle-editing-changes-effecting-simulation ()

  (for-each-element-in-rederive-set
    (variables-whose-runtime-structures-must-be-rederived 
      current-model-runtime-info?)
    'handle-newly-simulated-variable-if-necessary)

  (for-each-element-in-rederive-set
    (variables-whose-runtime-structures-must-be-rederived 
      current-model-runtime-info?)
    'generate-new-runtime-simulation-formula)
  
  ;; Since dependent variables may have been added, removed, or had their
  ;; runtime formulas rederived, it is necessary to sort the 
  ;; dependent variable info list. 
  ;; Note that sort-dependent-variable-info is only invoked if there are
  ;; dependent variables in current-model-runtime-info?.
  ;; Note that supporting structures are computed after 
  ;; model-dependent-variable-info list is completely computed.

  (when (and
	  (not (installation-set-empty?
		 (model-dependent-variable-info current-model-runtime-info?)))
	  (not (installation-set-empty?
		 (variables-whose-runtime-structures-must-be-rederived 
		   current-model-runtime-info?))))
    (sort-dependent-variable-info))
  
  ;; Reclaim lists and set special variables to nil.
  (clear-edit-handling-lists)
  )

(defun handle-newly-simulated-variable-if-necessary (variable)
  (when (null (simulation-runtime-information? variable))
    (make-and-initialize-variable-simulation-runtime-structure variable)
    (add-variable-simulation-runtime-structure-to-runtime-info variable)
    (begin-collecting-data-for-simulated-variable-if-appropriate variable)))



;;; Reclaim-variable-simulation-runtime-structure is always used
;;; for reclaiming a variable-simulation-runtime-structure.  It reclaims the
;;; structure and sets the variable's slot to nil.

(defun reclaim-variable-simulation-runtime-structure
       (variable-simulation-runtime-structure)
  (let ((variable (corresponding-variable variable-simulation-runtime-structure)))
    (when variable  ; should always be the case
      (set-simulation-runtime-information? variable nil))
    (reclaim-interval-at-which-to-send-value-to-inference-engine
      (interval-at-which-to-send-value-to-inference-engine
		variable-simulation-runtime-structure))
    (setf (interval-at-which-to-send-value-to-inference-engine
		variable-simulation-runtime-structure) nil)
    (reclaim-variable-simulation-runtime-structure-internal
      variable-simulation-runtime-structure)))

;; Note that the interval-at-which-to-send-value-to-inference-engine slot of a
;; variable-simulation-runtime-structure is reclaimed by 
;; stop-collecting-data-for-simulator which is always invoked upon reset.



;;; Add-variable-simulation-runtime-structure-to-runtime-info does many of the
;;; same things that initialize-simulator does, only for one variable.
;;; Note that if the new variable is a state variable, update for it is
;;; suppressed for one cycle since it already has an initial value.
;;; This is necessary because the new value of the state variable may be
;;; a function of dependent variables which are also new.  If these
;;; dependent variables are not computed first, no value will be computed
;;; for the state variable.

(defun add-variable-simulation-runtime-structure-to-runtime-info (variable)
  (initialize-runtime-simulation-information-for-variable variable)
  (when (state-variable-p variable)
    (with-temporary-gensym-float-creation add-variable
      (let ((initializing-state-variables? t)
	    (variable-simulation-runtime-structure
	      (simulation-runtime-information? variable)))
	(setf (variable-needs-initialization? 
		variable-simulation-runtime-structure)
	      t)
	(compute-initial-value-for-state-variable
	  variable variable-simulation-runtime-structure)
	(setf (variable-needs-initialization? 
		variable-simulation-runtime-structure)
	      nil)
	(store-simulated-value-if-compatible
	  variable
	  (simulation-value variable-simulation-runtime-structure) 
	  (extract-number-or-value
	    (new-simulation-value variable-simulation-runtime-structure)))
	(setf (update-variable-this-cycle? variable-simulation-runtime-structure)
	      'suppress-first-update)))))



;;; Generate-new-runtime-simulation-formula derives a new runtime simulation
;;; formula for the variable.  It does not change simulation values in the
;;; variable-simulation-runtime-structure, and it does not move this structure
;;; in the runtime info lists.

(defun generate-new-runtime-simulation-formula (variable)
  (generate-and-set-runtime-formula
    variable (simulation-runtime-information? variable)))





;;;; Shutdown

;;; Shutdown-simulator clears and reclaims data structures used
;;; when running the simulator so that they are empty when the simulator 
;;; is not running.  This function is always called before a new knowledge base
;;; is loaded, regardless of whether or not the simulator is running, even if
;;; the simulator is paused in the middle of a cycle.  Thus, as long as all
;;; necessary reclaiming is done here, no memory leakage will occur when a new
;;; knowledge base is loaded.

;;; One group of such data structures is the kb specific variables for incremental
;;; editing: variables-whose-runtime-structures-must-be-rederived.  G2 variables
;;; are added to these lists (using add-to-set) only when the simulator is
;;; running.  This is done update-runtime-structures-according-to-edit for
;;; variables-whose-runtime-structures-must-be-rederived.  The lists are
;;; completely reclaimed by handle-editing-changes-effecting-simulation.  If no
;;; edits are made between the last time
;;; handle-editing-changes-effecting-simulation is called and shutdown-simulator
;;; is called, then the caches are empty and there is no need to reclaim anything.
;;; If such edits are made however, (if for example, the simulator is paused in
;;; the middle of a simulation cycle, some things are edited, and then, the system
;;; is reset) then the caches will not be empty.  Therefore, shutdown-simulator
;;; must do reclaiming for this case (by calling clear-edit-handling-lists).  The
;;; kb specific variables also have reclaimers (see definitions) so that they are
;;; automatically reclaimed when a new kb is loaded.

;;; Another group of data structures to reclaim is the runtime structures caches
;;; in the runtime-structures-affected-by-this-entity,
;;; runtime-structures-affected-by-this-statement, and
;;; runtime-structures-affected-by-this-connection slots (see also
;;; update-runtime-structures-according-to-edit).  These slots are set via
;;; initialize-simulator and handle-editing-changes-effecting-simulation.  Thus,
;;; these slots are only set while the simulator is running.  They are cleared by
;;; update-runtime-structures-according-to-edit (and are typically set again by
;;; handle-editing-changes-effecting-simulation), also only when the simulator is
;;; running.  Therefore, these slots must be reclaimed by shutdown-simulator.

;;; The info lists in current-model-runtime-info? are reclaimed, after which the
;;; current-model-runtime-info? structure itself is reclaimed.

;;; Finally, the lists of variable-group-update-structures in
;;; current-model-runtime-info?  are reclaimed.

(defun shutdown-simulator (&optional model-runtime-info? model-definition?)
  (cond 
    ((not model-runtime-info?)  
     ;; if main model is being shutdown, shutdown all the other models as well.
     (let ((synchronous-models
	     (copy-list-using-gensym-conses 
	       (models-in-queue synchronous-model-queue)))
	   (as-fast-as-possible-models
	     (copy-list-using-gensym-conses 
	       (models-in-queue as-fast-as-possible-model-queue))))
       (shutdown-models-in-list synchronous-models)
       (shutdown-models-in-list as-fast-as-possible-models)
       (reclaim-gensym-list synchronous-models)
       (reclaim-gensym-list as-fast-as-possible-models)))
    (t
     (with-current-model-and-queue
       model-runtime-info? model-definition?
       (shutdown-simulator-1)))))

(defun shutdown-models-in-list (model-list)
  (loop for model-runtime-info in model-list do
    (with-current-model-and-queue
      model-runtime-info (model-definition-for-model? model-runtime-info)
      (when current-model-definition?
	(change-slot-value
	  current-model-definition? 'model-simulation-status 'not-running))
      (shutdown-simulator-1))))

(defun shutdown-simulator-1 ()
  (remove-model-from-simulation current-model-runtime-info?)
  (when (not (eq (model-runtime-status current-model-runtime-info?) 
		 'needs-to-be-initialized))
    (clear-variables-that-need-simulated-values)
    (update-shortest-simulation-time-increment-for-all-models)
    (clear-edit-handling-lists)
    (clear-runtime-structures-caches)
    (reclaim-simulation-update-table)
    (setf (simulation-procedure-finished? current-model-runtime-info?) t)
    (let ((simulation-procedure-invocation-for-model?
	    (simulation-procedure-invocation-for-model?
	      current-model-runtime-info?)))
      (when simulation-procedure-invocation-for-model?
	(cond
	  ((and evaluating-simulator-procedure?
		(eq evaluating-simulator-procedure? current-model-definition?))
	   ;; If simulation-procedure for model is shutting down the
	   ;; model itself, cut the procedure loose without aborting it.
	   (restart-simulator-after-procedure-1 current-model-definition?)
	   (setf (simulation-procedure-invocation?
		   simulation-procedure-invocation-for-model?) nil
		 (procedure-invocation-completion-form?
		   simulation-procedure-invocation-for-model?) nil))
	  (t
	   (abort-procedure-invocation simulation-procedure-invocation-for-model?)))
	(setf (simulation-procedure-invocation-for-model?
		current-model-runtime-info?) nil)))
    (setf (waiting-for-external-simulator? current-model-runtime-info?) nil)
    (shutdown-externally-simulated-portion-of-model))
  (when (or system-is-running system-has-paused)
    (with-current-scheduling
	(nil (priority-of-data-service data-server-parameters))
      (continue-data-server-data-acceptance
	(data-server 'simulator-data-server)
	(clock-get current-g2-time)))))

;; The call to schedule-current-task is necessary so that
;; simulate-until-consistent-with-gensym-time will happen again.  If
;; this isn't done, the simulator could become stuck since the model
;; removed may have been the one waiting for a simulation procedure or
;; externally simulated data.  These will never complete now, so the
;; simulator must be restarted some other way, since there may be other
;; models that want to execute.



;; There is currently a problem with aborting a procedure from within the
;; procedure itself (see doc for abort-procedure-invocation).  This will change
;; when the abort action is implemented.  For now, if the shutdown of a model is
;; done (via g2-reset-model) from the simulation procedure for the model itself,
;; the simulation procedure is not aborted, but rather, is cut loose.  There is,
;; thus, a chance that such simulation procedures could not end and pile up in the
;; scheduler if a user has the procedure do something which is suspendable after
;; the call to g2-reset-model.  This is extremely unlikely however, and would be
;; bad practice in any case.  While a task could be scheduled to abort the
;; procedure, it is probably best to just wait until Jim fixes the problem with
;; abort-procedure-invocation.  Be sure to use the
;; suppress-error-signal-to-callers?  arg in this case.

;; The 'needs-to-be-initialized check ensures that a model is not shutdown if it
;; has not been initialized.

;; Setting simulation-procedure-finished?  shouldn't actually be necessary here
;; since restart-simulator-after-procedure should take care of this (procedure
;; completion forms are called by abort-procedure-invocation).



(defun reclaim-simulation-update-table ()
  (loop for variable-group-update-structure
	    in (model-variable-group-update-info current-model-runtime-info?)
	do (reclaim-variable-group-update-structure-completely
	     variable-group-update-structure))
  (reclaim-eval-list
    (model-variable-group-update-info current-model-runtime-info?))
  (setf (model-variable-group-update-info current-model-runtime-info?) nil))



(defun clear-edit-handling-lists ()
  (clear-rederive-set
    (variables-whose-runtime-structures-must-be-rederived 
      current-model-runtime-info?)))



(defmacro reclaim-edit-cache-as-appropriate 
	  (edit-cache? slot-for-edit-cache parent-for-edit-cache)
  `(when ,edit-cache?
     (cond
       ((null (variables-to-reinstall ,edit-cache?))
	(setf (,slot-for-edit-cache ,parent-for-edit-cache) nil)
	(reclaim-edit-cache ,edit-cache?))
       (t
	(reclaim-eval-list (variables-to-rederive ,edit-cache?))
	(setf (variables-to-rederive ,edit-cache?) nil)))))

;; Edit-cache is assumed to always be a symbol here.



(defun clear-runtime-structures-caches ()
  (loop for entity-involved-in-simulation? being each class-instance of 'entity
	do
    (let ((edit-cache?
	    (runtime-structures-affected-by-this-entity
	      entity-involved-in-simulation?)))
      (reclaim-edit-cache-as-appropriate
	edit-cache? runtime-structures-affected-by-this-entity
	entity-involved-in-simulation?))
    (loop for connection-involved-in-simulation? being each output-connection 
	      of entity-involved-in-simulation?
	  do
      (let ((edit-cache?
	      (runtime-structures-affected-by-this-connection
		connection-involved-in-simulation?)))
	(reclaim-edit-cache-as-appropriate
	  edit-cache? runtime-structures-affected-by-this-connection
	  connection-involved-in-simulation?))))
  (loop for statement-involved-in-simulation? being each class-instance of 'statement
	do
    (let ((edit-cache?
	    (runtime-structures-affected-by-this-statement
	      statement-involved-in-simulation?)))
      (reclaim-edit-cache-as-appropriate
	edit-cache? runtime-structures-affected-by-this-statement
	statement-involved-in-simulation?))))

;; Brute force approach.  An alternative would be to collect only entities
;; that have variables being simulated.  





;;;; Stack Evaluator Functions for Simulator



;;; Sim-eval-for-stack is used for evaluation of simulation formulas.  It
;;; calls execute-simulation-formula-in-stack, which calls stack-eval.

;;; If the dependent variables in a model aren't all sorted, it is possible for
;;; sim-eval-get-value-of-variable (when called from stack-eval via
;;; sim-eval-variable-or-constant) to encounter a variable which does not yet have
;;; a simulated value for the current time step.  This is handled by
;;; sim-eval-calculate-new-value-for-variable which calls
;;; handle-encountered-unknown-value-in-simulator.
;;; Handle-encountered-unknown-value-in-simulator marks the variable as needing a
;;; value, and does a throw out of the stack evaluator.  The marking is done by
;;; mark-as-variable-that-needs-value, which adds the variable to the
;;; variables-that-need-simulated-values slot of current-model-runtime-info?.
;;; This slot is essentially a stack which holds all the variables that need
;;; values in order to determine the value for the one at the bottom of the stack.
;;; This stack is needed because (unlike the old evaluators) stack-eval is not
;;; recursive and cannot user the lisp stack.
;;; Calculate-new-value-for-one-dependent-variable always works on variables on
;;; this stack first before proceeding on to new dependent variables.

;;; If the dependent variables in a model aren't all sorted, it is also possible
;;; that loops may be encountered.  This happens when the variable arg to
;;; sim-eval-get-value-of-variable is already on the
;;; variables-that-need-simulated-values stack.  In this case,
;;; sim-eval-get-value-of-variable returns simulation-no-value.  Usually, this is
;;; the end of the story.  However, for certain types of problems, the loop may be
;;; encountered within the context of a "first of the following that has a value"
;;; form or a "has a value" predicate.  In such cases, a simulation formula can
;;; try alternative ways of getting a value.  However, the evaluation has been
;;; "tainted" by the fact that a loop has been encountered.  This means that even
;;; though the variable at the bottom of the stack may eventually get a value, it
;;; is wrong to assign values to all the other variables in the stack since their
;;; evaluation was not started from top level but was done to get a value for the
;;; variable at the bottom of the stack.  This concept is based on the idea of
;;; well founded supports (see also David McAllester's RUP truth maintenance
;;; system).  The fact that an evaluation has been tainted by a loop is noted in
;;; the value-tainted-by-ordering-loop?  slot of current-model-runtime-info? by
;;; simulation-loop-encountered?.  This slot is cleared by 
;;; clear-variables-that-need-simulated-values, and by

;; See also the test kb "ma:>agh>simulation-ordering-loops" for further discussion
;; and examples of loop issues.



(def-substitution-macro mark-as-variable-that-needs-value 
			(variable-or-parameter)
  (let ((simulation-runtime-information?
	  (simulation-runtime-information? variable-or-parameter)))
    (when (not (variable-needs-simulated-value? 
		 simulation-runtime-information?))
      (simulate-push 
	variable-or-parameter 
	(variables-that-need-simulated-values current-model-runtime-info?))
      (setf (variable-needs-simulated-value? 
	      (simulation-runtime-information? variable-or-parameter)) t))))

(defmacro pop-next-variable-that-needs-value ()
  `(let* ((variable (car (variables-that-need-simulated-values 
			  current-model-runtime-info?)))
	 (temp-list
	   (variables-that-need-simulated-values current-model-runtime-info?))
	 (runtime-info? (simulation-runtime-information? variable)))	
     (setf (variables-that-need-simulated-values current-model-runtime-info?)
	   (cdr (variables-that-need-simulated-values 
		  current-model-runtime-info?)))
     (when temp-list (reclaim-simulate-cons temp-list))
     (when runtime-info?
       (setf (variable-needs-simulated-value? runtime-info?) nil))
     variable))

;; Not using simulate-pop here since this binds a special variable.



(def-substitution-macro mark-as-tainted-variable (variable-or-parameter)
  (simulate-push 
    variable-or-parameter (tainted-variables current-model-runtime-info?))
  (setf (value-of-variable-tainted? 
	  (simulation-runtime-information? variable-or-parameter)) t))

(def-substitution-macro invalidate-value-computed-for-current-cycle-or-step?
			(variable-or-parameter)
  (let* ((runtime-structure (simulation-runtime-information? variable-or-parameter))
	 (value-computed? 
	   (new-value-computed-for-current-simulation-cycle? runtime-structure)))
    (setf (new-value-computed-for-current-simulation-cycle? runtime-structure)
	  (if (numberp value-computed?) 
	      (-f value-computed? 1)
	      nil))))

(defun clear-tainted-variables (&optional invalidate-values?)
  (setf (value-tainted-by-ordering-loop? current-model-runtime-info?) nil)
  (clear-tainted-variables-1
    (tainted-variables current-model-runtime-info?) invalidate-values?))

(defun clear-tainted-variables-1 (tainted-variables &optional invalidate-values?)
  (loop for variable in tainted-variables do
    (setf (value-of-variable-tainted? 
	    (simulation-runtime-information? variable)) nil)
    (when invalidate-values?
      (invalidate-value-computed-for-current-cycle-or-step? variable)))
  (setf (tainted-variables current-model-runtime-info?) nil)
  (reclaim-simulate-list tainted-variables))

(defun clear-variables-that-need-simulated-values ()
  (clear-tainted-variables)
  (clear-variables-that-need-simulated-values-1
    (variables-that-need-simulated-values current-model-runtime-info?)))

(defun clear-variables-that-need-simulated-values-1 
       (variables-that-need-simulated-values)
  (loop for variable in variables-that-need-simulated-values
	as variable-simulation-runtime-structure?
	   = (simulation-runtime-information? variable)
	do 
    (when variable-simulation-runtime-structure?
      (setf (variable-needs-simulated-value? 
	      variable-simulation-runtime-structure?) nil)))
  (setf (variables-that-need-simulated-values current-model-runtime-info?) nil)
  (reclaim-simulate-list variables-that-need-simulated-values))



(defmacro handle-encountered-unknown-value-in-simulator (variable)
  `(cond
     ((eq current-environment 'simulator)
      (mark-as-variable-that-needs-value current-computation-instance)
      (mark-as-variable-that-needs-value ,variable)
      (setq stack-expiration nil)
      (setf (simulation-error? current-model-runtime-info?) 
	    'unknown-encountered)
      (stack-error cached-top-of-stack ""))
     (t
      (setq stack-expiration nil))))

;; no recursion in stack evaluator




;;; The substitution macro `simulation-byte-code-body-and-environment' takes a
;;; computation-instance and returns two values, the byte code body to execute
;;; and the environment vector for that byte code body.  Note that this macro
;;; also uses the global variables initializing-state-variables?  and
;;; current-simulation-runtime-structure, which are only available within
;;; simulation contexts.

(def-substitution-macro simulation-byte-code-body-and-environment
			(computation-instance)
  (cond
     ((and (state-variable-p computation-instance)
	   initializing-state-variables?)
      (if (need-to-stack-eval-to-get-initial-value-for-state-variable?
	    computation-instance current-simulation-runtime-structure)
	  (values
	    (cond
	      ((generic-simulation-formula-p *current-computation-frame*)
	       (generic-simulation-initial-value-byte-code-body
		 *current-computation-frame*))
	      ((simulation-subtable-p *current-computation-frame*)
	       (simulation-subtable-initial-value-byte-code-body
		 *current-computation-frame*)))
	    (initial-value-simulation-environment-vector? 
	      current-simulation-runtime-structure))
	  (values nil nil)))
     (t
      (values 
	(runtime-formula current-simulation-runtime-structure)
	(runtime-cache? current-simulation-runtime-structure)))))

(defmacro with-bindings-for-variable-sim-eval (&body body)
  `(when current-computation-instance
     (multiple-value-bind (byte-code-body simulation-environment-vector)
	 (simulation-byte-code-body-and-environment
	   current-computation-instance)
       (unless byte-code-body
	 (setq current-computation-instance nil))
       (when byte-code-body
	 ,@body))))



#+development
(defun describe-variables-that-need-simulated-values ()
  (loop for variable in (variables-that-need-simulated-values
			  current-model-runtime-info?)
	for index from 1
	do
    (format t "~%~d." index)
    (describe-variable-that-needs-simulated-values variable)))

#+development
(defun describe-variable-that-needs-simulated-values (variable)
  (when (name-or-names-for-frame variable)
    (format t "~%name: ~s" 
	    (name-or-names-for-frame variable)))
  (multiple-value-bind (frame? slot-name? class-qualifier?)
      (get-kb-parent-information variable)
    (when frame?
      (let ((temporary-text-string
	      (tformat-text-string
		"parent-frame: ~a; parent-attribute-name: ~NQ"
		frame?
		slot-name? class-qualifier?)))
	(format t "~%~a" temporary-text-string)
	(reclaim-text-string temporary-text-string)))))

#+development
(defun display-simulated-values (variable-or-structure)
  (cond
    ((variable-simulation-runtime-structure-p variable-or-structure)
     (format t "~%Value is ~s" 
	     (extract-number-or-value (new-simulation-value variable-or-structure))))
    ((simulation-info-p variable-or-structure)
     (let ((runtime-structure
	     (runtime-info? variable-or-structure)))
       (format t "~%Value is ~s" 
	       (extract-number-or-value (new-simulation-value runtime-structure)))))
    ((of-class-p variable-or-structure 'variable-or-parameter)
     (let ((runtime-structure
	     (simulation-runtime-information? variable-or-structure)))
       (format t "~%Value is ~s" 
	       (extract-number-or-value (new-simulation-value runtime-structure)))))))




;;;; Timing of Variable Updates

;;; Simulation proceeds in cycles where each cycle represents a discrete 
;;; point in time.  The time increment between each cycle is the shortest
;;; time increment for any variable in the simulation.  
;;; The time increment is specified for the entire simulation by the 
;;; default-simulation-time-increment slot of the simulation-parameters 
;;; system table.  This time increment can be overridden for certain variables
;;; by specifying a different time increment in a generic-simulation-formula
;;; (using the "with time increment" clause or in the time-increment-for-update
;;; slot of the simulation subtable of a variable.  Thus, it is possible to 
;;; have different time increments for different variables and therefore,
;;; not all variables have to be updated each cycle.  For example,
;;; most of a plant may be simulated with a 1 minute time increment but 
;;; certain critical parts and reactions may require a 1 second time 
;;; increment.  Rather than using a 1 second time increment for everything,
;;; it is more efficient to use it for only the necessary parts and use
;;; the longer time increment for the rest.  The user is still responsible
;;; for making sure that the simulation stays within error bounds.     

;;; Computing whether a variable should be updated during a cycle could be done
;;; individually for each variable.  However, since there are typically many more
;;; variables than different time increments (and there are certainly never more
;;; different time increments than variables) it is more efficient to group the
;;; variables by time increment and compute whether the group should be updated.
;;; This is accompished using the structure in current-model-runtime-info?  which
;;; maintains update information for each group.  This table is set up by
;;; initialize-simulator which calls set-up-update-timing-for-variable for each
;;; simulated variable.  Simulate-one-cycle updates the appropriate
;;; slots at the beginning of each cycle by calling
;;; determine-variable-groups-to-be-updated.

;; Allow changing of time increments while running?  In 1.0, time increments
;; can be changed but simulator will not use new ones until next call to
;; initialize-simulator.  It shouldn't be too hard to change the 
;; current-model-runtime-info? based on edits while running.

;;; The model-variable-group-update-info slot of current-model-runtime-info?
;;; contains a list of variable-group-update-structures, one for each group of
;;; variables with the same simulation time increment.

;;; A variable-group-update-structure contains update timing information for a
;;; group of variables having the same time increment.  The group is assigned a
;;; group-index-structure for identification purposes.  This group-index-structure
;;; is bound to the variable-group-update-structure and the time-increment- group
;;; slot of the variable-simulation-runtime-structure for each variable in a group
;;; holds this group-index-structure.  This way, it is easy to access the
;;; variable-group-update-structure for a variable (to get update information for
;;; the variable).  Compound-fixnum-time-increment-for-group is
;;; time-increment-for-group in compound-fixnum-simulation-time form, time-of-last
;;; update is the simulation-time corresponding to the cycle during which the last
;;; update of this group of variables took place, and update-group-this-cycle?  is
;;; a flag indicating whether the group is to be updated in the current simulation
;;; cycle.  Index-structure-for-group, and
;;; compound-fixnum-time-increment-for-group are related to installation and are
;;; set up by initialize-simulator.  Time-of-next-update-for-group and
;;; update-group-this-cycle?  are related to running the simulation and are
;;; updated by simulate-one-cycle.

(def-structure variable-group-update-structure
  (index-structure-for-group nil)
  (compound-fixnum-time-increment-for-group nil)
  (time-of-next-update-for-group nil)
  (update-group-this-cycle? nil)
  (new-time-of-next-update-for-group nil)
  (time-increment-due-to-override? nil))

(defun-void reclaim-possible-variable-group-update-structure (variable-group-update-structure?)
  (when (variable-group-update-structure-p variable-group-update-structure?)
    (reclaim-variable-group-update-structure variable-group-update-structure?))
  nil)

;; Rather than using the group-index-structure mechanism, the variables could be
;; grouped into actual lists.  The disadvantage of this is obvious when
;; considering what has to be done to find out if a variable should be updated
;; for some cycle.  Since these lists will typically be long, the memq required
;; to see if a variable is a member (to see if it should be updated) will
;; typically be inefficient.  With the group-index-structure mechanism, the
;; variable-group-update-structure for a variable can be directly accessed in
;; order to determine whether the variable should be updated.


(def-structure group-index-structure
  (variable-group nil
		  :reclaimer reclaim-possible-variable-group-update-structure))


;;; Set-up-update-timing-for-variable is called for each simulated variable by
;;; initialize-simulator.  It determines the time increment for the variable and
;;; then checks if a variable-group-update-structure for the time increment
;;; already exists in the model-variable-group-update-info slot of
;;; current-model-runtime-info?.  If so, the time-increment-group slot of the
;;; variable-simulation-runtime-structure of the variable is simply set to the
;;; group-index-structure for the group.  If not, a new
;;; variable-group-update-structure is made.  Note that the
;;; update-group-this-cycle?  and time-of-next-update-for-group slots are also
;;; initialized here.  Update-group-this-cycle?  is set to t since all groups
;;; should be updated during initialization.  This flag will be updated as
;;; appropriate by simulate-one-cycle so there is no need to worry about resetting
;;; it.  Time-of-next-update is set to default-initial-simulation-time +
;;; compound-fixnum-time-increment-for-group.

(defun set-up-update-timing-for-variable 
       (variable-simulation-runtime-structure
	override-time-increment-for-update?)
  (let ((time-increment-for-variable
	  (or override-time-increment-for-update?
	      (current-default-simulation-time-increment))))
    (store-number-into-compound-fixnum-simulation-time
      simulation-time-accumulator time-increment-for-variable)
    (when (not
	    (loop for variable-group-update-structure 
		      in (model-variable-group-update-info current-model-runtime-info?)
		  do
	      (when (and (=compound-fixnum-simulation-time
			   simulation-time-accumulator
			   (compound-fixnum-time-increment-for-group
			     variable-group-update-structure))
			 (if (time-increment-due-to-override?
			       variable-group-update-structure)
			     override-time-increment-for-update?
			     (null override-time-increment-for-update?)))
		(setf (time-increment-group variable-simulation-runtime-structure)
		      (index-structure-for-group variable-group-update-structure))
		(return t))))
      (let ((new-variable-group-update-structure
	      (make-variable-group-update-structure))
	    (index-structure-for-new-group 
	      (make-group-index-structure)))
	(setf (time-increment-due-to-override? new-variable-group-update-structure)
	      (if override-time-increment-for-update? t nil))
	(setf (time-increment-group variable-simulation-runtime-structure)
	      index-structure-for-new-group)
	(setf (variable-group index-structure-for-new-group)
	      new-variable-group-update-structure)
	(add-to-set (model-variable-group-update-info current-model-runtime-info?)
		    new-variable-group-update-structure)
	(setf (index-structure-for-group new-variable-group-update-structure)
	      index-structure-for-new-group
	      (compound-fixnum-time-increment-for-group
		new-variable-group-update-structure)
	      (make-compound-fixnum-simulation-time)
	      (time-of-next-update-for-group 
		new-variable-group-update-structure)
	      (make-compound-fixnum-simulation-time)
	      (new-time-of-next-update-for-group 
		new-variable-group-update-structure)
	      (make-compound-fixnum-simulation-time))
	(transfer-value-of-compound-fixnum-simulation-times
	  (compound-fixnum-time-increment-for-group
	    new-variable-group-update-structure)
	  simulation-time-accumulator)
	(transfer-value-of-compound-fixnum-simulation-times
	  (shortest-simulation-time-increment current-model-runtime-info?)
	  (min-compound-fixnum-simulation-time
	    (shortest-simulation-time-increment current-model-runtime-info?)
	    (compound-fixnum-time-increment-for-group
	      new-variable-group-update-structure)))

	(when override-time-increment-for-update?
	  (cond 
	    ((<f (macro-time (shortest-override-time-increment
			       current-model-runtime-info?))
		 0)
	     (store-number-into-compound-fixnum-simulation-time
	       (shortest-override-time-increment current-model-runtime-info?)
	       override-time-increment-for-update?))
	    (t
	     (store-number-into-compound-fixnum-simulation-time
	       simulation-time-accumulator
	       override-time-increment-for-update?)
	     (when (<compound-fixnum-simulation-time
		     simulation-time-accumulator
		     (shortest-override-time-increment 
		       current-model-runtime-info?))
	       (transfer-value-of-compound-fixnum-simulation-times
		 (shortest-override-time-increment current-model-runtime-info?)
		 simulation-time-accumulator)))))

	(setf (update-group-this-cycle? new-variable-group-update-structure) t)
	(transfer-value-of-compound-fixnum-simulation-times
	  (time-of-next-update-for-group new-variable-group-update-structure)
	  (default-initial-simulation-time current-model-runtime-info?))
	(add-compound-fixnum-simulation-times
	  (time-of-next-update-for-group new-variable-group-update-structure)
	  (time-of-next-update-for-group new-variable-group-update-structure)
	  (compound-fixnum-time-increment-for-group 
	    new-variable-group-update-structure))
	
	(transfer-value-of-compound-fixnum-simulation-times
	  (new-time-of-next-update-for-group new-variable-group-update-structure)
	  (time-of-next-update-for-group new-variable-group-update-structure))
	
	))))

;; Note that this will allocate a group-index-structure for each different time 
;; increment each time the simulator is started.



(defun get-non-override-variable-group-update-structure (model-runtime-info)
  (loop for variable-group-update-structure 
	    in (model-variable-group-update-info model-runtime-info)
	do
    (when (null (time-increment-due-to-override?
		  variable-group-update-structure))
      (return variable-group-update-structure))))



(defun reclaim-variable-group-update-structure-completely
       (variable-group-update-structure)
  (reclaim-group-index-structure
    (index-structure-for-group variable-group-update-structure))
  (reclaim-compound-fixnum-simulation-time
    (compound-fixnum-time-increment-for-group variable-group-update-structure))
  (reclaim-compound-fixnum-simulation-time
    (time-of-next-update-for-group variable-group-update-structure)))



(defun add-shortest-simulation-time-increment-for-all-models
       (shortest-time-increment-for-model)
  (when (null (simulation-time-for-models-in-queue current-model-queue?))
    (setf (simulation-time-for-models-in-queue current-model-queue?)
	  (initialize-compound-simulation-time)
	  (simulation-base-time-for-models-in-queue current-model-queue?)
	  (initialize-compound-simulation-time))
    (transfer-value-of-compound-fixnum-simulation-times
      (simulation-time-for-models-in-queue current-model-queue?)
      (simulation-base-time current-model-runtime-info?))
    (transfer-value-of-compound-fixnum-simulation-times
      (simulation-base-time-for-models-in-queue current-model-queue?)
      (simulation-base-time current-model-runtime-info?)))
  (cond
    ((null (shortest-time-increment-for-models-in-queue current-model-queue?))
     (setf (shortest-time-increment-for-models-in-queue current-model-queue?)
	   (initialize-compound-simulation-time))
     (transfer-value-of-compound-fixnum-simulation-times
       (shortest-time-increment-for-models-in-queue current-model-queue?)
       shortest-time-increment-for-model))
    (t
     (transfer-value-of-compound-fixnum-simulation-times
       (shortest-time-increment-for-models-in-queue current-model-queue?)
       (min-compound-fixnum-simulation-time
	 (shortest-time-increment-for-models-in-queue current-model-queue?)
	 shortest-time-increment-for-model)))))

(defun update-shortest-simulation-time-increment-for-all-models ()
  (when (null (models-in-queue current-model-queue?))
    (reclaim-compound-fixnum-simulation-time
      (simulation-time-for-models-in-queue current-model-queue?))
    (reclaim-compound-fixnum-simulation-time
      (simulation-base-time-for-models-in-queue current-model-queue?))
    (setf (simulation-time-for-models-in-queue current-model-queue?) nil
	  (simulation-base-time-for-models-in-queue current-model-queue?) nil))
  (reclaim-compound-fixnum-simulation-time 
    (shortest-time-increment-for-models-in-queue current-model-queue?))
  (setf (shortest-time-increment-for-models-in-queue current-model-queue?) nil)
  (loop for model-runtime-info in (models-in-queue current-model-queue?)
	do (add-shortest-simulation-time-increment-for-all-models
	     (shortest-simulation-time-increment model-runtime-info))))

(declare-side-effect-free-function get-current-time-in-simulation-environment)

(defun get-current-time-in-simulation-environment ()
  (cond
    (current-model-runtime-info?
     (current-simulation-time current-model-runtime-info?))
    ((framep evaluating-simulator-procedure?)
     (current-simulation-time
       (model-runtime-info-function? evaluating-simulator-procedure?)))
    (t
     (let ((time-for-models-in-queue
	     (simulation-time-for-models-in-queue 
	       synchronous-model-queue))
	   (base-time-for-models-in-queue
	     (simulation-base-time-for-models-in-queue 
	       synchronous-model-queue)))
       (if (and time-for-models-in-queue
		base-time-for-models-in-queue)
	   (subtract-compound-fixnum-simulation-times
	     simulation-time-accumulator
	     time-for-models-in-queue base-time-for-models-in-queue)
	   (with-temporary-gensym-float-creation get-current-time
	     (store-number-into-compound-fixnum-simulation-time
	       simulation-time-accumulator
	       0.0d0)))
       simulation-time-accumulator))))

;; Get-current-time-in-simulation-environment returns a
;; compound-fixnum-simulation-time.



(defun get-current-time-in-simulation-environment-and-convert-to-g2-time ()
  (let ((gensym-time-value nil))
    (setq gensym-time-value
	  (cond
	    (current-model-runtime-info?
	     (add-compound-fixnum-simulation-times
	       simulation-time-accumulator
	       (current-simulation-time current-model-runtime-info?)
	       (simulation-base-time current-model-runtime-info?))
	     (extract-macro-number-from-compound-fixnum-simulation-time 
	       simulation-time-accumulator))
	    ((framep evaluating-simulator-procedure?)
	     (let ((model-runtime-info
		     (model-runtime-info-function?
		       evaluating-simulator-procedure?)))
	       (add-compound-fixnum-simulation-times
		 simulation-time-accumulator
		 (current-simulation-time model-runtime-info)
		 (simulation-base-time model-runtime-info))
	       (extract-macro-number-from-compound-fixnum-simulation-time 
		 simulation-time-accumulator)))
	    (t
	     (transfer-value-of-compound-fixnum-simulation-times
	       simulation-time-accumulator
	       (simulation-time-for-models-in-queue synchronous-model-queue))
	     (extract-macro-number-from-compound-fixnum-simulation-time
	       simulation-time-accumulator))))
    (+e (convert-gensym-time-to-unix-time gensym-time-value)
	(extract-micro-number-from-simulation-time-as-float
	  simulation-time-accumulator))))



;;; The function `get-simulation-environment-gensym-time-for-variable-as-float'
;;; returns the simulation time for the given variable.  Note that a
;;; managed-float is returned, but this value should be copied and *NOT* HELD
;;; ONTO.

;;; Note that this time is relative to gensym-time and not g2-time.

(defun get-simulation-environment-gensym-time-for-variable-as-float
       (variable-or-parameter)
  (let ((model-runtime-info?
          (when (simulation-info? variable-or-parameter)
            (get-model-runtime-info-for-variable variable-or-parameter))))
    (when model-runtime-info?
      (add-compound-fixnum-simulation-times
        simulation-time-accumulator
        (current-simulation-time model-runtime-info?)
        (simulation-base-time model-runtime-info?))
      (extract-number-from-compound-fixnum-simulation-time
        simulation-time-accumulator))))




;;;; Functions to Interface Inference Engine Requests to Simulator

;;; Collect-one-shot-data-for-simulator checks if the simulator is on and if the
;;; variable has a simulation runtime structure.  If so, and if the simulator is
;;; up to date with gensym time, or the variable is not to be updated by the
;;; simulator this cycle, it will immediately call put-current-value to pass back
;;; the simulated value.  Note that if a variable is not to be updated during a
;;; simulation cycle, its simulated value computed from a previous simulation
;;; cycle is still valid and can be sent back to the inference engine.  If the
;;; simulator is not up to date with gensym time, and the variable is to be
;;; updated during this cycle, the
;;; interval-at-which-to-send-value-to-inference-engine slot of the simulation
;;; runtime structure is set to ('send-one-value .  gensym-time).  Gensym-time is
;;; stored here to save the time of this request.  The next time update-variable
;;; is called for this variable, it checks the slot and compares simulation time
;;; with the time of request in the slot to see if the value should be sent (see
;;; update-variable).  If it should be sent, update-variable will call
;;; put-current-value just as is done in collect-one-shot-data-for-simulator.  The
;;; time of request is passed as the collection time argument to
;;; put-current-value.  Update-variable will clear this slot when it sends data.

;;; In the run cycle, the data servers are executed before other tasks.  However,
;;; the data servers are suspendable if they take too long.  Thus, the simulator
;;; may suspend before being finished and therefore will not be up to date when
;;; collect-one-shot-data-for-simulator is called, resulting in put-current-value
;;; not being immediately called.  This results in wakeups being set up.  Note
;;; that this can happen in simulated time mode as well as real time mode.  In
;;; simulated time mode, the simulator is allowed to run for some time at the
;;; beginning of the cycle, then inference engine tasks are executed.  After this,
;;; the simulator is allowed to finish if it didn't get finished when it was first
;;; called.  Finally gensym-time is incremented.

;;; Collect-one-shot-data-for-simulator does not return any meaningful value.

;; It would be possible to save a lot of wakeups by not running any inference
;; engine tasks until the simulator is finished (in simulated time mode).  The
;; simulator would still be suspended so that user editing tasks could be
;; executed.  Talked to Jim about this.  Seems like a good idea!  This would
;; also solve the (minor) problem of readouts not being consistently up to date
;; with the simulator.  Greg noticed this problem when running a simulation,
;; then adding some objects, and running the simulation again (see bug report
;; 663).  Readout values that should have been the same after 10 seconds for
;; each run were slightly different.  This made it appear that simulation
;; results were a function of how many objects were in the kb.  It was actually
;; due to the fact that the simulator suspends itself if the knowledge base is
;; too large and the readout update function was scheduled at slightly different
;; times.


;;; Variable-to-be-updated-this-cycle?  accesses the
;;; variable-group-update-structure corresponding to the variable to see if it
;;; should be updated.  Note that the calculate-new-values...  functions set the
;;; update-variable-this-cycle?  flag in the variable-simulation-runtime-structure
;;; if the variable is to be updated and clear it if it is not.  Thus, the result
;;; of variable-to-be-updated-this-cycle?  is "cached" in the
;;; update-variable-this-cycle slot and variable-to-be-updated-this-cycle?  need
;;; only be computed once per cycle for each variable.

(defmacro variable-to-be-updated-this-cycle? (variable-simulation-runtime-structure)
  (let ((value-of-structure (gensym))
	(variable-group (gensym)))
    `(let* ((,value-of-structure ,variable-simulation-runtime-structure)
	    (,variable-group   (variable-group
				       (time-increment-group ,value-of-structure))))
       (when (and
	       ,variable-group
	       (update-group-this-cycle? ,variable-group))
	 (cond
	   ((eq (update-variable-this-cycle? ,value-of-structure)
		'suppress-first-update)
	    nil)
	   (t t))))))

(defmacro get-compound-fixnum-time-increment-for-group
	  (variable-simulation-runtime-structure)
  `(compound-fixnum-time-increment-for-group
     (variable-group
       (time-increment-group
	 ,variable-simulation-runtime-structure))))

(defmacro collect-one-shot-data-request-pending?
	  (interval-at-which-to-send-value-to-inference-engine)
  `(eq (car ,interval-at-which-to-send-value-to-inference-engine)
       'send-one-value))

(defmacro collecting-at-regular-interval?
	  (interval-at-which-to-send-value-to-inference-engine)
  (let ((value-of-interval (gensym)))
    `(let ((,value-of-interval ,interval-at-which-to-send-value-to-inference-engine))
       (and ,value-of-interval
	    (not (eq (car ,value-of-interval) 'send-one-value))))))

(defmacro one-shot-and-interval-request-pending?
	  (interval-at-which-to-send-value-to-inference-engine)
  `(consp (cdr ,interval-at-which-to-send-value-to-inference-engine)))



(defun collect-one-shot-data-for-simulator 
       (variable &optional model-runtime-info? model-definition?)
  (with-current-model model-runtime-info? model-definition?
		      (collect-one-shot-data-for-simulator-1 variable)))

(defun collect-one-shot-data-for-simulator-1 (variable)
  (when (and (simulator-on? simulation-parameters)
	     (not (g1-authorized-p)))
    (let* ((variable-simulation-runtime-structure?
	     (simulation-runtime-information? variable))
	   (interval-at-which-to-send-value-to-inference-engine
	     (if variable-simulation-runtime-structure?
		 (interval-at-which-to-send-value-to-inference-engine
		   variable-simulation-runtime-structure?)))
	   (*current-computation-frame* variable)
	   (current-computation-instance (data-server 'simulator-data-server)))
      (when (and variable-simulation-runtime-structure?
		 (not (collect-one-shot-data-request-pending?
			interval-at-which-to-send-value-to-inference-engine)))
	(cond 
	  ((or (simulator-up-to-date? current-model-runtime-info?)
	       (not (variable-to-be-updated-this-cycle?
		      variable-simulation-runtime-structure?)))
	   ;; If simulator is up to date with gensym-time, or if variable is not
	   ;; being updated this cycle, return value immediately by calling
	   ;; put-current-value.

	   (let ((simulation-value
		   (extract-number-or-value
		     (simulation-value
		       variable-simulation-runtime-structure?))))
	     (when (not (no-simulation-value-p simulation-value))
	       (put-simulated-value-to-inference-engine
		 ;; Use the default collection-time, which is current-g2-time.
		 variable simulation-value nil))))
	  (t
	   (setf (interval-at-which-to-send-value-to-inference-engine
		   variable-simulation-runtime-structure?)
		 (if (collecting-at-regular-interval?
		       interval-at-which-to-send-value-to-inference-engine)
		     (simulate-cons
		       'send-one-value 
		       (simulate-cons
			 (allocate-managed-float
			   (time-since-base-time-as-gensym-float))
			 interval-at-which-to-send-value-to-inference-engine))
		     (simulate-cons 'send-one-value
				    (allocate-managed-float
				      (time-since-base-time-as-gensym-float)))))))))))

;; In call to put-current-value, consider passing current-simulation-time instead of 
;; gensym-time.  It is possible for these to be slightly different if the
;; simulation time increment is not a multiple of the gensym time clock tick
;; increment (currently one second).


;;; Begin-collecting-data-for-simulator returns a value immediately if the
;;; simulator is up to date (or the variable is not to be update this cycle by
;;; simulator), and then sets the
;;; interval-at-which-to-send-value-to-inference-engine and the
;;; last-time-value-sent-to-inference-engine slots of the simulation runtime
;;; structure.  Update variable uses these slots to decide when to call
;;; put-current-value.  Last-time-value-sent-to-inference-engine is initialized
;;; to 'long-time-ago but is then set to a fixnum the first time a value is
;;; returned.  This fixnum indicates the time that the last value was sent and
;;; is updated by update-variable.
;;; Interval-at-which-to-send-value-to-inference-engine is of the form
;;; (collection-interval .  gensym-time).  Gensym time is stored here to save
;;; the time of the request.  It is used the first time a value is sent back as
;;; the collection time argument for put-current-value.  Collection times for
;;; subsequent values are computed from collection-interval and
;;; last-time-value-sent-to-inference-engine.

;;; If a variable has just been created (asynchronously), it does not have a
;;; variable-simulation-runtime-structure (these are added by
;;; handle-editing-changes-effecting-simulation at the beginning of the next
;;; simulation cycle).  If this is the case,
;;; begin-collecting-data-for-simulated-variable-if-appropriate is called by
;;; handle-editing-changes-effecting-simulation and calls
;;; begin-collecting-data-for-simulator after the
;;; variable-simulation-runtime-structure has been added.

(defun begin-collecting-data-for-simulator
    (variable interval &optional model-runtime-info? model-definition?)
  (let (interval-to-use)
    (with-temporary-creation begin-collecting-data-for-simulator
      (setq interval-to-use
	  (allocate-managed-float
	    (if (managed-float-p interval)
		(managed-float-value interval)
		(coerce-fixnum-to-gensym-float interval)))))
    (with-current-model model-runtime-info? model-definition?
      (begin-collecting-data-for-simulator-1 variable interval-to-use))))

;;; we're guarding for a lot of possibilities here assuming it could be a
;;; symbol or managed float or list of (a .b) or (c a .b)
(defun reclaim-interval-at-which-to-send-value-to-inference-engine (interval)
  (cond ((consp interval)
	 (loop with car-item = (car interval)
	       with cdr-item = (cdr interval)
	       while car-item
	       do
	   (when (managed-float-p car-item)
	     (reclaim-managed-float car-item))
	   (cond ((consp cdr-item)
		  (setq  car-item (car cdr-item)))
		 (t (setq  car-item cdr-item)))
	   (setq cdr-item (when (consp cdr-item)
			    (cdr cdr-item))))
	 (reclaim-simulate-list* interval))
	((managed-float-p interval)
	 (reclaim-managed-float interval))))


(defun begin-collecting-data-for-simulator-1 (variable collection-interval)
  (let ((collection-interval-used? nil))
    (when (and (simulator-on? simulation-parameters)
	       (not (g1-authorized-p)))
      (let ((variable-simulation-runtime-structure?
	      (simulation-runtime-information? variable))
	    (*current-computation-frame* variable)
	    (current-computation-instance (data-server 'simulator-data-server))
	    interval-at-which-to-send-value-to-inference-engine)
	(when variable-simulation-runtime-structure?
	  (setq interval-at-which-to-send-value-to-inference-engine
		(interval-at-which-to-send-value-to-inference-engine
		  variable-simulation-runtime-structure?))
	  (cond
	    ((or (simulator-up-to-date? current-model-runtime-info?)
		 (not (variable-to-be-updated-this-cycle?
			variable-simulation-runtime-structure?)))
	     ;; If simulator is up to date with gensym-time, or if variable is not
	     ;; being updated this cycle, return value immediately by calling
	     ;; put-current-value.
	     
	     (let ((simulation-value
		     (extract-number-or-value
		       (simulation-value variable-simulation-runtime-structure?))))
	       (when (not (no-simulation-value-p simulation-value))
		 (put-simulated-value-to-inference-engine
		   ;; Use the default collection-time, which is current-g2-time.
		   variable simulation-value nil)))
	     
	     (set-last-time-value-sent-to-inference-engine
	       variable-simulation-runtime-structure?
	       (time-since-base-time-as-gensym-float)))
	    (t
	     (set-last-time-value-sent-to-inference-engine
	       variable-simulation-runtime-structure?
	       'long-time-ago)))
	  (reclaim-interval-at-which-to-send-value-to-inference-engine
	    interval-at-which-to-send-value-to-inference-engine)
	  (setq collection-interval-used? t)
	  (setf (interval-at-which-to-send-value-to-inference-engine
		  variable-simulation-runtime-structure?)
		(simulate-cons collection-interval
			       (allocate-managed-float
				 (time-since-base-time-as-gensym-float)))))))
    (unless collection-interval-used?
      (when (managed-float-p collection-interval)
	(reclaim-managed-float collection-interval)))))


;; Begin-collecting-data-for-simulator is now being used again.  Previously,
;; only collect-one-shot-data-for-simulator was used - agh, 7/18/88.



(defun begin-collecting-data-for-simulated-variable-if-appropriate 
       (variable-or-parameter)
  (when (and (variable-p variable-or-parameter)  ; screen out parameters
	     (active-p variable-or-parameter))
    (let ((collection-interval? (background-collection-interval? variable-or-parameter))
	  (data-server? (get-data-server variable-or-parameter)))
      (when (and collection-interval?
		 (data-server-p data-server?)
		 (eq (name-of-data-server data-server?) 'simulator-data-server))
	(begin-collecting-data-for-simulator 
	  variable-or-parameter collection-interval?)))))



(defun stop-collecting-data-for-simulator (variable)
  (let ((variable-simulation-runtime-structure?
	  (simulation-runtime-information? variable))
	interval-at-which-to-send-value-to-inference-engine?)
    (when (and variable-simulation-runtime-structure?
	       (setq interval-at-which-to-send-value-to-inference-engine?
		     (interval-at-which-to-send-value-to-inference-engine
		       variable-simulation-runtime-structure?)))
      (setf (interval-at-which-to-send-value-to-inference-engine
	      variable-simulation-runtime-structure?)
	    (if (one-shot-and-interval-request-pending?
		  interval-at-which-to-send-value-to-inference-engine?)
		(simulate-cons 
		  (first interval-at-which-to-send-value-to-inference-engine?)
		  (second interval-at-which-to-send-value-to-inference-engine?))
		nil))
      (cond ((interval-at-which-to-send-value-to-inference-engine
	       variable-simulation-runtime-structure?)
	     (reclaim-simulate-list* interval-at-which-to-send-value-to-inference-engine?))
	    (t
	     (reclaim-interval-at-which-to-send-value-to-inference-engine
	       interval-at-which-to-send-value-to-inference-engine?))))))


;;; Processing Data Requests While Others are Still Pending

;;; There are four cases of data request while another request is pending;
;;; 1.  one shot request while one shot is still pending,
;;; 2.  one shot request while collecting at regular interval.
;;; 3.  begin collecting data request while one shot is still pending,
;;; 4.  begin collecting data request while collecting at regular interval,

;;; If collect-one-shot-data-for-simulator is called while a collect
;;; one shot request is still pending, then the simulator has not yet caught up
;;; sufficiently to process the previous request.  The new request will be
;;; ignored in this case.  If collect-one-shot-data-for-simulator while
;;; collecting data at regular intervals (if collect-one-shot-data-for-simulator
;;; is called between begin-collecting-data-for-simulator and
;;; stop-collecting-data-for-simulator), then the one shot request is processed
;;; but interval collection continues uninterrupted as if the one shot request
;;; never happened.  If the one shot request can't be processed immediately, the
;;; interval-at-which-to-send-value-to-inference-engine slot is set to
;;; ('send-one-value gensym-time-for-one-shot collection-interval .
;;; gensym-time) (see also notes on begin-collecting-data-for-simulator).  When
;;; update-variable sends the value for the one shot request, it sets the
;;; interval... slot back to its form for collecting at regular intervals:
;;; (collection-interval .  gensym-time).  If stop-collecting-data-for-simulator
;;; is called before update-variable sends the value for the one shot request,
;;; the interval... slot is set to the form for processing one shot requests: 
;;; ('send-one-value .  gensym-time).  In general, update-variable cleans up for
;;; collect-one-shot-data-for-simulator and stop-collecting-data-for-simulator
;;; cleans up for begin-collecting-data-for-simulator, even if both types of
;;; requests are pending at one time.

;; Consider modifying this so that if collect-one-shot-data-for-simulator is called
;; for a time which data is already scheduled to be collected, the one shot request
;; is ignored.  This would save an extra call to put-current-value.

;;; If begin-collecting-data-for-simulator is called while a one shot request is
;;; still pending, the one shot request is replaced with the begin collecting data
;;; request.  If begin... is called while data is already being collected at a
;;; regular interval, the interval specified in the most recent call to begin...
;;; will be used. 

;; All data servers should follow these rules.


;;; Set-external-variable-for-simulator is the last link in the mechanism
;;; which allows the inference engine to affect simulated values.
;;; This function simply sets the simulation value of the variable, 
;;; overiding the simulated value that was calculated for it the
;;; last time that simulate-one-cycle was run.  This value will stay
;;; until the next time the simulated value is updated by the 
;;; simulator.  Thus, setting a simulated value in this way does not
;;; mean that it will necesarily stay that way for long;  it could
;;; be wiped out in the next simulation cycle.  One way to achieve
;;; a more permanent effect is to give the variable being set a 
;;; simulation formula of the form 
;;; "state variable: next value = <name-of-variable>".
;;; This way, the set value will persist until it is set again to
;;; a new value.  

;; Consider defining a set of simulation input variables which have
;; this behavior.

;; Note that this function should never be called in the middle of
;; a simulation cycle.  This will be an issue when the simulator is
;; broken into suspendable tasks.

;;; Note also that for this to work, the data server map must be
;;; g2-simulator.


(defun compute-g2-time-for-simulation-time (simulation-time)
  (let ((accumulator-compound-fixnum-simulation-time
	  (make-compound-fixnum-simulation-time))
	(gensym-time-value nil)
	(g2-time-value nil))
    (add-compound-fixnum-simulation-times
      accumulator-compound-fixnum-simulation-time
      simulation-time
      (simulation-base-time current-model-runtime-info?))
    (setq gensym-time-value
	  (extract-macro-number-from-compound-fixnum-simulation-time
	    accumulator-compound-fixnum-simulation-time))
    (setq g2-time-value
	  (+e (convert-gensym-time-to-unix-time
		gensym-time-value)
	      (extract-micro-number-from-simulation-time-as-float
		accumulator-compound-fixnum-simulation-time)))
    (reclaim-compound-fixnum-simulation-time
      accumulator-compound-fixnum-simulation-time)
    g2-time-value))


;; this is to arrange an overly complex set of forward references
;; in the ring boffer code 
(defun current-simulation-time-as-float ()
  (managed-float-value
    (current-simulation-time-as-managed-float)))

(defun current-simulation-time-as-managed-float ()
  (extract-number-from-compound-fixnum-simulation-time
    (new-simulation-time current-model-runtime-info?)))

(defun set-external-variable-for-simulator (variable value &optional data-type)
  (setq value (evaluation-value-value value))
  (when (simulation-runtime-information? variable)
    (store-simulated-value-if-compatible
      variable
      (simulation-value
	(simulation-runtime-information? variable))
      value)
    (store-simulated-value-if-compatible
      variable
      (new-simulation-value
	(simulation-runtime-information? variable))
      value))
  (when (and (parameter-p variable)
	     evaluating-simulator-procedure?)
    (let ((put-current-value-called-from-simulator-p t))
      (put-simulated-value-to-inference-engine
	variable value
	(get-current-time-in-simulation-environment-and-convert-to-g2-time) data-type))))



;;; Convert-simulation-value-to-value-and-type is used by the simulator to send
;;; values back to the inference engine via put-current-value.  It is needed
;;; because the simulator does not maintain types.  It assumes that
;;; simulation-value is not simulation-no-value, and returns value and type.  Note
;;; that in the case of truth values, the value returned is not the same as the
;;; value passed in.

(defun convert-simulation-value-to-value-and-type (value)
  (let ((type
	  (cond 
	    ((numberp value) 'number)
	    ((eq value nil)
	     (setq value -1000)
	     'truth-value)
	    ((eq value t)
	     (setq value 1000)
	     'truth-value)
	    ((symbolp value) 'symbol)
	    ((text-string-p value) 'text))))
    (values value type)))



;;; The function `put-simulated-value-to-inference-engine' should be used for
;;; putting a simulated value into the inference engine.  Simulation-value
;;; should not be simulation-no-value.

(defun put-simulated-value-to-inference-engine
    (variable simulation-value collection-time? &optional (type? nil))
  (let (value type)
    (cond (type?
	   (setq value simulation-value)
	   (setq type type?))
	  (t
	   (multiple-value-setq (value type)
	     (convert-simulation-value-to-value-and-type simulation-value))))
    (put-current-value 
      variable value type nil collection-time?)))





;;; Notes on Interface between Simulator and Inference Engine

;;; 1.  Simulator Providing Values to Inference Engine Normally,
;;; simulated values are provided to the inference engine via sensor
;;; variables, just as real values from the data acquisition interface
;;; are.  It is currently possible for the inference engine to obtain
;;; simulated values for non-sensor variables.  If the variable is not a
;;; sensor variable and the source-of-value is 'simulation then
;;; obtain-newer-value-from-simulation will be called (see
;;; obtain-newer-value in "variables").
;;; 
;;; In most cases however, the simulated values will be provided via
;;; sensor variables.  It is important that this happen in such a way
;;; that is identical (from the standpoint of the inference engine) to
;;; getting real data via the data acquisition interface.  Therefore,
;;; when the inference engine calls obtain-newer-value and the variable
;;; is a sensor variable, it will be turned on (if it isn't already) and
;;; begin-collecting-data will be called.  It is here that the decision
;;; to use real or simulated values is made.  The source-of-value for
;;; the variable is computed and if it is not 'simulation, then
;;; begin-collecting-real-data will be called.  The data acquisition
;;; interface will then supply values at the specified rate.  If the
;;; source-of-value is 'simulation, then the
;;; interval-at-which-to-send-value-to-inference-engine and
;;; last-time-value-sent-to-inference-engine slots of the simulation
;;; frame will be set to appropriate values.  The simulator will then
;;; supply values at the specified rate just as the data acquisition
;;; interface would and the inference engine has no way of knowing
;;; whether the data is simulated or real.  (See also
;;; begin-collecting-data and stop-collecting-data currently in
;;; "variables", and update-variable in "simulate").

;;; 2.  Inference Engine Setting Simulated Values
;;; 
;;; An output action has been defined for the inference engine.  If the variable
;;; is not being simulated, the output will be sent out via the interface.
;;; If the variable is being simulated, it must be an "input" simulation variable.
;;; The output action will put the value into the simulated-value slot of 
;;; the simulation-subtable.  The simulation computation method should be a simple
;;; expression which indicates that the new-simulation-value should be 
;;; obtained simply from the simulation value;  something like 
;;; (use-current-simulation-value).  





;;;; To Do

;; Simulation data service needs to be revised.  Rather than serving data
;; in update-variable, set up separate (but efficient) mechanism called at
;; the end of simulate-one-cycle to handle data service.  See also bug report 
;; 2096.  Update-variable will thus be greatly simplified.  It should not
;; take much time at all.  It should become a macro to avoid function call
;; overhead.  Do speed tests to make sure this part is as efficient as
;; possible.  Perhaps it could be avoided completely for all but the state
;; variables.  Variables that save simulated histories could be kept on a 
;; separate list and could be handled separately.

;; Simulation initialization issues need to be documented better in the user
;; manual.  Currently, backchaining through dependent variables via algebraic
;; formulas is done when computing initial values for state variables.  It
;; should be easy to extend this to backchaining through state variables as
;; well via the initial value formulas.  Of course, if a loop is encountered,
;; the evaluation will fail.  Need to give good warning messages for this and
;; in general, when a simulation value fails.  These should probably be at
;; level 3 when running and at level 2 when initializing.  Possibly give a
;; backtrace showing chain of variables being computed when evaluation failed.
;; Probably should distinguish between variables
;; failing to get values due to missing formulas and variables failing to get
;; values due to loops.  The former should be at warning level 2, the latter,
;; at warning level 3.

;; Functions called from simulation - put up warning message if args fail to
;; evaluate (same way as inference engine does it). 

;; Clarify what disable should do for simulator.  Disabling simulation formulas,
;; connections.  Should probably be the same as deleting these.
;; Also, clarify in user documentation the basic distinction between the
;; inference engine (which observes data) and the simulator (which generates data). 

;; Review data service issues.  Collect-one-shot-data is ok.  
;; Begin-collecting-data is limited, however, by the fact that service
;; is done within update-variable and cannot happen more frequently than this.
;; While it is unreasonable for someone to give a validity interval and 
;; default update interval shorter than the simulation time step, and while
;; begin collecting data is only used for default collection intervals, this
;; should be improved.  Move data service out of update-variable and add 
;; extra function to do this at the end of simulate-one-cycle.

;; Review functions for posting warnings.  Update and improve.
;; Will need to add more of these.

;; Make role-cache and runtime-structures-affected-by-this-entity into one slot.
;; Jim's stuff in the role-cache slot is in alist form.  My runtime structures
;; stuff could be just another element in the alist.  Jim says the alist wont
;; be long so there is never a search efficiency problem here.

;; When done re-organizing, put a table of contents on major sections at top of
;; simulate1.

;; Move documentation on handling edits while running from bottom of this file
;; to appropriate places.

;; In simulated-time mode, allow simulator to finish before executing inference engine
;; and display tasks (see documentation for collect-one-shot-data-for-simulator).
;; Talk to Jim.  Should be done.  Test this.  Data servers should have highest 
;; priority.

;; (semi-low priority)
;; Make update-variables suspendable.


;; Lower Priority To Do

;; Review cloning of variables.  If the variable has a specific simulation formula,
;; an ellipsis is put into the new one and the value is (no-value).  This 
;; currently requires some special handling in the slot putters.  See if this 
;; can be eliminated or simplified.  It is essentially a cloning issue.

;; Move recursion limit parameter out of inference engine parameters slot since
;; this parameter is used by simulator as well.

;; Other numerical techniques.  Predictor-corrector, Implicit.

;; Better control of simulation cycle.  Should be able to interrupt in
;; the middle of the cycle and repeat that cycle (see notes for 
;; remove-variable-from-simulation).

;; Mode where no editing happens?  This will be more of an issue when 
;; compiling down to machine code.

;; Time after initialization (see note at end of initialize-simulator).

;; (low priority)
;; In liquid-flow, deleting PID workspace while running doesn't cause graphs
;; of table-2-level, etc. to clear.  The variables are no longer part of the 
;; simulation but they still have history values.

;; Consider making caching of runtime formulas more efficient in terms of runtime
;; memory (see notes at top of this file).

;; Update-variable could be made a macro to save a function call.

;; Consider handling common operators like +, -, *, and /, specially
;; with inline macros in sim-eval.  This would make a difference now since
;; sim-eval now takes a significant percentage of the time.  The extra
;; condition tests would slow down other operators however.
;; Do a benchmark on how long it takes to retrieve a simulation evaluator
;; in sim-eval.

;; See how much overhead is involved with keeping history values.  This should
;; be small.  Also, with big simulations such as tray by tray simulations of
;; distillation columns, it is silly to keep histories for every single 
;; simulated variable. 

;; Consider, at least for dependent variables, doing stuff done in
;; update-variable in calculate-new-values...  This would save loop overhead.

;; When done, test liquid-flow and other kbs to see how much they have improved.
;; Improvement should be comparable to pointer-on-cart even though equations
;; are more complicated.  More complicated equations take longer for the
;; arithmetic but also have more designations and the improvement is large for
;; the designations.  Meter percentage of time spent in sim-eval to judge
;; how much speeding up sim-eval would help.
;; - done for the most part - see agh>new-simulator-test-results.lisp

;; Think about various kinds of compiling of portions or all of
;; the simulation, depending on what the "mode" is.  In certain
;; modes, the user could designate what is to be edited while running and 
;; those parts wouldn't be compiled.

;; Do some simple benchmarks (similar to the ones in agh>simple-speed-tests)
;; in C on a VAX or PC.  Also, run simple-speed-tests on VAX.  See if there
;; is a noticeable inefficiency in Lucid.

;; When sorting, separate out algebraic loops and separate these if
;; possible (if subsystems are decoupled).

;; Think about DAE systems, solving simultaneous equations, and modeling
;; DAE systems as stiff systems and using implicit techniques as suggested
;; by Petzold in one of her papers.

;; Think about ways to take advantage of the fact that these matrices 
;; are sparse.

;; Analytic techniques such as solving simultaneous equations analytically
;; and analytic differentiation.  Read up on Macsyma?

;; (low priority)
;; If avoid arithmetic errors trap occurs, return no-simulation-value. 

;; (low priority)
;; Review simulation warning notes.  Make sure all of these use the one true method
;; for writing a variable.  Also, if a variable can't get a value for simulation,
;; a message is posted only when initializing.  If an edit change is made later
;; which causes a variable to not get a simulation value, a message is not put up.
;; Consider switching to the approach used in the inference engine:  use a
;; non-level-1 message.

;; (low priority)
;; Review data service issues 
;; (see collect-one-shot-data-for-simulator, update-variable).

;; The simulator does not currently do much type checking of values.  Perhaps
;; it should.  Rather than return explicit type values as is done in the 
;; inference engine, just use value to derive type.  The simulator deals
;; with numbers for the most part.  However, logical expressions can
;; be embedded in antecedents of "if" expressions, yielding logical values.
;; Also, the grammars for displays and functions is much less restrictive
;; than the simulation grammar.  Since displays and functions can be used
;; for simulation, it is possible to get symbolic and text values into the
;; simulator.  Simulation functions do check if arguments are numeric or not
;; and post a message if the type is not correct.  Review to make sure that
;; all evaluators do this and, perhaps, expand on the type checking 
;; capabilities.

;; There is now a directory of names capability.  This allows for putting g2 
;; function names in the menu.  Since the simulator function names are the
;; same as the inference engine function names, nothing has to be done for the 
;; simulator if this is done in the inference engine.

;; Review simulation evaluator for "the".  Compare to one in inference engine.
;; Make sure that it ensures that the uniqueness requirement is satisfied.

;; Consider changing grammar for specifying initial value for state variable 
;; simulation formula:
;; "with initial value being <expression>"
;; rather than
;; "with initial value <expression>"

;; In simulate-one-cycle when a new state variable is entered, its
;; new-simulation-value-time is default-initial-simulation-time.  Review this.
;; It may be more appropriate to make this the current time since it could
;; lead to a very large integration step on the first iteration.

;; Currently, the non-default-initial-simulated-value? slot of a variable is
;; always nil or a number.  Consider allowing this to be an expression as well
;; (just like initial value expressions in formulas).

;; Need to improve message facility for when simulator can't get a value.
;; Use different message levels.  Currently, message only sent during 
;; initialization or when a new variable is entered.  This means that if a
;; state variable successfully gets its initial value but then can't evaluate
;; its formula, no message will be sent.  Similarly, if the schematic changes,
;; due to editing a connection for example, a variable may suddenly not be able
;; to get a simulated value.  However no message will be sent since initialization
;; has already passed.

;; Think about issues of summing flows in a junction block.

;; (low priority)
;; Editing a generic simulation formula for a state variable while running
;; causes the variable to reset and begin from its initial value.
;; Review this.  Bug?  Feature?

;; Review with Jim all places where I post messages; simulate, 
;; compile1, install, and connections.

;; Matrices - Talk to Greg.  See stuff on Matlab and Linpack.
;; Actually, it would probably be best to limit this to entering models in
;; matrix form.  I don't think we want to make a general matrix engineering
;; tool like Linpack.
;; Get spec on entering models in matrix format from Dave Schnelle.

;; Evaluators for there-exists and for-every.  When these are implemented, change 
;; grammar for simulation-expression to allow for iteration in antecedents of if
;; statements.  Note that an evaluator for there-exists-an-inverse is not needed
;; since this never occurs in compiled expressions, only in compiled rules.

;; The rk4 and exact integration techniques are currently disabled.  Revive
;; at some point when other complicated issues (multiple simulators, 
;; simultaneous equations, compilation) are resolved.  Also consider
;; predictor-corrector (implicit) integration techniques.

;; There is some repetition of initialization code between simulate-one-cycle and
;; initialize-simulator.

;; Currently, not allowed to change simulation time step while running.
;; Consider relaxing this restriction at some point.

;; Use +e, *e, etc. (floating point functions) for calculations.
;; Allow declaring of types.

;; Review functions and function calling from simulator once again.

;; Implement same-object-as predicate; similar to one in inference engine.

;; Speed-up ideas:
;;   4.  Compilation to Lisp.
;;   5.  Composite Objects.  As long as nothing inside them is
;;       edited, they can be cached and compiled.
;;   6.  Define "moveable" connections.  These connections will
;;       remain uncached and uncompiled while the rest of the
;;       schematic is.  Thus, most of the simulation will be
;;       compiled but a portion of it won't and can be changed
;;       while the system is running.  This provides efficiency
;;       and flexibility.
;;   7.  Important variables:  only these dependent variables are
;;       evaluated at top level (ordering loops issue).
;;   9.  Consider using a marking scheme rather than variables
;;       to exclude to avoid looping.  Note that this is no longer a
;;       big issue since in most kbs, most variables can be sorted so
;;       that there is no recursion.
;;   10. Review functions of file.  See if they can be compacted.

;; Multiple Simulations.
;; How to address in displays and inference engine.  How to
;; communicate between them.  How to keep histories for each.
;; Simulation-information? structure has to be expanded and 
;; abstracted.  See other notes.

;; Activation and de-activation issues for the simulator.  Have to be
;; Able to turn simulator off.  Note, if switching between simulators,
;; must be done in such a way that values for state variables are preserved
;; during the switch.  This is an issue for multiple simulators.

;; Implement "the value of any object".  This would allow
;; generic simulation formulas to set simulated values of 
;; variables and sensors.

;; Consider having simulator deal with truth values and symbolic values
;; as well as numbers?

;; In specific simulation formulas, consider putting the variable name
;; or some such designation on the left side of the equation.
;; Alternatively, consider allowing "this variable" in the right
;; side to the equation.

;; State variables with constraints.  
;; state variable: d/dt = ... , with initial value ... , with constraints <algebraic equation>.
;; See notes in design book from discussions with Astrom.  Talk to 
;; Greg.  At least put in saturation checks.

;; Error messages - post... functions.  Use Mark and Lowell's stuff here.
;; There is an incompatibility here though since the messages have to
;; be posted on the logbook using notify-user.  
;; Lowell's functions, however, write them into slots of tables.

;; Solve simultaneous equations.  Do first by iterative means on algebraic
;; loops which have been separated out by the sort.  Later, implement 
;; automatic linearization for some things.  A very useful technique would
;; be to allow table entry of characteristic functions (for pumps etc.).
;; This is a very common way to describe non-linear components; much more
;; common than trying to discover one function that fits the table.
;; Since these tables are already in piecewise linear form, the problem
;; becomes one of solving simultaneous linear equations instead of the
;; more difficult case of solving simultaneous non-linear equations.
;; This technique does require an initial value or operating point for the variables 
;; so for the first simulation step, an iterative technique must be used.
;; Use a DASSL-like technique.






