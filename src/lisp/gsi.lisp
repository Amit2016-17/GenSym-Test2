;; -*- Mode: Lisp; Package: AB; Base: 10; Syntax: Common-Lisp -*-
(in-package "AB")

;;;; Module GSI

;;; Copyright (c) 1986 - 2017 Gensym Corporation.
;;; All Rights Reserved.

;;; Nick Caruso, Peter Fandel, John Hodgkinson



;;; File name:		     GSI.LISP
;;; File location:	     /bt/ab/lisp
;;; Code control:	     CVS
;;; Purpose:		     Support GSI extension product
;;; Contents:		     Various structure, function and other definitions
;;;			     supporting the GSI product that are unique to the
;;;			     GSI side of a GSI connection.
;;; This file depends on:    Preceding .LISP files in the system load ordering.
;;; Dependent files:	     Subsequent .LISP files in the system load ordering.
;;; Role in products:	     Delivered to customers in object form
;;;			     with other objects as the GSI toolkit product.
;;; Testing harness:	     Regression test harness: gsi-regress.kb
;;;			     Stress and individual regression tests: navigator.kb
;;;			       see Peter Fandel for details on the navigator.
;;;			     Some validation functions also included in here.
;;; Performace requirements: These functions and macros are the core of GSI
;;;			     dataservice.  Performance is critical.
;;;





;;;; Forward References

;; To GSI-RPC1
(declare-forward-reference gsi-rpc-return-values-internal function)
(declare-forward-reference reclaim-list-of-local-functions function)
;; To GSI-RPC2
(declare-forward-reference make-gsi-circularity-table function)
(declare-forward-reference gsi-make-appropriate-array function)
(declare-forward-reference simple-or-null-value-type-p function)
(declare-forward-reference simple-text-string-copy-from-attribute-name-1 function)


;;;; Constants

;; GSI error codes generated by 'GSI in Lisp' code.

(eval-when (:compile-toplevel :load-toplevel :execute)
(defconstant gsi-error-code-out-of-range -1)
(defconstant gsi-invalid-protocol                  1)
(defconstant gsi-invalid-network-combo             2)
(defconstant gsi-invalid-tcp-port-number           3)
(defconstant gsi-invalid-decnet-object-name        4)
(defconstant gsi-invalid-network-address           5)
(defconstant gsi-item-definitions-are-read-only    6)
(defconstant gsi-structure-has-no-handle           7)
(defconstant gsi-structure-has-no-identifying-attrs 8)
(defconstant gsi-structure-has-no-instance         9)
(defconstant gsi-structure-has-no-timestamp       10)
(defconstant gsi-structure-has-no-timed-flag      11)
(defconstant gsi-structure-has-no-interval        12)
(defconstant gsi-structure-has-no-status          13)
(defconstant gsi-structure-has-no-attribute-name  14)
(defconstant gsi-missing-instance-structure       15)
(defconstant gsi-incompatible-type                16)
(defconstant gsi-local-function-undefined         17)
(defconstant gsi-invalid-call-handle              18)
(defconstant gsi-remote-declaration-not-found     19)
(defconstant gsi-incorrect-argument-count         20)
(defconstant gsi-unexpected-operation             21)
(defconstant gsi-internal-memory-inconsistency    22)
(defconstant gsi-bad-magic-number                 23)
(defconstant gsi-invalid-context                  24)
(defconstant gsi-identifying-attribute-index-out-of-range 25)
(defconstant gsi-no-class-in-registered-item	  26)
(defconstant gsi-g2-logical-out-of-bounds	  27)
(defconstant gsi-missing-attribute-name		  28)
(defconstant gsi-count-out-of-array-bounds	  29)
(defconstant gsi-incompatible-structure		  30)
(defconstant gsi-structure-has-no-class-qualifier 31)
(defconstant gsi-no-class-name-specified	  32)
(defconstant gsi-argument-count-too-big		  33)
(defconstant gsi-rpc-error-from-g2		  34)
(defconstant gsi-rpc-error-from-g2-procedure	  35)
(defconstant gsi-reserved-error-code		  36)
(defconstant gsi-custom-user-error		  37)
(defconstant gsi-connection-lost		  38)
(defconstant gsi-ownerous-reclamation-violation	  39)
(defconstant gsi-null-pointer-argument		  40)
(defconstant gsi-item-has-no-value		  41)
(defconstant gsi-noop-code-accessed		  42)
(defconstant gsi-illegal-nesting-of-run-loop	  43)
(defconstant gsi-structure-has-no-history	  44)
(defconstant gsi-incompatible-history-spec	  45)
(defconstant gsi-invalid-type			  46)
(defconstant gsi-type-for-data-service		  47)
(defconstant gsi-bad-magic-number-in-query	  48)
(defconstant gsi-context-undefined		  49)
(defconstant gsi-invalid-handle			  50)
(defconstant gsi-invalid-handle-of-nth		  51)
(defconstant gsi-timestamp-out-of-bounds	  52)
(defconstant gsi-invalid-timestamp		  53)
(defconstant gsi-invalid-handle-for-context	  54)
(defconstant gsi-no-name-in-registered-item	  55)
(defconstant gsi-incompatible-structure2	  56)
(defconstant gsi-icp-message-too-long		  57)
(defconstant gsi-icp-message-out-of-synch-case-2  58)
(defconstant gsi-maximum-text-string-length-error 59)
(defconstant gsi-extend-current-text-string-error 60)
(defconstant gsi-undefined-structure-method-error 61)
(defconstant gsi-index-space-full-error		  62)
(defconstant gsi-circularity-not-supported	  63)
(defconstant gsi-no-more-rpc-identifiers	  64)
(defconstant gsi-bad-rpc-state			  65)
(defconstant gsi-malformed-socket		  66)
(defconstant gsi-unknown-type-tag		  67)
(defconstant gsi-invalid-history-type		  68)
(defconstant gsi-uncaught-exception		  69)
(defconstant gsi-cannot-establish-listener        70)
(defconstant gsi-maximum-contexts-exceeded        71)
(defconstant gsi-connection-denied                72)
(defconstant gsi-unknown-string-conversion-style  73)
(defconstant gsi-error-in-connect                 74)
(defconstant gsi-invalid-return-value-index       75)
(defconstant gsi-invalid-return-value-kind        76)
(defconstant gsi-invalid-attribute-type           77)
(defconstant gsi-resumable-icp-error              78)
(defconstant gsi-unknown-calling-procedure-index  79)
(defconstant gsi-illegal-error-arguments          80)
(defconstant gsi-integer-too-large                81)
(defconstant gsi-integer-too-small                82)
(defconstant gsi-not-a-symbol                     83)
(defconstant gsi-no-license                       84)
(defconstant gsi-context-has-been-killed          85)
(defconstant gsi-context-has-been-shut-down       86)
(defconstant gsi-callback-name-not-found          87)
(defconstant gsi-invalid-option-index             88)
(defconstant gsi-application-load-failed          89)
(defconstant gsi-network-error                    90)

(defconstant gsi-base-warning-code 256)
(defconstant gsi-attribute-name-not-found 256)
(defconstant gsi-timestamp-not-found 257)
(defconstant gsi-rpc-async-abort 258)
(defconstant gsi-rpc-late-async-abort 259)

(defconstant gsi-base-information-code 512) ; there is as yet no support
					    ; for these codes (i.e. no
					    ; gsi-inform internal function).
					    ;
(defconstant gsi-base-success-code 768)	    ; nor support for success messages
					    ; either. -ncc, 11 Jan 1995

(defconstant gsi-base-user-error-code 1024) ; Error codes above this number
					    ; are available to the user via
					    ; the gsi_signal_error API
					    ; function, which see.
)

;; Other constants

(eval-when (:compile-toplevel :load-toplevel :execute)

;; NOTA BENE
;;  The following two constants are defined both here
;;  and in the file "ext/c/gsi_main.h".	 They must agree.
;;   -ncc, 5/31/94
(defconstant gsi-success 0)
(defconstant gsi-failure 1)

(defconstant gsi-true 1)
(defconstant gsi-false 0)

;; initial-maximum-number-of-contexts:
;;
;; this is used to size the global array that tracks context usage,
;; gsi-context-number-table.  This variable could be renamed
;; default-maximum-number-of-contexts in the future, if this value becomes
;; user-specifiable.  -ncc, 3/6/95
;;
(defconstant initial-maximum-number-of-contexts 50)

(defconstant gsi-max-number-of-identifying-attributes 6)

)




;;;; Global and System Variables

(defvar next-available-context-number 0)
(defvar fake-array-of-one-wrapper nil)
(defvar reusable-circularity-table nil)
(defvar array-element-attribute-spec nil)
(defvar list-element-attribute-spec nil)
(defvar item-name-attribute-spec nil)
(defvar simple-item-value-attribute-spec nil)
(defvar reusable-name-instance nil)
(defvar reusable-value-instance nil)
(defvar within-run-loop-extent nil)
(defvar gsi-shutdown-reason nil)

;; Text strings associated with GSI errors.

(defparameter gsi-error-code-table
  '((#.gsi-error-code-out-of-range "Error Code out of range.")
    (#.gsi-invalid-protocol "Invalid network protocol ~a - only tcpip is supported")
    (#.gsi-invalid-network-combo "Duplication of network protocol ~a - please specify one of each")
    (#.gsi-invalid-tcp-port-number "Invalid TCP port number ~a - please specify an integer number")
    (#.gsi-invalid-decnet-object-name "DECnet is no longer supported (object name ~a)")
    (#.gsi-invalid-network-address "Invalid network address ~a - does not conform to TCP/IP")
    (#.gsi-item-definitions-are-read-only "Item registrations are read-only - make modifications through G2")
    (#.gsi-structure-has-no-handle "Access function received structure with no handle element") ;
    (#.gsi-structure-has-no-identifying-attrs "Access function received structure with no identifying attribute elements")
    (#.gsi-structure-has-no-instance "Access function received an incompatible structure as an argument")
    (#.gsi-structure-has-no-timestamp "Access function received structure with no timestamp element")
    (#.gsi-structure-has-no-timed-flag "Access function received structure with no is-timed element")
    (#.gsi-structure-has-no-interval "Access function received structure with no interval element")
    (#.gsi-structure-has-no-status "Access function received structure with no status element")
    (#.gsi-structure-has-no-attribute-name "Access function expected an attribute structure")
    (#.gsi-missing-instance-structure "Nothing was found where an embedded value or instance structure was expected")
    (#.gsi-incompatible-type "Type mismatch - value of type ~a passed to this function")
    (#.gsi-local-function-undefined "GSI could not find function ~a which G2 attempted to invoke")
    (#.gsi-invalid-call-handle "Call handle specified was not for an outstanding RPC")
    (#.gsi-remote-declaration-not-found "No remote procedure declaration was found for ~a. Ensure gsi_rpc_declare_remote() called")
    (#.gsi-incorrect-argument-count "Remote procedure ~a passed/received ~a arguments - ~a were expected")
    (#.gsi-unexpected-operation "This operation not thought to be useful and may imply a misunderstanding of GSI")
    (#.gsi-internal-memory-inconsistency "Internal memory inconsistency encountered in GSI - please contact customer support")
    (#.gsi-bad-magic-number "Bad magic number - address received was not the head of an array")
    (#.gsi-invalid-context "Context ~a is invalid or inactive")
    (#.gsi-identifying-attribute-index-out-of-range
     #.(ab-lisp::format nil
	"Identifying attribute index ~~a is out of the acceptable range (1..~D)"
	gsi-max-number-of-identifying-attributes))
    (#.gsi-no-class-in-registered-item "The class name is in the registration corresponding to the handle of this registered item")
    (#.gsi-g2-logical-out-of-bounds "Logical ~a is out of bounds. Logicals in GSI may range from -1000 to 1000 inclusive")
    (#.gsi-missing-attribute-name "Requested attribute name where there was none")
    (#.gsi-count-out-of-array-bounds "Count ~a out of bounds for array of size ~a")
    (#.gsi-incompatible-structure "Received null pointer argument, or a structure type incompatible with requested operation")
    (#.gsi-structure-has-no-class-qualifier "Requested class qualifier where there was none")
    (#.gsi-no-class-name-specified "Attempt to pass item without specifying class name")
    (#.gsi-argument-count-too-big "Argument count ~a too large for provided argument array of length ~a")
    (#.gsi-rpc-error-from-g2 "Remote procedure invocation failed with level ~a error: ~a")
    (#.gsi-rpc-error-from-g2-procedure "Invocation of remote procedure ~a failed with level ~a error:~%~a")
    (#.gsi-reserved-error-code "Reserved error code ~a signalled by user.  Codes below ~a are reserved")
    (#.gsi-custom-user-error "The following custom error has been signalled: ~a")
    (#.gsi-connection-lost "Connection was lost or ICP protocol error occurred: ~a")
    (#.gsi-ownerous-reclamation-violation "Attempted to reclaim a structure not owned (allocated) by user")
    (#.gsi-null-pointer-argument "Access function received null pointer argument")
    (#.gsi-item-has-no-value "Attempted to access value when none present - see GSI_NULL_TAG")
    (#.gsi-noop-code-accessed "Support for desired network transport type (TCP/IP) not linked in to your executable")
    (#.gsi-illegal-nesting-of-run-loop "Attempt to call gsi_run_loop from within the extent of a previous call to gsi_run_loop")
    (#.gsi-structure-has-no-history "Attempted to access history when none present - see gsi_history_count_of()")
    (#.gsi-invalid-type "Type code ~a is invalid - see documentation for valid type codes")
    (#.gsi-type-for-data-service "Type code ~a is invalid for return to data served variable")
    (#.gsi-incompatible-history-spec "Attempt to load ~a values into a history whose spec allows for no more than ~a")
    (#.gsi-bad-magic-number-in-query "Attempted to access non-existent data - perhaps reclaimed or never allocated?")
    (#.gsi-context-undefined "Context -1 is the undefined context - operation attempted outside of any context")
    (#.gsi-invalid-handle "The handle of the registered_item is invalid")
    (#.gsi-invalid-handle-of-nth "The handle of registered_items[~d] is invalid")
    (#.gsi-timestamp-out-of-bounds "Out-of-range timestamp seen:~%~
				    timestamp: ~d  Valid range: 0.0 < t < ~d")

    (#.gsi-invalid-timestamp "Invalid timestamp seen in timestamped object.")
    (#.gsi-invalid-handle-for-context "The handle ~a is not known in context ~a")
    (#.gsi-no-name-in-registered-item "The name is in the registration corresponding to the handle of this registered item")
    (#.gsi-incompatible-structure2 "Received null pointer argument, or incompatible type for second structure argument")
    (#.gsi-icp-message-too-long #.icp-message-too-long-warning)
    (#.gsi-icp-message-out-of-synch-case-2
     #.icp-message-out-of-synch-case-2-warning)
    (#.gsi-maximum-text-string-length-error
     #.maximum-text-string-length-exceeded-message)
    (#.gsi-extend-current-text-string-error
     #.extend-current-text-string-error-message)
    (#.gsi-undefined-structure-method-error
     #.undefined-structure-method-message)
    (#.gsi-index-space-full-error
     #.enlarge-index-space-error-message)
    (#.gsi-attribute-name-not-found "Could not find attribute with qualified name of ~a")
    (#.gsi-timestamp-not-found "No timestamp specified.	 The 0.0 value returned does not construe a valid timestamp")
    (#.gsi-rpc-async-abort "The local call to ~A made by G2 has been aborted by G2 - no values returned")
    (#.gsi-rpc-late-async-abort "An RPC has been aborted by the client before returning")
    (#.gsi-circularity-not-supported "Self referencing items may not yet be sent to G2 - sorry") ; ***delete this msg when feature is done.
    (#.gsi-no-more-rpc-identifiers "The limit of outstanding calls to G2 procedures has been reached")
    (#.gsi-bad-rpc-state "Internal state of RPC identifier is unknown.")
    (#.gsi-malformed-socket "GSI socket malformed- extension data missing")
    (#.gsi-unknown-type-tag "GSI structure contains unknown type tag.")
    (#.gsi-invalid-history-type "GSI found an invalid value type for this history.")
    (#.gsi-uncaught-exception "GSI uncaught exception.")
    (#.gsi-cannot-establish-listener "Could not make exact ICP connection.~%")
    (#.gsi-maximum-contexts-exceeded "Connection rejected - GSI bridge context limit (~d) exceeded.")
    (#.gsi-connection-denied "Connection denied - the G2 at ~a has disallowed connections from GSI")
    (#.gsi-no-license "No license is available for a connection over \"~a\".")
    (#.gsi-unknown-string-conversion-style "Unknown string conversion style")
    (#.gsi-error-in-connect "Error during connection attempt: ~a")
    (#.gsi-invalid-return-value-index "Invalid return value index")
    (#.gsi-invalid-return-value-kind "Invalid return value kind")
    (#.gsi-invalid-attribute-type "Invalid attribute type")
    (#.gsi-resumable-icp-error "~a")
    (#.gsi-unknown-calling-procedure-index "Unknown calling procedure index")
    (#.gsi-illegal-error-arguments "Illegal error arguments: ~a")
    (#.gsi-integer-too-large "gsi_int argument was larger than 536870911")
    (#.gsi-integer-too-small "gsi_int argument was smaller than -536870912")
    (#.gsi-not-a-symbol "Invalid gsi_symbol argument (use gsi_make_symbol)")
    (#.gsi-context-has-been-killed "Context ~a has been killed")
    (#.gsi-context-has-been-shut-down "Context ~a has been shut down")
    (#.gsi-callback-name-not-found "Invalid GSI callback name: ~A")
    (#.gsi-invalid-option-index "Invalid GSI option index: ~D")
    (#.gsi-application-load-failed "Failed to successfully load the application ~A")
    (#.gsi-network-error "Network error event: socket-handle is ~D, event-status is ~D")
    )
  )


(defmacro set-gsi-error-message (code &optional arg1 arg2 arg3 arg4 arg5 arg6)
  `(set-gsi-error-message-1 nil ,code ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6))


;;; gsi-scheduled-tasks-time-limit
;; the maximum interval during which the GSI scheduler will execute tasks
;; before returning control to the user.  This sets the maximum amount of time
;; that can be spent performing work inside gsi-run-loop. -ncc, 21 Apr 1997
;;  SEE ALSO gsi-set-run-loop-timeout for the user-visible setter for this
;; parameter.
(defvar gsi-scheduled-tasks-time-limit (fixnum-time-interval 200))


(defun-simple gsi-priority-of-data-service-function ()
  4)



(defmacro def-gsi-toolkit-function (name-and-options &rest arg-specs)
  (let* ((name (if (atom name-and-options)
		   name-and-options
		   (car name-and-options)))
	 (options (if (atom name-and-options)
		      nil
		      (cdr name-and-options)))
	 (return-type (or (cadr (assq ':return-type options)) ':object))
	 (inline-name (intern (format nil "INLINE-CALL-~A" name)))
	 (inline-name-non-c (intern (format nil "INLINE-CALL-~A-NON-C" name)))
	 (macro-name (intern (format nil "CALL-~A" name)))
	 (macro-name-non-c (intern (format nil "CALL-~A-NON-C" name)))
	 (args (loop for arg in arg-specs
		     collect (if (atom arg) arg (car arg)))))
    (if (null args)
	`(progn
	   (def-inlined-pseudo-function-with-side-effects (,inline-name ,return-type)
	       ((function :object))
	     (funcall function))
	   (defmacro ,macro-name (function)
	     `(,',inline-name ,function)))
	`(progn
	   (def-inlined-pseudo-function-with-side-effects (,inline-name ,return-type)
	       ((function :object) ,@arg-specs)
	     (funcall function ,@args))
	   (defmacro ,macro-name (function ,@args)
	     `(,',inline-name ,function ,@(list ,@args)))
	   (def-inlined-pseudo-function-with-side-effects (,inline-name-non-c ,return-type)
	       ((function :object) ,@(loop for arg in args
					   collect `(,arg :object)))
	     (funcall function ,@args))
	   (defmacro ,macro-name-non-c (function ,@args) ; :object :fixnum-long :string
	     `(,',inline-name ,function ,@(list ,@args)))))))

(def-gsi-toolkit-function (gsi-set-up
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-get-tcp-port
			    (:return-type :fixnum-long)))

(def-gsi-toolkit-function (gsi-pause-context
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-resume-context
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-start-context
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-reset-context
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-shutdown-context
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-g2-poll
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-watchdog-function
			    (:return-type :null)))

(def-gsi-toolkit-function (gsi-initialize-context
			    (:return-type :fixnum-long))
    (rpis	 :string)
    (rpis-length :fixnum-long))

(def-gsi-toolkit-function (gsi-receive-registration
			    (:return-type :null))
    (item-definition  :object))

(def-gsi-toolkit-function (gsi-receive-deregistrations
			    (:return-type :null))
    (transfer-wrappers :object)
    (count	       :fixnum-long))

(def-gsi-toolkit-function (gsi-get-data
			    (:return-type :null))
    (transfer-wrappers :object)
    (count	       :fixnum-long))

(def-gsi-toolkit-function (gsi-set-data
			    (:return-type :null))
    (transfer-wrappers :object)
    (count	       :fixnum-long))


(def-gsi-toolkit-function (gsi-receive-message
			    (:return-type :null))
    (message	  :string)
    (length	  :fixnum-long))

(def-gsi-toolkit-function (gsi-error-handler
			    (:return-type :null))
    (error-context :fixnum-long)
    (error-code    :fixnum-long)
    (error-message :string))

(def-gsi-toolkit-function (gsi-run-state-change
			    (:return-type :null))
    (direction-code :fixnum-long)
    (type-code      :fixnum-long)
    (name           :string))

(def-gsi-toolkit-function (gsi-missing-procedure-handler
			    (:return-type :null))
    (name :string))

(def-gsi-toolkit-function (gsi-read-callback
			    (:return-type :null))
    (context   :fixnum-long)
    (readable? :fixnum-long))

(def-gsi-toolkit-function (gsi-write-callback
			    (:return-type :null))
    (context   :fixnum-long)
    (writable? :fixnum-long))

(def-gsi-toolkit-function (gsi-open-fd
			    (:return-type :null))
    (fd        :fixnum-long))

(def-gsi-toolkit-function (gsi-close-fd
			    (:return-type :null))
    (fd        :fixnum-long))

(def-gsi-toolkit-function (gsi-writing-fd
			    (:return-type :null))
    (fd        :fixnum-long))

(def-gsi-toolkit-function (gsi-not-writing-fd
			    (:return-type :null))
    (fd        :fixnum-long))

(def-gsi-toolkit-function (gsi-idle
			    (:return-type :null)))


(defconstant gsi-run-state-direction-entering-gsi 1)
(defconstant gsi-run-state-direction-leaving-gsi 2)
(defconstant gsi-run-state-direction-entering-watchdog 3)
(defconstant gsi-run-state-direction-leaving-watchdog 4)
(defconstant gsi-run-state-direction-entering-gsi-by-signal 5)

(defconstant gsi-run-state-type-api 1)
(defconstant gsi-run-state-type-callback 2)
(defconstant gsi-run-state-type-wait 3)
(defconstant gsi-run-state-type-signal 4)

(defmacro gsi-call-run-state-change (direction type name)
  `(call-gsi-callback gsi-run-state-change ,direction ,type ,name))


(defmacro entering-gsi-api-callback (name-symbol) ; `(gsi-call-wait-handler 0)
  `(gsi-call-run-state-change gsi-run-state-direction-entering-gsi
			      gsi-run-state-type-api
			      ,(string-downcase (substitute #\_ #\- (symbol-name name-symbol)))))

(defmacro leaving-gsi-api-callback (name-symbol) ; `(gsi-call-wait-handler 1)
  `(gsi-call-run-state-change gsi-run-state-direction-leaving-gsi
			      gsi-run-state-type-api
			      ,(string-downcase (substitute #\_ #\- (symbol-name name-symbol)))))

(defmacro calling-gsi-callback-callback (string) ; See gsiannex.c
  `(gsi-call-run-state-change gsi-run-state-direction-leaving-gsi
			      gsi-run-state-type-callback
			      ,string))

(defmacro returning-from-gsi-callback-callback (string) ; See gsiannex.c
  `(gsi-call-run-state-change gsi-run-state-direction-entering-gsi
			      gsi-run-state-type-callback
			      ,string))

(defmacro before-gsi-wait-callback () ; `(gsi-call-wait-handler 1)
  `(gsi-call-run-state-change gsi-run-state-direction-leaving-gsi
			      gsi-run-state-type-wait
			      "gsi_wait"))

(defmacro after-gsi-wait-callback () ; `(gsi-call-wait-handler 0)
  `(gsi-call-run-state-change gsi-run-state-direction-entering-gsi
			      gsi-run-state-type-wait
			      "gsi_wait"))

(defmacro entering-gsi-signal-handler-callback ()
  `(gsi-call-run-state-change gsi-run-state-direction-entering-gsi-by-signal
			      gsi-run-state-type-signal
			      "gsi_signal_handler"))

(defun-void entering-signal-handler-function ()
  (entering-gsi-signal-handler-callback))

(defun-void call-gsi-open-fd-callback (fd)
  (call-gsi-callback gsi-open-fd fd))

(defun-void call-gsi-close-fd-callback (fd)
  (call-gsi-callback gsi-close-fd fd))

(defun-void call-gsi-writing-fd-callback (fd)
  (call-gsi-callback gsi-writing-fd fd))

(defun-void call-gsi-not-writing-fd-callback (fd)
  (call-gsi-callback gsi-not-writing-fd fd))


;global options
;  one cycle, use gfloats, non c, no signal handlers, trace run state

;per-application options:
; string check, suppress output, wide string api, user data for callbacks,
; no flush, new symbol api, use references

(defvar gsi-global-option-array
  (let ((option-array (make-array gsi-number-of-options :initial-element ':local)))
    (setf (svref option-array gsi-one-cycle) nil)
    (setf (svref option-array gsi-use-gfloats) nil)
    (setf (svref option-array gsi-no-signal-handlers) nil)
    (setf (svref option-array gsi-trace-run-state) nil)
    option-array))

(defvar callback-is-global-array
  (let ((array (make-array gsi-number-of-callbacks)))
    (setf (svref array gsi-set-up) t)
    ;;(setf (svref array gsi-get-tcp-port) t) ;?
    (setf (svref array gsi-read-callback) t) ;?
    (setf (svref array gsi-write-callback) t) ;?
    (setf (svref array gsi-open-fd) t)
    (setf (svref array gsi-close-fd) t)
    (setf (svref array gsi-writing-fd) t)
    (setf (svref array gsi-not-writing-fd) t)
    (setf (svref array gsi-error-handler) t) ; if there is no context for the error
    (setf (svref array gsi-run-state-change) t)
    (setf (svref array gsi-idle) t)
    array))

(eval-when (:compile-toplevel :load-toplevel :execute)
(defvar gsi-callback-name-symbol-array
  '#(|gsi_set_up| |gsi_get_tcp_port| |gsi_pause_context| |gsi_resume_context|
     |gsi_shutdown_context| |gsi_g2_poll| |gsi_read_callback| |gsi_write_callback|
     |gsi_open_fd| |gsi_close_fd| |gsi_initialize_context| |gsi_receive_registration|
     |gsi_receive_deregistrations| |gsi_get_data| |gsi_set_data| |gsi_receive_message|
     |gsi_run_state_change| |gsi_error_handler| |gsi_missing_procedure_handler|
     nil ; |gsi_watchdog_function| needs a timeout, too.
     |gsi_idle| |gsi_start_context| |gsi_reset_context|
     |gsi_writing_fd| |gsi_not_writing_fd|))

(defvar gsi-callback-name-string-array
  '#("gsi_set_up" "gsi_get_tcp_port" "gsi_pause_context" "gsi_resume_context"
     "gsi_shutdown_context" "gsi_g2_poll" "gsi_read_callback" "gsi_write_callback"
     "gsi_open_fd" "gsi_close_fd" "gsi_initialize_context" "gsi_receive_registration"
     "gsi_receive_deregistrations" "gsi_get_data" "gsi_set_data" "gsi_receive_message"
     "gsi_run_state_change" "gsi_error_handler" "gsi_missing_procedure_handler"
     "gsi_watchdog_function" "gsi_idle" "gsi_start_context" "gsi_reset_context"
     "gsi_writing_fd" "gsi_not_writing_fd"))
)

(defmacro define-gsi-callback-name-function (name-string)
  `(def-gsi-api-function (,(intern
			     (string-upcase
			       (substitute
				 #\- #\_
				 (format nil "gsin_~a"
					 (subseq name-string 4)))))
			   (:return-type gsi-api-symbol)
			   (:initializes-gsi t)
			   (:needs-catch-p nil))
                         ()
     ',(intern name-string)))

(defmacro define-gsi-callback-name-functions ()
  `(progn ,@(loop for i from 0 below (length gsi-callback-name-string-array)
		  for name-string = (svref gsi-callback-name-string-array i)
		  collect `(define-gsi-callback-name-function ,name-string))))

(define-gsi-callback-name-functions)

(defun-simple allocate-initialized-managed-simple-vector (size)
  (let ((array (allocate-managed-simple-vector size)))
    (loop for i from 0 below size
	  do (setf (svref array i) nil))
    array))

(def-structure (gsi-application
		 (:constructor make-gsi-application
			       (gsi-application-name-symbol)))
  gsi-application-name-symbol
  (gsi-application-option-array
    (allocate-initialized-managed-simple-vector gsi-number-of-options)
    :reclaimer reclaim-managed-simple-vector)
  (gsi-application-callback-array
    (allocate-initialized-managed-simple-vector gsi-number-of-callbacks)
    :reclaimer reclaim-managed-simple-vector)
  (gsi-local-functions
    nil :reclaimer reclaim-list-of-local-functions)
  (gsi-error-variable-location nil)
  (gsi-watchdog-task
    nil :reclaimer cancel-task)
  (gsi-application-last-converted-string
    nil :reclaimer reclaim-if-text-or-gensym-string))

;; list of local (C) functions declared by a GSI bridge to be invocable
;; remotely (by G2).

(defvar loadable-bridges-enabled-p nil)

(def-system-variable have-default-gsi-application gsi nil nil t)

(def-system-variable default-gsi-application gsi
  (:funcall make-default-gsi-application))

(defun-simple make-default-gsi-application ()
  (cond (have-default-gsi-application
	 default-gsi-application)
	(t
	 (setq have-default-gsi-application t)
	 (make-gsi-application 'default))))

(defvar all-gsi-applications nil)

(defvar current-gsi-application nil)

(defun-simple gsi-application-for-socket (icp-socket)
  (let* ((socket-extension-data?
	  (or (gsi-extension-data? icp-socket)
	      (return-from gsi-application-for-socket nil)))
	 (application
	   (gsi-extension-application socket-extension-data?)))
    (when application
      (return-from gsi-application-for-socket application))
    (loop for application-name = (or (gsi-application-name-symbol current-icp-socket)
				     'default)
	  for gsi-application in all-gsi-applications
	  when (eq (gsi-application-name-symbol gsi-application) application-name)
	    do (setq application gsi-application)
	  finally (setq application default-gsi-application))
    (setf (gsi-extension-application socket-extension-data?) application)
    application))

(defun-simple current-gsi-application ()
  (or (when current-icp-socket
	(gsi-application-for-socket current-icp-socket))
      current-gsi-application
      default-gsi-application))

(defun-simple find-or-load-gsi-application (name)
  (when (or (null name) (eq name 'default))
    (return-from find-or-load-gsi-application default-gsi-application))
  (loop for gsi-application in all-gsi-applications
	when (eq (gsi-application-name-symbol gsi-application) name)
	  do (return-from find-or-load-gsi-application gsi-application))
  (if loadable-bridges-enabled-p
      (load-gsi-application name)
      default-gsi-application))

(defun-void set-gsi-current-application (application)
  (let ((socket-extension-data?
	  (when current-icp-socket
	    (gsi-extension-data? current-icp-socket))))
    (if socket-extension-data?
	(setf (gsi-extension-application socket-extension-data?) application)
	(setq current-gsi-application application))))


(def-side-effect-free-inlined-pseudo-function inline-gsi-api-function-array ()
  nil)

(defun-simple load-library-for-gsi (name)
  (let* (#+development
	 (load-lisp-p nil)
	 (downcased-symbol-name-text
	   (tformat-text-string "~(~A~)" name))
	 (pathname (gensym-make-pathname :name downcased-symbol-name-text))
	 (shared-pathname (pathname->shared-file-pathname pathname))
	 (namestring-as-gensym-string
	   (namestring-as-gensym-string shared-pathname)))
    (prog1 (load-library
	     namestring-as-gensym-string
	     "gsi_set_options_from_compile"
	     (inline-gsi-api-function-array))
      (reclaim-text-string downcased-symbol-name-text)
      (reclaim-gensym-pathname pathname)
      (reclaim-gensym-pathname shared-pathname))))

(defun-simple load-gsi-application (name)
  (when loadable-bridges-enabled-p
    (let ((application (make-gsi-application name)))
      (gsi-push application all-gsi-applications)
      (set-gsi-current-application application)
      (cond ((not (load-library-for-gsi name))
	     (setq all-gsi-applications (delete-gsi-element application all-gsi-applications))
	     (reclaim-gsi-application application)
	     (set-gsi-current-application nil)
	     (gsi-warning 'load-gsi-application gsi-application-load-failed name)
	     nil)
	    (t
	     (let ((function (svref (gsi-application-callback-array application) gsi-set-up)))
	       (when function
		 (calling-gsi-callback-callback "gsi_set_up")
		 (call-gsi-set-up function)
		 (returning-from-gsi-callback-callback "gsi_set_up")))
	     application)))))

(def-gsi-api-function (gsi-set-current-application
			(:return-type :null)
			(:initializes-gsi t))
                      ((application-name gsi-api-symbol))
  (cond
    ((or (null application-name) (eq application-name 'default))
     (setq current-gsi-application nil))
    (t
     (set-gsi-current-application
       (loop for gsi-application in all-gsi-applications
	     when (eq (gsi-application-name-symbol gsi-application) application-name)
	       return gsi-application
	     finally (let ((application (make-gsi-application application-name)))
		       (gsi-push application all-gsi-applications)
		       (return application)))))))

(def-gsi-api-function (gsi-initialize-callback
			(:return-type :null)
			(:initializes-gsi t))
                      ((name     gsi-api-symbol)
		       (function :object))
  (unless name
    (gsi-api-error gsi-callback-name-not-found name))
  (setf (svref (gsi-application-callback-array (current-gsi-application))
	       (loop for i from 0 below (length gsi-callback-name-symbol-array)
		     when (eq name (svref gsi-callback-name-symbol-array i))
		       return i
		     finally (gsi-api-error gsi-callback-name-not-found name)))
	function))

; pending-gsi-callbacks is for callbacks outside of with-system-variables (gsi-open-fd)
(defvar pending-gsi-callbacks nil)
(defvar enable-global-errors nil)

(defun call-gsi-callback (callback-index &optional arg1 arg2 arg3)
  (unless have-default-gsi-application
    (with-permanent-allocation
      (push (list callback-index arg1 arg2 arg3) pending-gsi-callbacks))
    (return-from call-gsi-callback nil))
  (when pending-gsi-callbacks
    (loop for (callback-index arg1 arg2 arg3) in (prog1 (nreverse pending-gsi-callbacks)
						   (setq pending-gsi-callbacks nil))
	  do (call-gsi-callback callback-index arg1 arg2 arg3)))
  (loop with gsi-run-state-change-p = (=f gsi-run-state-change callback-index)
	with name-string = (svref gsi-callback-name-string-array callback-index)
	with global-p = (if (=f callback-index gsi-error-handler)
			    (not (and current-icp-socket
				      enable-global-errors
				      (gsi-application-for-socket current-icp-socket)))
			    (svref callback-is-global-array callback-index))
	with result = (case callback-index
			(#.gsi-get-tcp-port 0)
			(#.gsi-initialize-context 0)
			(t nil))
	for application       = (if global-p
				    default-gsi-application
				    (current-gsi-application))
			      then (first applications-tail)
	for applications-tail = (if global-p
				    all-gsi-applications
				    nil)
			      then (cdr applications-tail)
	for function = (svref (gsi-application-callback-array application) callback-index)
	do
    (when function
      (unless gsi-run-state-change-p
	(calling-gsi-callback-callback name-string))
      (fixnum-case callback-index
	(#.gsi-set-up            (call-gsi-set-up function))
	(#.gsi-get-tcp-port      (setq result (call-gsi-get-tcp-port function)))
	(#.gsi-pause-context     (call-gsi-pause-context function))
	(#.gsi-resume-context    (call-gsi-resume-context function))
	(#.gsi-start-context     (call-gsi-start-context function))
	(#.gsi-reset-context     (call-gsi-reset-context function))
	(#.gsi-shutdown-context  (call-gsi-shutdown-context function))
	(#.gsi-g2-poll           (call-gsi-g2-poll function))
	(#.gsi-watchdog-function (call-gsi-watchdog-function function))
	(#.gsi-idle              (call-gsi-idle function))
	(t
	  (if (svref (gsi-application-option-array application) gsi-non-c)
	      (fixnum-case callback-index
		(#.gsi-read-callback
		   (call-gsi-read-callback-non-c function arg1 arg2))
		(#.gsi-write-callback
		   (call-gsi-write-callback-non-c function arg1 arg2))
		(#.gsi-open-fd
		   (call-gsi-open-fd-non-c function arg1))
		(#.gsi-close-fd
		   (call-gsi-close-fd-non-c function arg1))
		(#.gsi-writing-fd
		   (call-gsi-writing-fd-non-c function arg1))
		(#.gsi-not-writing-fd
		   (call-gsi-not-writing-fd-non-c function arg1))
		(#.gsi-initialize-context
		   (setq result (call-gsi-initialize-context-non-c function arg1 arg2)))
		(#.gsi-receive-registration
		   (call-gsi-receive-registration-non-c function arg1))
		(#.gsi-receive-deregistrations
		   (call-gsi-receive-deregistrations-non-c function arg1 arg2))
		(#.gsi-get-data
		   (call-gsi-get-data-non-c function arg1 arg2))
		(#.gsi-set-data
		   (call-gsi-set-data-non-c function arg1 arg2))
		(#.gsi-receive-message
		   (call-gsi-receive-message-non-c function arg1 arg2))
		(#.gsi-run-state-change
		   (call-gsi-run-state-change-non-c function arg1 arg2 arg3))
		(#.gsi-error-handler
		   (call-gsi-error-handler-non-c function arg1 arg2 arg3))
		(#.gsi-missing-procedure-handler
		   (call-gsi-missing-procedure-handler-non-c function arg1)))
	      (fixnum-case callback-index
		(#.gsi-read-callback
		   (call-gsi-read-callback function arg1 arg2))
		(#.gsi-write-callback
		   (call-gsi-write-callback function arg1 arg2))
		(#.gsi-open-fd
		   (call-gsi-open-fd function arg1))
		(#.gsi-close-fd
		   (call-gsi-close-fd function arg1))
		(#.gsi-writing-fd
		   (call-gsi-writing-fd function arg1))
		(#.gsi-not-writing-fd
		   (call-gsi-not-writing-fd function arg1))
		(#.gsi-initialize-context
		   (setq result (call-gsi-initialize-context function arg1 arg2)))
		(#.gsi-receive-registration
		   (call-gsi-receive-registration function arg1))
		(#.gsi-receive-deregistrations
		   (call-gsi-receive-deregistrations function arg1 arg2))
		(#.gsi-get-data
		   (call-gsi-get-data function arg1 arg2))
		(#.gsi-set-data
		   (call-gsi-set-data function arg1 arg2))
		(#.gsi-receive-message
		   (call-gsi-receive-message function arg1 arg2))
		(#.gsi-run-state-change
		   (call-gsi-run-state-change function arg1 arg2 arg3))
		(#.gsi-error-handler
		   (call-gsi-error-handler function arg1 arg2 arg3))
		(#.gsi-missing-procedure-handler
		   (call-gsi-missing-procedure-handler function arg1))))))
      (unless gsi-run-state-change-p
	(returning-from-gsi-callback-callback name-string)))
	while applications-tail
	finally (return result)))

;static char *direction_names[] = {
;  ">> entering gsi", "<< leaving gsi",
;  ">> entering watchdog", "<< leaving watchdog",
;  ">> entering gsi by signal"
;};
;static char *type_names[] = {"api", "callback", "wait", "signal"};

;  if (gsi_options[GSI_TRACE_RUN_STATE])
;    printf("%s:  %s [%s]\n", direction_names[direction_code-1], type_names[type_code-1], name);


;This doesn't work when the user has control;
;and doesn't allow for GSI exceeding its time slice.
;(However, the C version only worked in VMS.  It had no WIN32 code,
; and its UNIX code stopped working in 5.0, since the scheduler uses SIGALRM.)
;To do:
;  Extend our SIGALRM handler, to have knowledge of all the watchdog callbacks and times.
;  On NT, have a separate thread for the watchdogs.
;  On VMS, what?
(def-gsi-api-function (gsi-watchdog
			(:return-type :null)
			(:initializes-gsi t))
                      ((function :object)
		       (period   :fixnum-int))
  (let ((application (current-gsi-application)))
    (cancel-task (gsi-watchdog-task application))
    (setf (svref (gsi-application-callback-array application)
		 gsi-watchdog-function)
	  function)
    (when (<f 0 period)
      (with-future-scheduling ((gsi-watchdog-task application)
			       highest-system-priority
			       (+e (float period)
				   (managed-float-value (clock-get current-real-time)))
			       nil nil t)
	(handle-watchdog-task application)))))

(defun-void handle-watchdog-task (application)
  (cancel-task (gsi-watchdog-task application))
  (call-gsi-callback gsi-watchdog-function))

(def-gsi-api-function (gsi-initialize-error-variable
			(:return-type :null)
			(:initializes-gsi t))
                      ((error-variable-location :object))
  (setf (gsi-error-variable-location (current-gsi-application))
	error-variable-location))

(defvar gsi-wide-api-p nil)

(defvar gsi-use-references-p nil)

(defvar gsi-references-in-use 0)

(defun-simple set-gsi-option (option-index value)
  (unless (and (<=f 0 option-index)
	       (<f option-index gsi-number-of-options))
    (return-from set-gsi-option nil))
  (setf (svref (if (eq ':local (svref gsi-global-option-array option-index))
		   (gsi-application-option-array (current-gsi-application))
		   gsi-global-option-array)
	       option-index)
	value)
  (case option-index
    #+chestnut-trans
    (#.gsi-suppress-output      (setq trun:*gc-silence* value))
    (#.gsi-wide-string-api      (setq gsi-wide-api-p value))
    (#.gsi-use-references       (setq gsi-use-references-p value)
				(setq gsi-references-in-use
				      (if gsi-use-references-p 1 0)))
    (#.gsi-protect-inner-calls  (setq gsi-protect-inner-calls-p value)))
  t)

(defun-simple default-owner-for-gsi-objects ()
  (if (gsi-option-is-set-p gsi-user-owns-gsi-items)
      'user
      'gsi))

(def-gsi-api-function (gsi-set-option
			(:return-type :null)
			(:initializes-gsi t))
                      ((option-index :fixnum-int))
  (unless (set-gsi-option option-index t)
    (gsi-api-error gsi-invalid-option-index option-index)))

(def-gsi-api-function (gsi-reset-option
			(:return-type :null)
			(:initializes-gsi t))
                      ((option-index :fixnum-int))
  (unless (set-gsi-option option-index nil)
    (gsi-api-error gsi-invalid-option-index option-index)))

(def-gsi-api-function (gsi-option-is-set
			(:return-type :fixnum-int)
			(:initializes-gsi t))
                      ((option-index :fixnum-int))
  (unless (and (<=f 0 option-index)
	       (<f option-index gsi-number-of-options))
    (gsi-api-error gsi-invalid-option-index option-index))
  (if (svref (if (eq ':local (svref gsi-global-option-array option-index))
		 (gsi-application-option-array (current-gsi-application))
		 gsi-global-option-array)
	     option-index)
      1 0))

(defun-simple gsi-option-is-set-p (option-index)
  (=f (gsi-option-is-set option-index) 1))

(defun-simple filter-text-for-gsi-p ()
  (gsi-option-is-set-p gsi-string-check))



(defvar in-error-handler nil)

(defun-allowing-unwind gsi-handle-error-1 (originating-function severity inhibit-non-local-exit-p)
  (unless (gsi-option-is-set-p gsi-suppress-output)
    (notify-user-if-possible "~%~a ~a occurred in ~a"
			     (if (eq severity 'warning) "Warning" "Error")
			     gsi-most-recent-error
			     originating-function)
    (notify-user-if-possible "~%  ~a~%~%" gsi-most-recent-error-message))

  ;; User error handling function signature:
  ;;  void myerf(connection_which_errored, error_code, error_text)
  (if in-error-handler
      (notify-user-if-possible
	"~%Not calling the user error handler, because a user error handler is already running.~2%")
      (let ((in-error-handler t)) ; avoid an infinite recursion
	(with-scheduler-disabled
	  (call-gsi-callback gsi-error-handler
			     (gsi-current-context-number)
			     gsi-most-recent-error
			     gsi-most-recent-error-message))))

  (unless inhibit-non-local-exit-p
    (case severity
      ((fatal)
       (g2-unrecoverable-error-exit))
      ((error)
       (gsi-continue-from-error))
      ((connection)
       (shutdown-icp-socket-connection current-icp-socket)
       (gsi-continue-from-error))
      ((warning nil)
       nil))))

(defun-simple clear-gsi-error-message ()
  (cond ((gensym-string-p gsi-most-recent-error-message)
	 (reclaim-gensym-string gsi-most-recent-error-message))
	((text-string-p gsi-most-recent-error-message)
	 (reclaim-text-string gsi-most-recent-error-message)))
  (setq gsi-most-recent-error-remote-procedure-identifier nil)
  (setq gsi-most-recent-error-message nil))

(defmacro gsi-set-most-recent-error (new-error-code)
  `(let ((code ,new-error-code))
     (clear-gsi-error-message)
     (setq gsi-most-recent-error code)
     (setq gsi-most-recent-error-remote-procedure-identifier
	   current-remote-procedure-identifier)
     (let ((error-variable-location
	     (gsi-error-variable-location (current-gsi-application))))
       (when error-variable-location
	 (inline-set-gsi-error-variable error-variable-location code)
	 t))))

(defun-simple set-gsi-error-message-1 (signal-or-internal-error? error-code arg1 arg2 arg3 arg4 arg5 arg6)
  (let* ((error-message?
	   (if (=f error-code gsi-custom-user-error)
	       nil
	       (second (assq error-code gsi-error-code-table))))
	 (adjusted-error-code
	   (if (=f error-code gsi-custom-user-error)
	       arg1
	       error-code)))
    (prog1 (gsi-set-most-recent-error adjusted-error-code)
      (setq gsi-most-recent-error-message
	    (cond (signal-or-internal-error?
		   (copy-constant-wide-string #w"A signal has been caught, or an internal error has occurred"))
		  (error-message?
		   (apply #'tformat-text-string error-message? arg1 arg2 arg3 arg4 arg5 arg6))
		  ((gensym-string-p arg2)
		   (copy-gensym-string arg2))
		  ((text-string-p arg2)
		   (copy-text-string arg2))
		  (t
		   (tformat-text-string
		     "~%Undefined error - please notify Gensym customer support.~%~%"))))
      (unless (or (using-wide-gsi-api-p)
		  (gensym-string-p gsi-most-recent-error-message))
	(setq gsi-most-recent-error-message
	      (prog1 (wide-string-to-gensym-string-for-gsi gsi-most-recent-error-message)
		(reclaim-text-string gsi-most-recent-error-message)))))))

(defmacro gsi-handle-error (originating-function
			     &optional signal-or-internal-error? severity error-code
			     arg1 arg2 arg3 arg4 arg5 arg6)
  `(progn
     (set-gsi-error-message-1 ,signal-or-internal-error? ,error-code
			      ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6)
     (gsi-handle-error-1 ,originating-function ,severity nil)))

(defmacro gsi-handle-error-no-exit (originating-function
			     &optional signal-or-internal-error? severity error-code
			     arg1 arg2 arg3 arg4 arg5 arg6)
  `(progn
     (set-gsi-error-message-1 ,signal-or-internal-error? ,error-code
			      ,arg1 ,arg2 ,arg3 ,arg4 ,arg5 ,arg6)
     (gsi-handle-error-1 ,originating-function ,severity t)))


;;;; GSI Supporting Macros	 (see GSI-COMMON for more)


(defmacro get-resumable-reclaim-list ()
  '(receiving-rpc-arglist-reclaim-list
    (enclosing-rpc-arglist-structure?
      current-receiving-resumable-object)))

(defmacro gsi-null-c-pointer-p (c-pointer)
  `(not ,c-pointer))



(defun c-string-to-gsi-string (c-string)
  (if (using-wide-gsi-api-p)
      (c-string-to-text-string c-string)
      (c-string-to-gensym-string c-string)))

(defun c-wide-string-to-gsi-string (c-wide-string)
  (if (using-wide-gsi-api-p)
      (c-wide-string-to-text-string c-wide-string)
      (c-wide-string-to-gensym-string c-wide-string)))

(defun convert-value-to-gsi-value (value)
  #+development
  (when (gensym-string-p value)
    (error "convert-value-to-gsi-value: ~S is a gensym-string:" value))
  (unless (and (text-string-p value)
	       (not (using-wide-gsi-api-p)))
    (return-from convert-value-to-gsi-value value))
  (prog1 (wide-string-to-gensym-string-for-gsi value)
    (reclaim-text-string value)))

(defun-simple convert-gsi-value-to-value (value)
  (if (not (gensym-string-p value))
      value
      (gensym-string-to-wide-string-for-gsi value)))


(defparameter gsi-text-conversion-style-list
  '(utf-g       iso-8859-1 iso-8859-2 iso-8859-3 iso-8859-4
    iso-8859-5  iso-8859-6 iso-8859-7 iso-8859-8 iso-8859-9
    iso-8859-10 us-ascii
    (jis-x-0208 :han-unification-mode japanese) ; 12
    (jis-x-0208-euc :han-unification-mode japanese) ; 13
    (shift-jis-x-0208 :han-unification-mode japanese) ; 14
    (ks-c-5601 :han-unification-mode korean) ; 15
    (ks-c-5601-euc :han-unification-mode korean) ; 16
    unicode-utf-7 ; 17
    unicode-utf-8 ; 18
    (x-compound-text ; 19
     :han-unification-mode japanese
     :unicode-line-separator-export-translation LF)
    (gb-2312 :han-unification-mode chinese) ; 20
    (gb-2312-euc :han-unification-mode chinese) ; 21
))

(defun-simple make-transcode-purpose-array (wide-p style-list)
  (loop	with array = (make-array (length style-list))
	with string-type-for-export = (if wide-p 'wide-string 'gensym-string)
	for i from 0
	for style in style-list
	for external-character-set = (if (consp style) (car style) style)
	for plist = (if (consp style) (cdr style) nil)
	for unicode-line-separator-export-translation
	    = (getfq plist ':unicode-line-separator-export-translation)
	for han-unification-mode
	    = (getfq plist ':han-unification-mode)
	do
    (setf (svref array i)
	  (create-transcode-text-conversion-style
	    nil
	    nil external-character-set nil
	    unicode-line-separator-export-translation han-unification-mode
	    string-type-for-export))
	finally (return array)))

(defvar gsi-gensym-string-text-conversion-style-array
  (make-transcode-purpose-array
    nil
    gsi-text-conversion-style-list))

(defvar gsi-wide-string-text-conversion-style-array
  (make-transcode-purpose-array
    t
    gsi-text-conversion-style-list))

(defun-simple text-conversion-style-for-gsi (style-code wide-string-p)
  (let ((array (if wide-string-p
		   gsi-wide-string-text-conversion-style-array
		   gsi-gensym-string-text-conversion-style-array)))
    (when (and (fixnump style-code)
	       (<=f 0 style-code)
	       (<f style-code (length array)))
      (svref array style-code))))

(defparameter current-gsi-string-conversion-style-code nil)

(defun-simple current-gsi-string-conversion-style ()
  (if (using-wide-gsi-api-p)
      0
      (or current-gsi-string-conversion-style-code
	  (if (filter-text-for-gsi-p)
	      1     ;'iso-8859-1-gensym-string
	      0)))) ;'utf-g-gensym-string

(def-gsi-api-function (gsi-string-conversion-style
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
                      ()
  (current-gsi-string-conversion-style))

(def-gsi-api-function (gsi-set-string-conversion-style
			(:return-type :null)
			(:needs-catch-p nil))
		      ((style	gsi-fixnum-long))
  (if (text-conversion-style-for-gsi style (using-wide-gsi-api-p))
      (setq current-gsi-string-conversion-style-code style)
      (gsi-api-error gsi-unknown-string-conversion-style)))

(defun-simple gsi-last-converted-string ()
  (let* ((icp-socket current-icp-socket)
	 (socket-extension-data?
	  (when icp-socket
	    (gsi-extension-data? icp-socket))))
    (if socket-extension-data?
	(gsi-extension-last-converted-string socket-extension-data?)
	(gsi-application-last-converted-string
	  (or current-gsi-application default-gsi-application)))))

(defun-simple gsi-set-last-converted-string (string)
  (let* ((icp-socket current-icp-socket)
	 (socket-extension-data?
	  (when icp-socket
	    (gsi-extension-data? icp-socket))))
    (if socket-extension-data?
	(setf (gsi-extension-last-converted-string socket-extension-data?)
	      string)
	(setf (gsi-application-last-converted-string
		(or current-gsi-application default-gsi-application))
	      string))))

(defsetf gsi-last-converted-string gsi-set-last-converted-string)

(def-gsi-api-function (gsi-convert-str-to-ustr (:return-type gsi-api-text-string))
                      ((string gsi-api-gensym-string)
		       (style  gsi-fixnum-long))
  (let ((old-string (gsi-last-converted-string)))
    (when old-string
      (reclaim-text-or-gensym-string old-string))
    (setf (gsi-last-converted-string)
	  (import-text-string-per-text-conversion-style
	    string (text-conversion-style-for-gsi style nil) nil nil))))

(def-gsi-api-function (gsi-convert-wstr-to-ustr (:return-type gsi-api-text-string))
                      ((string gsi-api-text-string)
		       (style  gsi-fixnum-long))
  (let ((old-string (gsi-last-converted-string)))
    (when old-string
      (reclaim-text-or-gensym-string old-string))
    (setf (gsi-last-converted-string)
	  (import-text-string-per-text-conversion-style
	    string (text-conversion-style-for-gsi style t) nil nil))))

(def-gsi-api-function (gsi-convert-ustr-to-str (:return-type gsi-api-gensym-string))
                      ((string gsi-api-text-string)
		       (style  gsi-fixnum-long))
  (let ((old-string (gsi-last-converted-string)))
    (when old-string
      (reclaim-text-or-gensym-string old-string))
    (setf (gsi-last-converted-string)
	  (export-text-string-per-text-conversion-style
	    string (text-conversion-style-for-gsi style nil) nil nil))))

(def-gsi-api-function (gsi-convert-ustr-to-wstr (:return-type gsi-api-text-string))
                      ((string gsi-api-gensym-string)
		       (style  gsi-fixnum-long))
  (let ((old-string (gsi-last-converted-string)))
    (when old-string
      (reclaim-text-or-gensym-string old-string))
    (setf (gsi-last-converted-string)
	  (export-text-string-per-text-conversion-style
	    string (text-conversion-style-for-gsi style t) nil nil))))


(defun gsi-displaced-array-from-c-contents (c-array count)
  #+chestnut-trans
  (let ((temporary-array (gsi-allocate-managed-array (+f count gsi-magic-offset))))
    (loop with c-pointer = c-array
	  for i from gsi-magic-offset below (+f count gsi-magic-offset)
	  do
      (setf (gsi-managed-svref temporary-array i)
	    (inline-dereference-c-pointer c-pointer))
      (setf c-pointer (inline-increment-c-pointer c-pointer)))
    temporary-array)
  #-chestnut-trans (declare (ignore count))
  #-chestnut-trans c-array
  )



;;;; Internal Constructors and Reclaimers Not Used (Though Sometimes Stubbed) By G2

(defun gsi-push-onto-appropriate-list (new-thing &optional (gsi-instance? nil))
  (if gsi-instance?
      (gsi-push new-thing (gsi-instance-reclaim-list gsi-instance?))
      (if (eq gsi-reclaim-list-level 'rpc-arg-list)
	  (gsi-push new-thing (get-resumable-reclaim-list))
	  (gsi-push new-thing gsi-reclaim-list?)))
  new-thing)

(defun-void signal-gsi-icp-message-too-long-error ()
  (gsi-connection-error 'gsi_icp_facility gsi-icp-message-too-long))

(defun-void signal-gsi-icp-message-out-of-synch-case-2-error ()
  (gsi-connection-error 'gsi_icp_facility gsi-icp-message-out-of-synch-case-2))


(defun-void signal-gsi-maximum-gensym-string-length-error (length maximum-length)
  (gsi-error 'gsi_string_facility gsi-maximum-text-string-length-error
	     length maximum-length))

(defun-void signal-gsi-extend-current-gensym-string-error ()
  (gsi-error 'gsi_string_facility gsi-extend-current-text-string-error))

(defun-void signal-gsi-maximum-text-string-length-error (length maximum-length)
  (gsi-error 'gsi_string_facility gsi-maximum-text-string-length-error
	     length
	     maximum-length))

(defun-void signal-gsi-extend-current-text-string-error ()
  (gsi-error 'gsi_string_facility gsi-extend-current-text-string-error))

(defun-void signal-gsi-undefined-structure-method-error () ; What's this?
  (gsi-error 'gsi_structure_facility gsi-undefined-structure-method-error))

(defun-void signal-gsi-index-space-full-error () ; never called, anymore
  (gsi-error 'gsi_icp_facility gsi-index-space-full-error))

(defun-void signal-gsi-network-error (event-socket-handle event-status-code)
  (gsi-error 'gsi_icp_facility gsi-network-error event-socket-handle event-status-code))

(defun-simple gsi-reclaim-contents (reclaim-list? user-or-gsi)
  (loop while reclaim-list?
	as list-entry = (gsi-pop reclaim-list?)
	do
    (cond ((gsi-instance-p list-entry)
	   (reclaim-gsi-instance list-entry user-or-gsi))
	  ((gsi-transfer-wrapper-p list-entry)
	   (reclaim-gsi-transfer-wrapper list-entry))
	  ((gsi-attribute-p list-entry)
	   (reclaim-gsi-attribute list-entry))
	  ((gsi-history-p list-entry)
	   (reclaim-gsi-history list-entry))
	  ((gsi-array-wrapper-p list-entry)
	   (let ((array (gsi-array list-entry)))
	     (case (gsi-array-type list-entry)
	       (managed-array
		(gsi-reclaim-managed-array array))
	       (managed-string-array
		(loop for i from 0 below (gsi-managed-array-length array)
		      as c-string = (gsi-managed-svref array i)
		      as string = (inline-restore-lisp-gensym-string c-string) ; works on text strings, too, I think
		      do (reclaim-text-or-gensym-string string)
		      finally (gsi-reclaim-managed-array array)))
	       (simple-integer-vector
		(gsi-reclaim-integer-vector array))
	       (simple-float-array
		(reclaim-managed-simple-float-array array)))
	     (reclaim-gsi-array-wrapper list-entry)))
	  (t
	   (gsi-error 'gsi_reclaim_facility gsi-internal-memory-inconsistency)))))

(defun gsi-symbol-name-length (symbol)
  (text-string-length (symbol-name-text-string symbol)))

(defun make-gsi-instance (&optional (instance-type nil)
				    (instance-value nil)
				    (instance-attributes nil)
				    (instance-class nil)
				    (instance-name nil)
				    (gsi-instance-owner nil)
				    (sensor-collection-interval nil))
  (let* ((existing-instance make-gsi-instance-existing-instance)
	 (new-instance (or existing-instance (make-gsi-instance-1))))
    (setf (gsi-instance-value-type new-instance) (or instance-type gsi-null-type-tag))
    (when instance-value
      (setf (gsi-instance-value new-instance) instance-value))
    (when instance-class
      (setf (gsi-instance-class new-instance) instance-class))
    (when instance-name
      (setf (gsi-instance-name new-instance) instance-name))
    (when instance-attributes
      (setf (gsi-attributes new-instance) instance-attributes)
      (setf (gsi-attribute-count new-instance) (1-f (length instance-attributes))))
    (when sensor-collection-interval
      (setf (gsi-sensor-collection-interval new-instance) sensor-collection-interval))
    (unless existing-instance
      (unless gsi-instance-owner (setq gsi-instance-owner (default-owner-for-gsi-objects)))
      (setf (gsi-instance-owner new-instance) gsi-instance-owner)
      (when (eq gsi-instance-owner 'gsi)
	(gsi-push-onto-appropriate-list new-instance)))
    new-instance))

(defun-simple make-gsi-instance-for-user-or-gsi (user-or-gsi)
  (make-gsi-instance gsi-null-type-tag nil nil nil nil user-or-gsi))

(defun-void reclaim-gsi-instance (gsi-instance user-or-gsi)
  (when (eq (gsi-instance-owner gsi-instance) user-or-gsi)
    (let* ((value? (gsi-instance-value gsi-instance)))
      (when value?
	(reclaim-gsi-instance-value
	  (gsi-instance-value-type gsi-instance)
	  value?
	  gsi-instance
	  user-or-gsi))
      (reclaim-gsi-instance-extension gsi-instance user-or-gsi))
    (reclaim-gsi-instance-1 gsi-instance)))

(defun-void reclaim-gsi-instance-extension (gsi-instance user-or-gsi)
  (let ((extension? (gsi-instance-extension gsi-instance)))
    (when extension?
      (reclaim-icp-object-map-for-gsi-instance gsi-instance)
      (let ((history? (gsi-instance-history--ext extension?))
	    (reclaim-list? (gsi-instance-reclaim-list--ext extension?)))
	(when history?
	  (reclaim-gsi-history history?))
	(when reclaim-list?
	  (gsi-reclaim-contents reclaim-list? user-or-gsi))
	(reclaim-gsi-instance-extension-1 extension?)))
    (setf (gsi-instance-extension gsi-instance) nil)))

(defun-void gsi-reclaim-instance-value-array (value instance user-or-gsi)
  (loop for prev = nil then current
	for current = (gsi-instance-reclaim-list instance)
		    then next
	for next = (cdr current)
	until (or (null current)
		  (let ((list-element (car current)))
		    (and (gsi-array-wrapper-p list-element)
			 (eq value (gsi-array list-element)))))
	finally
	  (cond ((null current)
		 (error "Bug in gsi-reclaim-instance-value-array"))
		(prev
		 (setf (cdr prev) next))
		(t
		 (setf (gsi-instance-reclaim-list instance) next)))
	(setf (cdr current) nil)
	(gsi-reclaim-contents current user-or-gsi)))

(defun-void reclaim-gsi-instance-value (type value instance user-or-gsi)
  (when value
    (case type
      (#.gsi-64bit-float-type-tag
       (reclaim-managed-float value))
      (#.gsi-long-type-tag
       (reclaim-managed-long value))
      ((#.gsi-string-type-tag #.gsi-unsigned-short-vector-type-tag)
       (reclaim-text-or-gensym-string value))
      ((#.gsi-integer-type-tag #.gsi-logical-type-tag #.gsi-symbol-type-tag))
      ((#.gsi-64bit-float-array-type-tag #.gsi-64bit-float-list-type-tag
        #.gsi-string-array-type-tag #.gsi-string-list-type-tag
	#.gsi-integer-array-type-tag #.gsi-integer-list-type-tag
	#.gsi-logical-array-type-tag #.gsi-logical-list-type-tag
	#.gsi-symbol-array-type-tag #.gsi-symbol-list-type-tag)
       (gsi-reclaim-instance-value-array value instance user-or-gsi))
      ((#.gsi-item-or-value-array-type-tag #.gsi-item-or-value-list-type-tag
        #.gsi-quantity-array-type-tag #.gsi-quantity-list-type-tag
	#.gsi-item-array-type-tag #.gsi-item-list-type-tag
	#.gsi-value-array-type-tag #.gsi-value-list-type-tag
	#.gsi-sequence-type-tag))
      (#.gsi-structure-type-tag)
      (#.gsi-null-type-tag)
      (#.gsi-item-handle-type-tag)
      (otherwise
       (gsi-error 'reclaim-gsi-instance-value gsi-internal-memory-inconsistency)))))

(defun-simple make-gsi-transfer-wrapper ()
  (gsi-push-onto-appropriate-list
    (make-gsi-transfer-wrapper-1 nil 0 nil nil (default-owner-for-gsi-objects))))

(defun-void reclaim-gsi-transfer-wrapper (transfer-wrapper)
  (reclaim-gsi-transfer-wrapper-1 transfer-wrapper))

(defun-void reclaim-gsi-user-transfer-wrapper (transfer-wrapper)
  (unless (eq (gsi-transfer-owner transfer-wrapper) 'user)
    (gsi-error 'reclaim-gsi-user-transfer-wrapper gsi-ownerous-reclamation-violation))
  (reclaim-gsi-transfer-wrapper-1 transfer-wrapper))

(defun-simple make-gsi-sequence (list)
  (let* ((length (length list))
	 (gsi-item (make-gsi-instance gsi-sequence-type-tag)))
    (setf (gsi-element-count gsi-item) length)
    (when (<f 0 length)
      (let ((gsi-items (gsi-allocate-managed-array (+f length gsi-magic-offset))))
	(gsi-push-onto-appropriate-list
	  (make-gsi-array-wrapper 'managed-array gsi-items)
	  gsi-item)
	(setf (gsi-instance-value gsi-item) gsi-items)
	(loop for item in list
	      for j from gsi-magic-offset
	      do
	  (setf (gsi-managed-svref gsi-items j) item))))
    (reclaim-gsi-list list)
    gsi-item))

(defun-simple make-gsi-structure (list)
  (let* ((length (length list))
	 (attribute-count (ashf length -1))
	 (gsi-item (make-gsi-instance gsi-structure-type-tag))
	 (attribute-count-with-offset (+f attribute-count gsi-magic-offset))
	 (attributes (gsi-allocate-managed-array attribute-count-with-offset)))
    (gsi-push-onto-appropriate-list
      (make-gsi-array-wrapper 'managed-array attributes)
      gsi-item)
    (setf (gsi-attributes gsi-item) attributes)
    (setf (gsi-attribute-count gsi-item) attribute-count)
    (setf (gsi-managed-svref attributes 0) gsi-magic-number)
    (loop for (attribute-name attribute-value) on list by 'cddr
	  for i from gsi-magic-offset below attribute-count-with-offset
	  for attribute = (make-gsi-attribute attribute-name)
	  do
      (setf (gsi-managed-svref attributes i) attribute)
      (setf (gsi-attribute-instance attribute) attribute-value))
    (reclaim-gsi-list list)
    gsi-item))

(defun make-gsi-attribute (&optional (base-name nil) (class-qualifier nil))
  (gsi-push-onto-appropriate-list
    (make-gsi-attribute-1
      (make-resumable-attribute-name class-qualifier base-name)
      nil
      (default-owner-for-gsi-objects))))

(defun-simple make-gsi-attribute-for-user-or-gsi (user-or-gsi)
  (let ((attribute (make-gsi-attribute-1 (make-resumable-attribute-name)
					 nil user-or-gsi)))
    (when (or (eq user-or-gsi 'gsi) (eq user-or-gsi 'context))
      (gsi-push-onto-appropriate-list attribute))
    attribute))

(defun-void reclaim-gsi-attribute (attribute)
  (let ((spec (gsi-attribute-spec attribute)))
    (cond ((resumable-attribute-spec-p spec)
	   (reclaim-resumable-attribute-spec-function spec))
	  ((consp spec)
	   (reclaim-gsi-list spec))))
  (reclaim-gsi-attribute-1 attribute))

(defun-void reclaim-gsi-user-attribute (attribute)
  (when (eq (gsi-attribute-owner attribute) 'user)
    (reclaim-gsi-attribute attribute)))

(defun make-gsi-history (gsi-instance length &optional
				      (values? nil)
				      (timestamps? nil)
				      (base-time? nil)
				      (max-count? nil)
				      (max-age? nil)
				      (granularity? nil))
  (let ((value-type (gsi-instance-value-type gsi-instance)))
    (unless values?
      (setq values?
	    (case value-type
	      ((#.gsi-integer-type-tag #.gsi-logical-type-tag)
	       (gsi-make-appropriate-array gsi-integer-array-type-tag length gsi-instance))
	      (#.gsi-64bit-float-type-tag
	       (gsi-make-appropriate-array gsi-64bit-float-array-type-tag length gsi-instance))
	      ((#.gsi-string-type-tag #.gsi-unsigned-short-vector-type-tag)
	       (gsi-make-appropriate-array gsi-string-array-type-tag length gsi-instance))
	      (#.gsi-symbol-type-tag
	       (gsi-make-appropriate-array gsi-symbol-array-type-tag length gsi-instance))
	      ((#.gsi-value-type-tag #.gsi-quantity-type-tag)
	       (gsi-make-appropriate-array gsi-value-array-type-tag length gsi-instance))
	      (t
	       (gsi-error 'make_gsi_history gsi-invalid-history-type)))))
    (unless timestamps?
      (setf timestamps?
	    (allocate-managed-simple-float-array length)))
    (unless base-time?
      (setf base-time? (allocate-managed-float 0.0)))

    (let ((history (make-gsi-history-1 length values? timestamps? 0)))
      (setf (gsi-history-internals history) (gsi-list nil max-count? max-age? granularity?))
      (setf (gsi-history-dynamic-info history) (gsi-list base-time? nil nil))
    history)))

(defun-simple gsi-set-history-type (gsi-instance history-type)
  (setf (gsi-instance-class-type gsi-instance) history-type)
  history-type)

(defun-simple make-gsi-history-from-specification (max-count? max-age? granularity?)
  (let ((history (make-gsi-history-1 nil nil nil 0)))
    (setf (gsi-history-internals history) (gsi-list nil max-count? max-age? granularity?))
    (setf (gsi-history-dynamic-info history) (gsi-list (allocate-managed-float 0.0) nil nil))
    history))

(defun-simple add-vectors-to-gsi-history (length history gsi-instance)
  (setf (gsi-history-length history) length)
  (setf (gsi-history-values history)
	(case (gsi-instance-class-type gsi-instance)
	  ((#.gsi-integer-type-tag #.gsi-logical-type-tag)
	   (gsi-make-appropriate-array gsi-integer-array-type-tag length gsi-instance))
	  (#.gsi-64bit-float-type-tag
	   (gsi-make-appropriate-array gsi-64bit-float-array-type-tag length gsi-instance))
	  ((#.gsi-string-type-tag #.gsi-unsigned-short-vector-type-tag)
	   (gsi-make-appropriate-array gsi-string-array-type-tag length gsi-instance))
	  (#.gsi-symbol-type-tag
	   (gsi-make-appropriate-array gsi-symbol-array-type-tag length gsi-instance))
	  ((#.gsi-value-type-tag #.gsi-quantity-type-tag)
	   (gsi-make-appropriate-array gsi-value-array-type-tag length gsi-instance))
	  (t
	   (gsi-error 'make_gsi_history gsi-invalid-history-type))))
  (setf (gsi-history-timestamps history)
	(allocate-managed-simple-float-array length))
  history)

(defun-void reclaim-gsi-history (history)
  (let* ((timestamps? (gsi-history-timestamps history))
	 (internals? (gsi-history-internals history))
	 (dynamic-info? (gsi-history-dynamic-info history)))
    (when timestamps?
      (reclaim-managed-simple-float-array timestamps?))
    (when internals?
      (reclaim-gsi-list internals?))
    (when dynamic-info?
      (reclaim-managed-float (first dynamic-info?))
      (reclaim-gsi-list dynamic-info?))
    (reclaim-gsi-history-1 history)))

(defun gsi-attribute-qualified-name (gsi-attribute)
  (or (gsi-attribute-qualified-name-1 gsi-attribute)
      (setf (gsi-attribute-qualified-name-1 gsi-attribute)
	    (let* ((resumable-attribute-spec (gsi-attribute-spec gsi-attribute))
		   (class-qualifier?
		     (resumable-attribute-class-qualifier? resumable-attribute-spec)))
	      (gsi-intern
		(simple-text-string-copy-from-attribute-name-1
		  (resumable-attribute-base-name resumable-attribute-spec)
		  class-qualifier?
		  t))))))

(defun-simple gsi-intern (string)
  (when string
    (let ((package
	    (if (position-of-two-colons string)
		keyword-package-1
		ab-package-1)))
      (if (wide-string-p string)
	  (intern-text-string string package)
	  (intern-gensym-string string package)))))




;;;; GSI Supporting Macros and Functions


(defun-simple gsi-failure-p (value)
  (not (=f value gsi-success)))






;;;; Foreign Function Cruft

;; this definition is to prevent the
;; load-foreign-libraries-for-ab-when-appropriate call from generating an error.
;; This function is never called from LISP.  In a development environment, it
;; will be called from the (UNIX) signal handler for the alarm clock (SIGALRM)
;; interrupt.
;;
;; quoting from primitives.lisp;
;;
;; jh, 8/16/93.	 Changed the compile-switching so that the dummy foreign symbols
;; defined by lucid::def-foreign-callable will get created in every Lucid build
;; environment except :chestnut-trans.	These dummy foreign symbols will thereby
;; suppress "undefined foreign symbol" warnings in both development and
;; translation macro passes, but will allow C code generated by the translation
;; pass to link correctly with the signal handlers in g2signal.c.


#+(and lucid (not :chestnut-trans))
(lucid::def-foreign-callable (gsi-connection-shutdown-callback
			       (:name "_shutdown_icp_socket_connection")
			       (:return-type :lisp))
    ()
  (shutdown-icp-socket-connection current-icp-socket))

(defun shutdown-data-server-wrapper ()
  (shutdown-icp-socket-connection current-icp-socket))

#-gsi-in-g2
(load-foreign-libraries-for-ab-when-appropriate)

(defvar gsi-transfer-array-for-deregistration nil)
(defvar gsi-sensor-to-deregister? nil)
(defvar index-of-gsi-sensor-to-deregister? -1)

;called by remove-icp-port-entries-from-icp-object-1.
(defun-simple gsi-deregister-items-wrapper-for-known-sensor (sensor index)
  (let* ((transfer-wrapper-array
	   (or gsi-transfer-array-for-deregistration
	       (setq gsi-transfer-array-for-deregistration
		     (create-transfer-wrapper-array 1))))
	 (transfer-wrapper (gsi-managed-svref transfer-wrapper-array
					      gsi-magic-offset)))
    (setf (gsi-transfer-sensor-or-index transfer-wrapper) sensor)
    ;;g2 sends one message per item to delete in this case.  --ncc
    (let* ((current-icp-socket icp-socket-for-reclaim?)
	   (gsi-sensor-to-deregister? sensor)
	   (index-of-gsi-sensor-to-deregister? index))
    (call-gsi-callback gsi-receive-deregistrations
      (gsi-extract-c-array transfer-wrapper-array) 1))
    (reclaim-gsi-instance-for-context sensor)))


;;; Declaration:     free-gsi-input-port-contents ()
;;; Type:	     Lisp function
;;; Purpose:	     Reclaim the contents of the gsi input port of the current socket.
;;; Return behavior: The return value of this function is undefined.
;;; Users:	     reclaim-gsi-structures-for-socket (gsi-common.lisp)
;;; Prerequisites:   The special current-icp-socket must be bound to a valid ICP socket.
;;;		     There must be a valid transfer-wrapper-array associated with the
;;;		     current-icp-socket.
;;; Side effects:    Yes; see memory impact entry below.
;;; Non-local exits: None.
;;; Memory impact:   Reclaims any GSI sensor objects associated with the input-port of
;;;		     the current-icp-socket.
;;; Notes: Called only by shutdown-data-server-body, free-gsi-input-port-contents is
;;;	  charged with reclaiming the contents of the input port being shut down.
;;;	  That is, the gsi corresponding object space, in which several different
;;;	  kinds of object may be stored.
;;;
;;;	  Currently, only gsi-sensors are reclaimed.  XXX This may be a leak.
;;;
;;;	  gsi sensors to be reclaimed are buffered in the transfer-wrapper
;;;	  array, and passed to the user via the toolkit function
;;;	  gsi-receive-deregistrations when the array is full or when there are no more
;;;	  sensors to process.  The toolkit function call gives the user the
;;;	  opportunity to reclaim any application-specific memory associated with
;;;	  each GSI sensor.
;;;
;;;	  It concerns me somewhat that the sensors are freed before calling the
;;;	  user toolkit function gsi-receive-deregistrations.   ???
;;;
;;;

(defun-void reclaim-gsi-transfer-wrapper-array (transfer-wrapper-array)
  (loop for array-index from gsi-magic-offset below (+f size-of-array-of-transfer-wrappers gsi-magic-offset)
	for transfer-wrapper = (gsi-managed-svref transfer-wrapper-array array-index)
	do
    (when (gsi-transfer-wrapper-p transfer-wrapper)
      (let ((old-value (gsi-transfer-instance transfer-wrapper)))
	(when old-value
	  (reclaim-gsi-instance-for-gsi old-value)))
      (reclaim-gsi-transfer-wrapper transfer-wrapper)
      (setf (gsi-managed-svref transfer-wrapper-array array-index) nil))
	finally (gsi-reclaim-managed-array transfer-wrapper-array)))



;;reclaim-gsi-remote-procedures
;; this is called from the reclaimer for the gsi-extension-data.
;; It reclaims all procedure objects associated with current-icp-socket.
(defun-simple reclaim-gsi-remote-procedures (list-of-procedures?)
  (loop while list-of-procedures?
	for procedure = (gsi-pop list-of-procedures?)
	do (reclaim-gsi-remote-procedure procedure)))

;;get-gsi-current-context-number
;; rewritten -ncc, 6/17/94 to work properly
;; when there is no extension-data for the current socket.
;; I note that this code assumes that current-icp-socket is valid,
;; which it isn't always.  This was the old code:
;; (defun-simple get-gsi-current-context-number ()
;;   (gsi-context-number (or (gsi-extension-data? current-icp-socket)
;;			  gsi-undefined-context)))
;; this is what it really wants to be:
;;
;; NOTE: It's puzzling that we have both a global named gsi-current-context-number
;; and this function.  I think this ought to be fixed.	-ncc, 6/17/94
;;
(defun-simple gsi-current-context-number ()
  (if (null current-icp-socket)
      gsi-undefined-context
      (let* ((socket-extension-data? (gsi-extension-data? current-icp-socket)))
	(if socket-extension-data?
	    (gsi-context-number socket-extension-data?)
	    gsi-undefined-context))))

;;; valid-gsi-context-p t iff context is the gsi-context-number of the
;;; gsi-extension-data? of some active icp-socket, nil otherwise.
;;;
;;; I don't really understand what this means; it certainly doesn't imply that
;;; the connection can be shut down, which is one of the purposes it is being
;;; used (incorrectly) for.

(defun-simple invalid-gsi-context-p (context for-writing-p)
  (declare (type fixnum context))
  (when (<f context 0)
    (return-from invalid-gsi-context-p gsi-context-undefined))
  (let ((socket (get-object-from-index-space-if-any gsi-context-to-socket-map context)))
    (unless (and socket
		 (let ((extension-data? (gsi-extension-data? socket)))
		   (and extension-data?
			(=f (gsi-context-number extension-data?) context))))
      (return-from invalid-gsi-context-p gsi-invalid-context))
    (unless (or (/=f (icp-connection-state socket) icp-connection-closed)
		(=f context (gsi-current-context-number)))
      (return-from invalid-gsi-context-p gsi-context-has-been-shut-down))
    (unless (or (not for-writing-p)
		(=f (icp-connection-state socket) icp-connection-running))
      (return-from invalid-gsi-context-p gsi-context-has-been-killed))))

(defun-simple get-icp-socket-from-context (context for-writing-p)
  (let ((code (invalid-gsi-context-p context for-writing-p)))
    (when code
      (gsi-error 'get-icp-socket-from-context code context)))
  (let ((socket (get-object-from-index-space gsi-context-to-socket-map context)))
    (when (and socket for-writing-p)
      (gsi-send-reply-to-initial-ping socket)) ; does nothing if already sent
    socket))

;;  This function, given a context, will validate the context.	Three values are
;;  returned: resolved-p indicates whether the context resolution was
;;  sucessfull; derived-icp-input-port is the input port that corresponds to the
;;  icp-socket associated with the desired context; derived-icp-output-port is
;;  the output port that corresponds to the icp-socket associated with the
;;  desired context.  Note that the argument function-name allows any error
;;  messages to indicate the originating GSI API function.

;; rewritten in light of the fact that a valid gsi-current-context-number
;; does not imply a valid current-icp-socket.  -ncc, 6/16/94

;;Q. Is the distinction between undefined and invalid context
;; clear and meaningful to the user? -ncc, 6/16/94

;;A. Yes, the undefined context (-1) is the 'current context'
;; (the value returned by gsi_current_context()) when outside
;; the extent of the run loop, or when inside an error handler
;; just after a fatal error resulting in a context shutdown.
;; An invalid context may be any number other than -1 which
;; does not correspond to a currently active context.	 The user
;; has the symbol GSI_UNDEFINED_CONTEXT to identify the undefined
;; context, and two distinct error messages (see below) are defined
;; and documented. -paf! 14mar95

(defmacro check-gsi-context (context &optional for-writing-p)
  `(let ((code (invalid-gsi-context-p context ,for-writing-p)))
     (when code
       (gsi-api-error code ,context))))

(defmacro resolve-gsi-context (context)
  `(let ((context ,context))
     (check-gsi-context context nil)
     (get-icp-socket-from-context context nil)))

(defmacro resolve-gsi-context-for-writing (context)
  `(let ((context ,context))
     (check-gsi-context context t)
     (get-icp-socket-from-context context t)))


;;    RECLAIM-ANY-LEFTOVERS  -->  WITH-LEFTOVER-GSI-INSTANCE-VALUE-RECLAMATION
;; called in relevant gsi-set- api functions, to reclaim any data the user may
;; be stomping on.  Only the gsi-set- fcns which deal with the value slot of a
;; gsi-item need to do this, but _ALL_ of them need to do it, in case the
;; PREVIOUS CONTENTS of the item was a string, array, symbol, etc.
;;
;;reclaim-any-leftovers was replaced -ncc, 6/16/94 with the following:
;;
;; WITH-LEFTOVER-GSI-INSTANCE-VALUE-RECLAMATION
;;  extended for array and other types -ncc, 8/23/94
;;
(defmacro with-leftover-gsi-instance-value-reclamation
    ((gsi-instance-to-be-reclaimed?)
     &body forms-affecting-instance)

  (avoiding-variable-capture (&aux old-gsi-instance-value?
				   old-gsi-instance-value-type?)
    `(let* ((,old-gsi-instance-value-type?
	     (if ,gsi-instance-to-be-reclaimed?
		 (gsi-instance-value-type ,gsi-instance-to-be-reclaimed?)
		 nil))
	    (,old-gsi-instance-value?
	     (if ,old-gsi-instance-value-type?
		 (gsi-instance-value ,gsi-instance-to-be-reclaimed?)
		 nil)))

      ,@forms-affecting-instance

      (reclaim-gsi-instance-value
	,old-gsi-instance-value-type? ,old-gsi-instance-value?
	,gsi-instance-to-be-reclaimed?
	(gsi-instance-owner ,gsi-instance-to-be-reclaimed?)))))



(defparameter GSI-IO-UNBLOCKED 1)	;must match definitions in gsi/c/gsi_main.h!
(defparameter GSI-IO-BLOCKED 0)

(defun-allowing-unwind gsi-read-state-change (socket state)
  (when *scheduler-enabled?*
    (let*-while-true ((extension-data? (gsi-extension-data? socket))
		      (context-number (gsi-context-number extension-data?)))
      (with-scheduler-disabled
	(call-gsi-callback gsi-read-callback
			   context-number
			   (if state
			       GSI-IO-UNBLOCKED
			       GSI-IO-BLOCKED))))))

(defun-allowing-unwind gsi-write-state-change (socket state)
  (when *scheduler-enabled?*
    (let*-while-true ((extension-data? (gsi-extension-data? socket))
		      (context-number (gsi-context-number extension-data?)))
      (with-scheduler-disabled
	(call-gsi-callback gsi-write-callback
			   context-number
			   (if state
			       GSI-IO-UNBLOCKED
			       GSI-IO-BLOCKED))))))

(defun-void register-gsi-connection-callbacks (listener-socket? nascent-socket)
  (when listener-socket?
    (setf (listener-socket nascent-socket) listener-socket?))
  (register-icp-callback 'icp-connection-loss 'gsi-connection-loss-notifier nascent-socket)
  (register-icp-callback 'icp-read 'gsi-read-state-change nascent-socket)
  (register-icp-callback 'icp-write 'gsi-write-state-change nascent-socket))

;;; gsi-connection-loss-notifier
;;;
;;; This function exists to generate a GSI error if the connection ("context" in
;;; GSI parlance) was closed in an errorful way, and to reclaim per-context data
;;; structures in that case, and in any case to call the GSI user code "toolkit"
;;; function "gsi_shutdown_context" to inform the user of the connection loss,
;;; errorful or not.
;;;
;;;		 A digression about connection shutdown in 4.0 GSI:
;;; ****								****
;;; *** PRIOR TO THE NEW SHUTDOWN HANDSHAKE MOD, due to -ncc, 3 Apr 1995 ***
;;; ****								****
;;;
;;; When a "normal" shutdown occurs, the shut-down-data-server message body
;;; reclaims the associated per-connection GSI data structures.	 The
;;; shutdown-icp-socket-connection function is called with reason-for-shutdown?
;;; nil, which indicates a normal shutdown.
;;;
;;; Peer crashes are detected by a negative (error) return value from
;;; c-network-read or c-network-write; in either case,
;;; shutdown-icp-socket-connection is called, which does a c-network-close on
;;; the socket, and marks the icp-socket structure as closed.  This process
;;; *doesn't* reclaim any GSI specific functions, because it can't -- it's a
;;; general-purpose part of ICP.  (You could argue that the connection loss
;;; notifier ought to be invoked at this point, and you might have a point, but
;;; it isn't.)	Finally, shutdown-icp-socket-connection is called with a non-nil
;;; "reason-for-shutdown?".
;;;
;;; Either way, normal or crash, the call to shutdown-icp-socket-connection
;;; later causes purge-inactive-icp-sockets to call the connection loss notifier
;;; (if it exists, and for GSI it always does).	 So here we are.
;;;
;;;  (End of digression)
;;;
;;; It is further assumed that if this *IS* an errorful shutdown, then we must
;;; reclaim the GSI per-connection data structures, as would otherwise have been
;;; reclaimed via the shut-down-data-server message. -ncc, 13 Feb 1995
;;;

(defun-allowing-unwind gsi-connection-loss-notifier (icp-socket clean?)
  (declare (ignore clean?))
  (let ((gsi-extension-data? (gsi-extension-data? icp-socket)))
    (when (and gsi-extension-data?
	       (gsi-initialize-context-has-been-called-p gsi-extension-data?))
      (let ((gsi-shutdown-reason (reason-for-shutdown? icp-socket))
	    (current-icp-socket icp-socket))
      (unless (gsi-maybe-notice-delayed-connection-failure icp-socket)
	(gsi-message "Connection closed - context ~a~%" (gsi-current-context-number)))

	(when gsi-shutdown-reason
	  (gsi-handle-error 'gsi_internals nil nil gsi-connection-lost gsi-shutdown-reason))))))

(defun-void maybe-call-gsi-shutdown-context-callback (icp-socket)
  (let* ((current-icp-socket icp-socket)
	 (gsi-extension-data? (gsi-extension-data? icp-socket)))
    (when (and gsi-extension-data?
	       (gsi-initialize-context-has-been-called-p gsi-extension-data?))
      (call-gsi-callback gsi-shutdown-context))))

;;;; GSI Product Entry-point

(define-system-access gsi)

;;;; abort-gsi-top-level
;; this is called by do-minimal-error-trapping when something causes a throw to
;; top-level-error-catcher.  Many things may do this.  Some of them may have
;; already set error info.  If so, we do not want to disturb this information.
;;
(defun-simple abort-gsi-top-level ()
  (gsi-handle-error 'gsi-error-handler t 'error))

(defun gsi-continue-from-error ()
  (cond ((and (not (gsi-option-is-set-p gsi-one-cycle))
	      within-run-loop-extent
	      (not unrecoverable-error-p))
	 (gsi-continue-run-loop))
	(unrecoverable-error-p
	 (g2-unrecoverable-error-exit))
	(t
	 (when (and in-unprotected-gsi-api-call-p
		    gsi-throw-to-run-loop-may-be-harmful-p)
	   (format t "~%Warning: error in an unprotected GSI API call.~
                      ~%Returning ~A the run loop.~
                      ~%(Use gsi_set_option(GSI_PROTECT_INNER_CALLS))~%"
		   (if (gsi-option-is-set-p gsi-one-cycle)
		       "from"
		       "to")))
	 (shutdown-or-exit))))

;; gsi-continue-run-loop throws to a catch (catch-abort (0), actually)
;; within the gsi run loop.
(defun-simple gsi-continue-run-loop ()
  (abort 0))

;; Default and derived listener address values.

(defvar default-gsi-extension-tcp-address 22041)
(defvar gsi-extension-tcp-address? nil)

(defvar gsi-is-not-initialized t) ; UNBOUND -> T -> NIL

(defun initialize-gsi ()
  ;; note that initial-maximum-number-of-contexts could easily be determined
  ;; from a command-line argument to be named later. -ncc, 3/6/95
  (initialize-gsi-context-number-table initial-maximum-number-of-contexts)

  (setf next-available-context-number 0)
  (setf reusable-circularity-table (make-gsi-circularity-table))

  ;; Prepare a set of global structures re-used for item passing
  (setf array-element-attribute-spec (make-resumable-vector-index))
  (setf list-element-attribute-spec (make-resumable-list-index))
  (setf item-name-attribute-spec (make-resumable-attribute-name nil 'name))
  (setf simple-item-value-attribute-spec (make-resumable-attribute-name nil 'current-value))
  (setf reusable-name-instance (make-gsi-instance-1))
  (setf (gsi-instance-value-type reusable-name-instance) gsi-symbol-type-tag)
  (setf reusable-value-instance	(make-gsi-instance-1))
  (setq gsi-is-not-initialized nil))

(defun-for-top-level run-gsi-1 ()
  (when (gsi-option-is-set-p gsi-trace-run-loop)
    (format t "Entering gsi_start~%"))
  (initialize-gsi)
  (initialize-scheduler)
  (initialize-gensym-time)
  (cache-command-line-if-necessary)
  (set-up-lisp-memory-management 'gsi)
  (current-system-case
    (gsi (unless (gsi-option-is-set-p gsi-suppress-output)
	   (announce-system-presence 'gsi)
	   (report-memory-usage 'gsi))))

  (multiple-value-bind (interface-name class-name network host port
				       remote-process-initialization-string)
      (get-connect-address-from-command-line)

    (setq gsi-use-references-p (gsi-option-is-set-p gsi-use-references))
    (setq gsi-references-in-use (if gsi-use-references-p 1 0))

    ;; Allow user code to declare local functions for access from G2 by
    ;; RPC, and to set and reset run-time GSI options.
    (call-gsi-callback gsi-set-up)

    (setq gsi-references-in-use (if gsi-use-references-p 1 0))

    ;; Establish signal handlers.
    (unless (or (gsi-option-is-set-p gsi-no-signal-handlers)
		(do-not-catch-aborts-p))
      (c-inhibit_core_dumping)
      (register-all-signal-handlers-unconditionally))

    ;; Use the command line, the toolkit function gsi_get_tcp_port(), and
    ;; default values to derive one or two network listener specifications.
    ;; Get out if we fail to parse a coherent specification for the listener(s).
    ;; Try to establish these listeners, get out if we fail.
    (let ((listeners-exist-p (unless (gsi-no-listener-p)
			       (derive-network-listeners)
			       (establish-gsi-listeners))))

      (when (and (not (and (not (gsi-no-connect-p))
			   (or (gsi-connect-p)
			       interface-name class-name network host port
			       remote-process-initialization-string)
			   (equal gsi-undefined-context
				  (initiate-gsi-connection
				    interface-name class-name nil
				    network host port
				    remote-process-initialization-string
				    nil
				    secure-icp-default-p))))
		 (or listeners-exist-p active-icp-sockets))
	(enter-abyss)))))

(defvar enable-run-gsi nil)

(defun-allowing-unwind run-gsi (gensym-window)
  (declare (ignore gensym-window))
  (when (gsi-option-is-set-p gsi-trace-run-loop)
    (format t "Entering gsi_start"))
  #+(and chestnut-3 translator)
  (setq trun::*gc-silence* nil)
  (when enable-run-gsi
    (if do-error-trapping?
	(do-minimal-error-trapping (abort-gsi-top-level)
	  (run-gsi-1))
	(run-gsi-1)))
  (when (gsi-option-is-set-p gsi-trace-run-loop)
    (format t "Leaving gsi_start~%"))
  (shutdown-or-exit)) ; just does a throw, returning from a GSI API function

(def-gensym-c-function c-create-argument-list
                       (:void "g2ext_create_argument_list")
  ((:fixnum-int argc) (:object argv)))

(def-inlined-pseudo-function-with-side-effects (gsi-log-command-line :null)
    ((argc :fixnum-int) (argv :object))
  (c-create-argument-list argc argv))

(def-gsi-api-function (gsi-start
			(:return-type :null)
			(:initializes-gsi t))
                      ((argc  gsi-fixnum-long)
		       (argv  :object))
  (current-system-case
    (gsi (gsi-log-command-line argc argv)
	 (let ((enable-run-gsi t)
	       (*write-console-p* t))
	   (run-gsi nil)))
    (t argc argv)))

;;; support for setting and calling the user error handler from LISP

;; "global" is used here to emphasize that the error handler is not per-connection.
;;  -ncc, 3/13/94


;;; GSI error handlers and reporters.

(defun gsi-init-error (originating-function error-code
		       &optional (arg1 nil) (arg2 nil) (arg3 nil)
				 (arg4 nil) (arg5 nil) (arg6 nil))
  (declare (ignore originating-function))
  (gsi-handle-error-no-exit '|gsi_start| nil 'error error-code
			    arg1 arg2 arg3 arg4 arg5 arg6)
  nil)

;;; gsi-error:

(defun gsi-error (originating-function error-code &optional
				       (arg1 nil) (arg2 nil) (arg3 nil)
				       (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error originating-function nil 'error error-code
		    arg1 arg2 arg3 arg4 arg5 arg6))

(defun gsi-error-no-exit (originating-function error-code &optional
				       (arg1 nil) (arg2 nil) (arg3 nil)
				       (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error-no-exit originating-function nil 'error error-code
			    arg1 arg2 arg3 arg4 arg5 arg6))

(defun gsi-connection-error (originating-function error-code &optional
				       (arg1 nil) (arg2 nil) (arg3 nil)
				       (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error originating-function nil 'connection error-code
		    arg1 arg2 arg3 arg4 arg5 arg6))

(defun gsi-connection-error-no-exit (originating-function error-code &optional
				       (arg1 nil) (arg2 nil) (arg3 nil)
				       (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error-no-exit originating-function nil 'connection error-code
			    arg1 arg2 arg3 arg4 arg5 arg6))

(defun gsi-fatal-error (originating-function error-code &optional
				       (arg1 nil) (arg2 nil) (arg3 nil)
				       (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error originating-function nil 'fatal error-code
		    arg1 arg2 arg3 arg4 arg5 arg6))

;;; changed gsi-warning to call user error handler, as per bug # HQ-195574
;;; -ncc, 3 Apr 1995
(defun gsi-warning (originating-function error-code &optional
					 (arg1 nil) (arg2 nil) (arg3 nil)
					 (arg4 nil) (arg5 nil) (arg6 nil))
  (gsi-handle-error originating-function nil 'warning error-code
		    arg1 arg2 arg3 arg4 arg5 arg6)
  nil)					; this nil is required here

;;; The nil just above is required because otherwise the chestnut-generated code
;;; will attempt to return the value of the
;;; gsi-call-user-error-handler-if-defined function call just above; this
;;; is a void function and so the C compiler will carp.
;;; I cannot define gsi-warning using a defun-void because defun-void
;;; does not allow optional arguments.	sigh. -ncc, 21 Apr 1995

(defun gsi-message (message-as-format-string
		     &optional				; pseudo rest args
		     (arg1 no-arg) (arg2 no-arg) (arg3 no-arg)
		     (arg4 no-arg) (arg5 no-arg) (arg6 no-arg)
		     (arg7 no-arg) (arg8 no-arg) (arg9 no-arg))

  (unless (gsi-option-is-set-p gsi-suppress-output)
    (notify-user-if-possible message-as-format-string
			     arg1 arg2 arg3 arg4 arg5
			     arg6 arg7 arg8 arg9)))


;;; Command-line interpreter

;; This function provides the GSI user code (through gsi_get_tcp_port())
;; a chance to programatically supply a TCP port number if one is
;; ommitted from the command line.  If zero is returned from this GSI
;; toolkit function, the default is used.
;; Derive-network-listeners uses the command line, a GSI toolkit function
;; (only for TCP), and default values to determine which and how many
;; (one or two) network listeners to open.  This function does its work
;; by side-effecting the global sensor gsi-extension-tcp-address?.
;; Note this function is rather complex
;; it mimics the traditional behavior of the GSI command line interpreter
;; which tried to do the inutitive thing and tried to guess user intentions
;; all while dealing with non-(UNIX)standard and inconsistent command-line
;; syntax.  See GSI 3.1 release notes for documentation.  29oct93 paf!

(defun-simple derive-network-listeners ()
  (let ((command-line-index 1)
	(network-1? nil)
	(address-1? nil))

    ;; Begin by calling user Toolkit function gsi-get-tcp-port to see if
    ;; user is specifiying a port number for TCP.  If user returned zero,
    ;; get-preset-tcp-port-number will return the default specified by
    ;; default-gsi-extension-tcp-address.

    (setf gsi-extension-tcp-address? (get-preset-tcp-port-number))

    ;; The user may override their own preset with a command line argument.
    ;; Therefore, I continue to check command line arguments.

    ;; Try to extract a pair of tokens from the command line, and if I get
    ;; anything try to extract another pair.

    (multiple-value-setq (command-line-index network-1? address-1?)
      (get-listener-from-command-line command-line-index))

    ;; BNF for command line is:
    ;;	 <program> [<listener>]
    ;; where listener is defined as:
    ;;	 [<port-number>] [-network tcpip]
    ;; e.g. "> skeleton -network tcpip" specifies one tcpip listener with
    ;; default port number, while
    ;; "> skeleton 12345 -network tcpip" specifies one listener which must
    ;; be tcpip with port number 12345.
    ;;
    ;; Handle case where only one listener was specified in the command line
    ;; either with a single network designation, a single address specification,
    ;; or one of the former followed by one of the latter.  In such a case, one
    ;; and only one listener will be established.

    (if (or address-1? network-1?)
	(cond ((equalw network-1? #w"tcpip")
	       (return-from derive-network-listeners
		 (gsi-store-desired-tcp-port-number address-1?)))
	      ((not network-1?)
	       (cond ((suitable-string-for-tcp-address? address-1?)
		      (setf gsi-extension-tcp-address?
			    (text-string-parse-integer address-1?))
		      (return-from derive-network-listeners t))
		     (t
		      (gsi-init-error 'derive_network_listeners
				      gsi-invalid-protocol address-1?)
		      (return-from derive-network-listeners nil))))
	      (t
	       ;; includes #w"decnet" case
	       (gsi-init-error 'derive_network_listeners
			       gsi-invalid-protocol network-1?)
	       (return-from derive-network-listeners nil))))
    t))

;; This function looks at the command line starting at an index
;; specified by its only input argument.  It attempts to parse out one
;; address and one network token (note that an address token does not
;; have a preceding keyword) in order e.g. if it immediately happens
;; on a network token (identified by a preceding '-network' key) it
;; will return nil for the address token.  This fucntion returns
;; three values: the command line index where a search for a second
;; pair of tokens should begin (this code does not support more than
;; two passess); a network token; and an address token. 29oct93 paf!

(defparameter gsi-flag-arguments
  '(#w"-tcpipexact" #w"-nolistener" #w"-noconnect" #w"-connect" #w"-secure"))

(defparameter gsi-keyword-arguments
  '(#w"-network" #w"-tcpport" #w"-cert"
    #w"-connect-interface-name" #w"-connect-class-name"
    #w"-connect-network" #w"-connect-host" #w"-connect-port"
    #w"-connect-initialization-string"))

;; paf! 29oct93.  Added defvar unix-command-line-argument-count and cache it when
;; the command line is cached.  This so that *all* command line info is accessible
;; in development environment.

(defun get-gensym-command-line-argument-count ()
  unix-command-line-argument-count)


(defun get-listener-from-command-line (command-line-index)
  (loop with argument-count = (get-gensym-command-line-argument-count)
	with token
	with network? = nil
	with address? = nil
	for i from command-line-index below argument-count
	until network?
	do
    (setf token (get-gensym-command-line-argument-as-text-string i))
    (cond
      ((string-equalw token #w"-network")
       (setf network? (get-gensym-command-line-argument (+f i 1))))
      ((member token gsi-flag-arguments :test #'string-equalw)
       )
      ((member token gsi-keyword-arguments :test #'string-equalw)
       (setf i (+f i 1)))
      (t
       (if address?
           (return (values i network? address?))
           (setf address? token))))
        finally (return (values (1+f i) network? address?))))

(defun gsi-no-listener-p ()
  (get-command-line-flag-argument #w"-nolistener"))

(defun gsi-no-connect-p ()
  (get-command-line-flag-argument #w"-noconnect"))

(defun gsi-connect-p ()
  (get-command-line-flag-argument #w"-connect"))

(defvar gsi-command-line-network nil)
(defvar gsi-command-line-host nil)
(defvar gsi-command-line-port nil)

(defun get-connect-address-from-command-line ()
  (let ((interface-name (get-command-line-keyword-argument #w"-connect-interface-name"))
	(class-name (get-command-line-keyword-argument #w"-connect-class-name"))
	(network (get-command-line-keyword-argument #w"-connect-network"))
	(host (get-command-line-keyword-argument #w"-connect-host"))
	(port (get-command-line-keyword-argument #w"-connect-port"))
	(init-string (get-command-line-keyword-argument #w"-connect-initialization-string")))
    (when (equalw interface-name #w"") (setq interface-name nil))
    (when interface-name
      (setq interface-name (gsi-intern (copy-text-string interface-name))))
    (when (equalw class-name #w"") (setq class-name nil))
    (when class-name
      (setq class-name (gsi-intern (copy-text-string class-name))))
    (when (or interface-name class-name network host port init-string)
      (setq gsi-command-line-network network)
      (setq gsi-command-line-host host)
      (setq gsi-command-line-port port)
      (values interface-name
	      class-name
	      network host port
	      init-string))))

(defun gsi-get-network-configuration (network host port &optional (secure? secure-icp-default-p))
  (when (equalw host #w"") (setq host nil))
  (unless host (setq host gsi-command-line-host))
  (unless (and host (not (equalw host #w""))) (setq host #w"localhost"))

  (when (equalw network #w"") (setq network nil))
  (unless network (setq network gsi-command-line-network))
  (unless (and network (not (equalw network #w""))) (setq network #w"T"))
  (let ((network-symbol
	  (cond ((char-equalw (charw network 0) #.%\T) 'tcp-ip)
		(t
		 (gsi-message "~%Unknown network type ~A~%" network)
		 (return-from gsi-get-network-configuration nil)))))

    (when (equalw port #w"") (setq port nil))
    (when (and (null port)
	       gsi-command-line-port (not (equalw #w"" gsi-command-line-port))
	       (or (null gsi-command-line-network)
		   (char-equalw (aref gsi-command-line-network 0)
				(aref network 0))))
      (setq port gsi-command-line-port))
    (unless port (setq port (if (eq network-symbol 'tcp-ip)
				#w"1111" #w"G20")))
    (gsi-list network-symbol host port secure?)))

;; TCP address verifier.

(defun-simple suitable-string-for-tcp-address? (string?)
  (if (and string?
	   (loop for index from 0 below (text-string-length string?)
		 always (digit-char-pw (charw string? index))))
      string?))

(defun-simple get-preset-tcp-port-number ()
  (let ((tcp-address? (call-gsi-callback gsi-get-tcp-port)))
    (when (minusp tcp-address?)
      (gsi-error 'get_preset_tcp_port gsi-invalid-tcp-port-number tcp-address?))
    (if (= tcp-address? 0)
	nil
	tcp-address?)))

;; This last call to GET-PRESENT-TCP-PORT-NUMBER is stylistically
;; ugly.  We check for a user-defined TCP port number earlier in
;; DERIVE-NETWORK-LISTENERS, but this value is not carried through the
;; entirety of the command line argument parsing.  In the interest of
;; closing HQ-2378721, we'll just test a second time rather than
;; attempt to correct the parsing hair (and possibly mess up more
;; stuff).

(defun-simple gsi-store-desired-tcp-port-number (port-number?)
  (if port-number?
      (if (suitable-string-for-tcp-address? port-number?)
	  (setf gsi-extension-tcp-address? (text-string-parse-integer port-number?))
	  (gsi-init-error 'derive_network_listeners
			    gsi-invalid-tcp-port-number port-number?))
      (setf gsi-extension-tcp-address? (or (get-preset-tcp-port-number) default-gsi-extension-tcp-address))))


;; jh, 10/21/93.  Establish-gsi-extension-listeners was adapted from
;; establish-network-listeners in INT4.	 Consider abstracting or at least
;; changing the names to contrast better - establish-network-listeners sounds
;; too generic.
;;  Changed the name of establish-network-listeners to
;; establish-g2-network-listeners. -ncc, 8/22/94
;;
(defun establish-gsi-listeners ()
  (let* ((specified-tcp-address
	  (or gsi-extension-tcp-address?
	      (get-command-line-keyword-argument-as-integer #w"tcpport")))
	(allow-default-addresses-p
	  (not specified-tcp-address))
	(listener-count
	  (establish-initial-gsi-listener
		specified-tcp-address
		allow-default-addresses-p)))
    (when (=f listener-count 0)
      (gsi-init-error nil gsi-noop-code-accessed)
      (shutdown-or-exit)))
  (let ((listeners (get-local-host-addresses)))
    (when listeners
      (let ((message
	      (twith-output-to-text-string
		      (tformat "Waiting to accept a connection on:~%")
		      (loop with host-name = (get-local-host-name)
			    for listener in listeners
			    do (tformat "~a:~a:~a~a~%"
					(first listener)
					host-name
					(second listener)
					(secure-icp-string :secure-p (third listener)))))))
	(reclaim-network-addresses listeners)
	(gsi-message message)
	(reclaim-text-string message))))
  t)

(defun-simple establish-initial-gsi-listener
    (specified-address allow-default-addresses-p)
  (if (or specified-address allow-default-addresses-p)
      (progn 
	(when (secure-icp-requested-p)
	  (set-up-secure-icp 'default))
	(let ((error-code
		(establish-gsi-listener
		  (or specified-address
		      default-gsi-extension-tcp-address)
		  (get-command-line-flag-argument
		    #w"tcpipexact")
		  (secure-icp-requested-p))))
	  (cond ((null error-code)
		 1)
		((=f error-code gsi-noop-code-accessed)
		 0)
		(t
		 (gsi-init-error nil error-code)
		 (shutdown-or-exit)))))
      0))

(defun establish-gsi-listener (address exact-p &optional (secure-p secure-icp-default-p))
  (let* ((listen-status (c-network-listen
			  use-tcpip-protocol-only
			  (if (fixnump address)
			      address
			      (or (text-string-parse-integer address)
				  default-gsi-extension-tcp-address))
			  (if exact-p 1 0)
			  gsi-product-tag
			  (if secure-p 1 0)))
	 (error-code (cond ((eql listen-status #.icp-noop-network-code-accessed)
			    gsi-noop-code-accessed)
			   ((and (not (eql listen-status #.icp-connection-succeeded-tag))
				 exact-p)
			    gsi-cannot-establish-listener))))
    (when error-code
      (return-from establish-gsi-listener error-code))
    (let ((connection-name (get-network-listener 0)))
      (when (null tcp-listener-port-number)
	(setq tcp-listener-port-number (get-tcp-listener-port-number connection-name)))
      (register-icp-callback 'icp-accept
	'register-gsi-connection-callbacks
	(make-and-install-network-listener
	  (ne-get-listener-handle 0)
	  connection-name))))
  nil)

(def-gsi-api-function (gsi-establish-listener (:return-type gsi-fixnum-long))
                      ((network text-string)
		       (port    text-string)
		       (exact   gsi-fixnum-long))
  (let ((error-code (establish-gsi-listener port (not (=f exact 0)) nil)))
    network
    (when error-code
      (gsi-api-error error-code))
    1))

(def-gsi-api-function (gsi-establish-secure-listener (:return-type gsi-fixnum-long))
                      ((network text-string)
		       (port    text-string)
		       (exact   gsi-fixnum-long)
		       (cert    text-string-or-null))
  (when (and cert (not secure-icp-initialized-p))
    (when cert (update-server-certificate cert))
    (set-up-secure-icp))
  (let ((error-code (establish-gsi-listener port (not (=f exact 0)) 1)))
    network
    (when error-code
      (gsi-api-error error-code))
    1))

(def-gsi-api-function (gsi-close-listeners (:return-type :null)) ()
  (dolist-safely (icp-socket active-icp-sockets)
    (when (=f (icp-connection-state icp-socket) icp-socket-listening)
      (close-and-disconnect-icp-socket-handle icp-socket))))

(def-system-variable gsi-icp-sockets-waiting-for-connect INT2 nil)

;;returns context or gsi-undefined-context
(defun initiate-gsi-connection (interface-name class-name keep-connection-on-g2-reset
				network host port
				remote-process-initialization-string
				context-user-data
				secure)
  (let* ((application (current-gsi-application))
	 (localp (string-equalw #w"LOCAL" network))
	 (network-configuration
	   (gsi-get-network-configuration network host port secure))
	 (network+host+port (or (if localp
				    (copy-constant-wide-string #w"LOCAL")
				    (make-network-pathname network-configuration))
				(progn
				  (reclaim-gsi-list network-configuration)
				  (return-from initiate-gsi-connection gsi-undefined-context))))
	 (icp-socket (or (unless (and (>=f gsi-maximum-number-of-contexts 0)
				      (>=f number-of-contexts-allocated
					   gsi-maximum-number-of-contexts))
			   (if localp
			       (make-localnet-connection
				 (copy-constant-wide-string #w"LOCAL") 'g2)
			       (make-network-connection network-configuration)))
			 (progn
			   (reclaim-wide-string network+host+port)
			   (reclaim-gsi-list network-configuration)
			   (return-from initiate-gsi-connection gsi-undefined-context))))
	 (current-icp-socket icp-socket)
	 (gsi-extension-data (gsi-extension-data? icp-socket))
	 (remote-process-initialization-string
	   (when remote-process-initialization-string
	     (copy-text-string remote-process-initialization-string))))
    (reclaim-gsi-list network-configuration)
    (setf (icp-socket-gsi-application-name icp-socket)
	  (gsi-application-name-symbol application))
    (setf (gsi-extension-application gsi-extension-data) application)
    (setf (gsi-context-number (gsi-extension-data? icp-socket))
	  (let ((current-icp-socket icp-socket))
	    (allocate-gsi-context-number)))
    (setf (gsi-extension-data-user-data gsi-extension-data) context-user-data)
    (gsi-push (gsi-list icp-socket network+host+port
			interface-name class-name
			keep-connection-on-g2-reset
			remote-process-initialization-string)
	      gsi-icp-sockets-waiting-for-connect)
    (register-icp-callback 'icp-connection-loss 'gsi-maybe-notice-delayed-connection-failure icp-socket)
    (when (gsi-option-is-set-p gsi-disable-interleaving)
      (setf (icp-socket-does-not-allow-resumability icp-socket) 'requested))
    (setup-network-connection-for-connect icp-socket 'gsi-maybe-initiate-delayed-connection)
    (gsi-current-context-number)))

(defun initiate-gsi-connection-after-connect (network+host+port icp-socket
					      interface-name class-name
					      keep-connection-on-g2-reset
					      remote-process-initialization-string)
  (let* ((current-icp-socket icp-socket)
	 (connect-protocol-char (charw network+host+port 0))
	 (listeners (get-local-host-addresses))
	 (listener (when listeners (first listeners)))
	 (listener-protocol nil)
	 (listener-port-name nil))
    (setf (icp-socket-listener-client? icp-socket) 'g2)
    (register-gsi-connection-callbacks nil icp-socket)
    (gsi-message "~%Connected to: ~A~A~%" network+host+port
		 (secure-icp-string :secure-p (icp-connection-is-secure current-icp-socket)))
    (reclaim-text-string network+host+port)
    (when listener
      (unless (or (char-equalw connect-protocol-char (charw (first listener) 0))
		  (null (cdr listeners)))
	(setq listener (second listeners)))
      (setq listener-protocol (cond ((equalw (first listener) #w"TCP_IP") 'TCP-IP)
				    (t nil)))
      (setq listener-port-name (second listener)))
    ;; create and initialize an interface object
    (writing-icp-message-group ((icp-output-port icp-socket))
      (send-icp-initialize-gsi-interface
	interface-name class-name keep-connection-on-g2-reset
	listener-protocol
	(get-local-host-name)
	(or listener-port-name #w"")
	(or remote-process-initialization-string #w"")))
    (reclaim-network-addresses listeners)
    (when remote-process-initialization-string
      (reclaim-text-string remote-process-initialization-string))
    ;; G2 activate-gsi-interface-with-socket
    ;; G2 finalize-gsi-connection
    ;; G2 write-message-group-upon-gsi-interface-activation
    ;; G2->GSI initialize-data-server
    ;; GSI send-version-info
    ;; GSI->G2 return-peer-version
    ;; G2 return-gsi-extension-version-body
    ;; G2 send-version-info
    ;; G2->GSI return-peer-version
    ;; GSI gsi-initialize-context API callback
    (gsi-current-context-number)))

(defun-void gsi-maybe-initiate-delayed-connection (icp-socket)
  (let ((a (assq icp-socket gsi-icp-sockets-waiting-for-connect)))
    (when a
      (setq gsi-icp-sockets-waiting-for-connect
	    (delete-gsi-element a gsi-icp-sockets-waiting-for-connect))
      (gensym-dstruct-bind ((icp-socket
			     network+host+port interface-name class-name
			     keep-connection-on-g2-reset remote-process-initialization-string)
			   a)
	(reclaim-gsi-list a)
	(initiate-gsi-connection-after-connect
	  network+host+port icp-socket
	  interface-name class-name
	  keep-connection-on-g2-reset remote-process-initialization-string)))))

(defun-void gsi-maybe-notice-delayed-connection-failure (icp-socket)
  (let ((a (assq icp-socket gsi-icp-sockets-waiting-for-connect)))
    (when a
      (setq gsi-icp-sockets-waiting-for-connect
	    (delete-gsi-element a gsi-icp-sockets-waiting-for-connect))
      (let ((network+host+port (second a))
	    (remote-process-initialization-string (sixth a))
	    (current-icp-socket icp-socket))
	(reclaim-gsi-list a)
	(gsi-error-no-exit '|gsi_initiate_connection|
			   gsi-error-in-connect
			   ;;network+host+port
			   (reason-for-shutdown? icp-socket))
	(reclaim-text-string network+host+port)
	(when remote-process-initialization-string
	  (reclaim-text-string remote-process-initialization-string))
	t))))



(def-system-variable gsi-wakeup-icp-socket INT2 nil)
(def-system-variable gsi-wakeup-icp-socket-active-p INT2 nil)

;;returns context or gsi-undefined-context
(defun initiate-gsi-wakeup-connection ()
  (unless gsi-wakeup-icp-socket
    (let* ((listeners (get-local-host-addresses))
	   (listener (when listeners (first listeners)))
	   (connection-configuration
	     (gsi-list (first listener) (get-local-host-name) (second listener)))
	   ;; (network+host+port (make-network-pathname connection-configuration))
	   (icp-socket (or (make-network-connection connection-configuration)
			   (return-from initiate-gsi-wakeup-connection nil))))
      (reclaim-gsi-list connection-configuration)
      (setq gsi-wakeup-icp-socket icp-socket)
      (register-icp-callback 'icp-connection-loss
	'gsi-wakeup-maybe-notice-delayed-connection-failure icp-socket)
      (setup-network-connection-for-connect
	icp-socket 'gsi-wakeup-maybe-initiate-delayed-connection)))
  gsi-wakeup-icp-socket)

(defun-void gsi-wakeup-maybe-initiate-delayed-connection (icp-socket)
  (declare (ignore icp-socket))
  (setf (icp-socket-listener-client? icp-socket) 'gsi)
  (setq gsi-wakeup-icp-socket-active-p t))

(defun-void gsi-wakeup-maybe-notice-delayed-connection-failure (icp-socket)
  (declare (ignore icp-socket))
  (setq gsi-wakeup-icp-socket nil)
  (setq gsi-wakeup-icp-socket-active-p nil))





;;;; GSI API Functions

(def-gsi-api-function (gsi-set-context-limit
			(:return-type :null)
			(:needs-catch-p nil))
                      ((limit gsi-fixnum-long))
  (setq gsi-maximum-number-of-contexts limit)) ; negative means unlimited

(def-gsi-api-function (gsi-set-local-home
			(:return-type :null)
			(:needs-catch-p nil))
                      ((home :object))
  (setq gsi-local-home home))

;; These are functions available to GSI applications developers (i.e.
;; customers) and are mostly used to send data to G2.

;; Note that most use the macro within-gsi-context which binds the special
;; variable derived-socket.

;;;
;;; gsi-flush-internal can only be used inside a within-gsi-context form!!!
;;;

(defmacro gsi-flush-internal (&optional gsi-flush-p)
  `(gsi-flush-internal-1 derived-socket ,gsi-flush-p))



;;; gsi-flush
;;;  the API function.	gsi-flush-internal is the workhorse, and
;;;  is used by other functions internal to GSI.
;;;
(def-gsi-api-function (gsi-flush (:return-type :null))
		      ((context	gsi-fixnum-long))
  (within-gsi-context context
    (gsi-flush-internal t)))


;;; feature added to GSI 3.2, and duplicated in 4.0 for the
;;; simultaneous release of both products.
(def-gsi-api-function (gsi-kill-context (:return-type :null))
		      ((context gsi-fixnum-long))
  (within-gsi-context context
    (flush-and-shutdown-icp-socket derived-socket)))


;;; same story as preceding

(def-gsi-api-function (gsi-context-received-data
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ((context gsi-fixnum-long))
  (let ((derived-socket (resolve-gsi-context context)))
    (if (icp-socket-saw-io? derived-socket)
	1
	0)))


;;;  new API function for GSI 4.0 Rev. 2: gsi-listener-socket
;;;
;;;  gsi-listener-socket returns the file descriptor representing the TCP/IP
;;;  listener for this GSI bridge, if there is one.  If there isn't (for
;;;  whatever reason), then the value -1 is returned (an invalid
;;;  filedescriptor).
;;;
;;;
(def-gsi-api-function (gsi-listener-socket
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ()
  (c-network-get-listener-fd))


;;;  new API function for GSI 4.0 Rev. 2: gsi-context-socket
;;;
;;;  gsi-context-socket takes a GSI context number, and for contexts that are
;;;  running over tcp/ip, returns a unix file descriptor naming the socket that
;;;  is being used by the ICP internals for the given context.
(def-gsi-api-function (gsi-context-socket
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ((context gsi-fixnum-long))
  (let ((derived-socket (resolve-gsi-context context)))
    (let* ((connection-handle (icp-connection-handle (icp-input-port derived-socket))))
      (c-network-get-fd-from-handle connection-handle))))

(def-gsi-api-function (gsi-context-remote-start-time
			(:return-type gsi-float)
			(:needs-catch-p nil))
		      ((context gsi-fixnum-long))
  (let ((remote-g2-time-at-start
	  (get-remote-g2-time-at-start (resolve-gsi-context context))))
    (if remote-g2-time-at-start
	(managed-float-value remote-g2-time-at-start)
	0.0)))

(def-gsi-api-function (gsi-context-remote-host
			(:return-type text-string-or-null))
		      ((context gsi-fixnum-long))
  (get-remote-host-name (resolve-gsi-context context)))

(def-gsi-api-function (gsi-context-remote-port
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ((context gsi-fixnum-long))
  (get-remote-listener-port (resolve-gsi-context context)))

(def-gsi-api-function (gsi-context-remote-home
			(:return-type :object))
    ((context gsi-fixnum-long))
  (let* ((icp-socket (resolve-gsi-context context))
	 (extension-data (gsi-extension-data? icp-socket)))
    (or (gsi-remote-home-for-context extension-data)
	(setf (gsi-remote-home-for-context extension-data)
	      (let* ((name (get-remote-home-name icp-socket))
		     (type (cond ((null name)
				  gsi-null-type-tag)
				 ((symbolp name)
				  gsi-symbol-type-tag)
				 ((or (gensym-string-p name)
				      (text-string-p name))
				  gsi-string-type-tag)
				 (t
				  (setq name nil)
				  gsi-null-type-tag))))
		(when type
		  (make-gsi-instance
		    type name nil nil nil 'context)))))))

(def-gsi-api-function (gsi-context-user-data
			(:return-type :object)
			(:needs-catch-p nil))
                      ((context gsi-fixnum-long))
  (gsi-extension-data-user-data
    (gsi-extension-data?
      (resolve-gsi-context context))))

(def-gsi-api-function (gsi-set-context-user-data
			(:return-type :null)
			(:needs-catch-p nil))
                      ((context gsi-fixnum-long)
		       (user-data :object))
  (setf (gsi-extension-data-user-data
	  (gsi-extension-data?
	    (resolve-gsi-context context)))
	user-data))

(def-gsi-api-function (gsi-initiate-connection (:return-type gsi-fixnum-long))
    ((interface-name                       gsi-symbol-or-nil)
     (class-name                           gsi-symbol-or-nil)
     (keep-connection-on-g2-reset          gsi-fixnum-long)
     (network                              text-string-or-null)
     (host                                 text-string-or-null)
     (port                                 text-string-or-null)
     (remote-process-initialization-string text-string-or-null))
  (if (=f gsi-undefined-context
	  (initiate-gsi-connection interface-name
				   class-name
				   (/=f 0 keep-connection-on-g2-reset)
				   network host port
				   remote-process-initialization-string
				   nil
				   nil)) ;secure nil
      gsi-failure
      gsi-success))

(def-gsi-api-function (gsi-initiate-connection-w-u-d
			(:return-type gsi-fixnum-long))
    ((interface-name                       gsi-symbol-or-nil)
     (class-name                           gsi-symbol-or-nil)
     (keep-connection-on-g2-reset          gsi-fixnum-long)
     (network                              text-string-or-null)
     (host                                 text-string-or-null)
     (port                                 text-string-or-null)
     (remote-process-initialization-string text-string-or-null)
     (context-user-data                    :object))
  (if (=f gsi-undefined-context
	  (initiate-gsi-connection interface-name
				   class-name
				   (/=f 0 keep-connection-on-g2-reset)
				   network host port
				   remote-process-initialization-string
				   context-user-data
				   nil))
      gsi-failure
      gsi-success))

(def-gsi-api-function (gsi-initiate-secure-connection (:return-type gsi-fixnum-long))
    ((interface-name                       gsi-symbol-or-nil)
     (class-name                           gsi-symbol-or-nil)
     (keep-connection-on-g2-reset          gsi-fixnum-long)
     (network                              text-string-or-null)
     (host                                 text-string-or-null)
     (port                                 text-string-or-null)
     (remote-process-initialization-string text-string-or-null))
  (if (=f gsi-undefined-context
	  (initiate-gsi-connection interface-name
				   class-name
				   (/=f 0 keep-connection-on-g2-reset)
				   network host port
				   remote-process-initialization-string
				   nil
				   'secure))
      gsi-failure
      gsi-success))

(def-gsi-api-function (gsi-initiate-secure-conn-w-u-d
			(:return-type gsi-fixnum-long))
    ((interface-name                       gsi-symbol-or-nil)
     (class-name                           gsi-symbol-or-nil)
     (keep-connection-on-g2-reset          gsi-fixnum-long)
     (network                              text-string-or-null)
     (host                                 text-string-or-null)
     (port                                 text-string-or-null)
     (remote-process-initialization-string text-string-or-null)
     (context-user-data                    :object))
  (if (=f gsi-undefined-context
	  (initiate-gsi-connection interface-name
				   class-name
				   (/=f 0 keep-connection-on-g2-reset)
				   network host port
				   remote-process-initialization-string
				   context-user-data
				   'secure))
      gsi-failure
      gsi-success))

(defun-void wakeup-gsi-internal ()
  (writing-icp-message-group ((icp-output-port gsi-wakeup-icp-socket))
    (send-icp-nop 0))
  (flush-icp-output-ports))

(def-gsi-api-function (gsi-wakeup
			(:return-type gsi-fixnum-long))
                      ()
  (cond ((null gsi-wakeup-icp-socket)
	 (if (initiate-gsi-wakeup-connection)
	     0
	     -1))
	(gsi-wakeup-icp-socket-active-p
	 (wakeup-gsi-internal)
	 1)
	(t
	 -1)))

(def-gsi-api-function (gsi-last-error
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil)) ()
  gsi-most-recent-error)

(def-gsi-api-function (gsi-last-error-message
			(:return-type gsi-string)
			(:needs-catch-p nil)) ()
  (or gsi-most-recent-error-message ""))

(def-gsi-api-function (gsi-last-error-call-handle
			(:return-type :object)
			(:needs-catch-p nil)) ()
  gsi-most-recent-error-remote-procedure-identifier)

(def-gsi-api-function (gsi-clear-last-error
			(:return-type :null)
			(:needs-catch-p nil)
			(:initializes-gsi t)) ()
  (gsi-set-most-recent-error 0))

(def-gsi-api-function (gsi-error-message
			(:return-type gsi-string))
                      ((error-code gsi-fixnum-long))
  (unless (and (>f error-code 0)
	       (<f error-code gsi-base-user-error-code))
    (setq error-code gsi-error-code-out-of-range))
  (car (cdr (assq error-code gsi-error-code-table))))

(def-gsi-api-function (gsi-signal-error
			(:return-type :null))
                      ((originating-user-function gensym-string)
		       (user-error-code		  gsi-fixnum-long)
		       (user-message		  gensym-string))
  (if (>f user-error-code gsi-base-user-error-code)
      (gsi-error-no-exit originating-user-function gsi-custom-user-error user-error-code user-message)
      (gsi-error-no-exit 'gsi_signal_error gsi-reserved-error-code user-error-code gsi-base-user-error-code)))

;;; flush-icp-output-buffers is to be used only by GSI, for the express purpose
;;; of modifying the behavior of gsi gsi-return-* functions and others which
;;; send data to G2. The desired behavior in GSI is that data be sent
;;; immediately.  (The ordinary ICP behavior is to buffer it up and send it in
;;; the janitorial code in process-icp-sockets.)
;;;
;;;  In GSI, we need to check for inactive ICP sockets independently from the
;;;  code in process-icp-sockets. This is because the user may operate outside
;;;  the context of this code, and may not call it for quite extended periods of
;;;  time.  Logically, this is the place to apply this band-aid, since it's
;;;  called inside all the GSI functions that send messages to G2.
;;;     -ncc, 13 Feb 1995
;;;

(defun-simple run-one-gsi-scheduler-cycle ()
  (schedule-processing-for-inhibited-messages) ; may be needed, in case of non-local exit
  (with-temporary-creation run-gsi-scheduler-cycle
    (loop with task-scheduling-start-time = (get-fixnum-time)
	  for time-slice-start-time = task-scheduling-start-time
				    then current-fixnum-time
	  for no-tasks-were-executed-this-pass
	      = (with-temporary-gensym-float-creation run-scheduler-task
		  (not (dequeue-and-execute-next-task)))
	  for current-fixnum-time = (get-fixnum-time)
	  until (or no-tasks-were-executed-this-pass
		    (>=f (fixnum-time-difference
			   current-fixnum-time task-scheduling-start-time)
			 gsi-scheduled-tasks-time-limit))))
  (enqueue-scheduler-events-if-necessary nil))

(defun-allowing-unwind gsi-flush-internal-1 (derived-socket gsi-flush-p)
  (when (and (or gsi-flush-p
		 (not (gsi-option-is-set-p gsi-no-flush)))
	     (/=f (icp-connection-state derived-socket) icp-connection-closed))
    (let ((icp-output-port (icp-output-port derived-socket)))
      (cond ((and (=f (icp-connection-state derived-socket) icp-connection-running)
		  (icp-port-blocked? icp-output-port))
	     (with-scheduler-enabled
	       (with-inhibited-icp-message-processing
		 (with-icp-socket-reclamation
		   (loop do (gsi-event-cycle-handling-windows-quit)
			 while (and (=f (icp-connection-state derived-socket) icp-connection-running)
				    (icp-port-blocked? icp-output-port))
			 do (when gsi-wakeup-icp-socket-active-p
			      (wakeup-gsi-internal))
			    (gsi-event-wait))))))
	    (t
	     (when gsi-wakeup-icp-socket-active-p
	       (wakeup-gsi-internal)))))))


(defun-simple gsi-event-wait ()
  (enqueue-scheduler-events-if-necessary nil)
  (let ((top-level-error-catcher-tag nil))
    (loop until (or (g2-event-ready-p)
		    (null (milliseconds-to-next-scheduler-event)))
	  do (before-gsi-wait-callback)
	     (g2-event-wait)
	     (after-gsi-wait-callback))
    nil))

(def-gsi-api-function (gsi-is-idle
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil)) ()
  (if (g2-event-ready-p)
      0
      (or (milliseconds-to-next-scheduler-event)
	  0)))

(def-gsi-api-function (gsi-has-network-connections
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil)) ()
  (if (visible-window-is-present-p)
      1 ; counts as a network connection
      (loop for icp-socket in active-icp-sockets
	    unless (or (eq (type-of-icp-connection icp-socket) 'localnet)
		       (=f (icp-connection-state icp-socket) icp-connection-closed)
		       (=f (icp-connection-state icp-socket) icp-socket-listening))
	      return 1
	    finally (return 0))))

(def-gsi-api-function (gsi-set-pause-timeout
			(:return-type :null)
			(:needs-catch-p nil))
		      ((max-idle-time gsi-fixnum-long))
  (setf gsi-maximum-idle-interval max-idle-time))

(def-gsi-api-function (gsi-pause
			(:return-type :null)
			(:needs-catch-p nil))
                      ()
  (gsi-event-wait))

(def-gsi-api-function (gsi-set-run-loop-timeout
			(:return-type :null)
			(:needs-catch-p nil))
		      ((max-run-time gsi-fixnum-long))
  (setf gsi-scheduled-tasks-time-limit max-run-time))

(def-gsi-api-function (gsi-run-loop (:return-type :null))
                      ()
  (when (gsi-option-is-set-p gsi-trace-run-loop)
    (format t "Entering gsi_run_loop~%"))

  (current-system-case
    #+gsi-in-g2
    (ab
      (reset-counters-for-all-icp-sockets)
      (let ((within-run-loop-extent t)
	    (current-system-name 'ab))
	(g2-event-loop)))
    (gsi
      (when within-run-loop-extent
	(gsi-api-error gsi-illegal-nesting-of-run-loop))
      (do-minimal-error-trapping (abort-gsi-top-level)
	(enter-abyss))))

  (when (gsi-option-is-set-p gsi-trace-run-loop)
    (format t "Leaving gsi_run_loop~%")))

(defun-allowing-unwind enter-abyss ()
  (reset-counters-for-all-icp-sockets)
  (let ((within-run-loop-extent t))
    (loop named outer-loop
	  do (with-handling-icp-messages t
	       (with-icp-socket-reclamation
		 (catch-abort (0)
		   (when *scheduler-enabled?*
		     (enqueue-scheduler-events-if-necessary nil))
		   (loop do
		     (with-scheduler-enabled
		       (gsi-event-cycle-handling-windows-quit))
		     (when (gsi-option-is-set-p gsi-one-cycle)
		       (return-from outer-loop nil))
		     (unless (or (g2-event-ready-p)
				 (null (milliseconds-to-next-scheduler-event)))
		       (call-gsi-callback gsi-idle))
		     (gsi-event-wait))))))))

;;; gsi-return-message now flushes buffers after running.  -ncc, 18 Jan 1995
;;;
(def-gsi-api-function (gsi-return-message (:return-type :null))
		      ((message	  text-string)
		       (context	  gsi-fixnum-long))
  (with-gsi-message-group-context context
    (send-icp-write-user-message-string
      message nil nil (gsi-option-is-set-p gsi-do-not-reformat-messages))))




(defmacro simplify-gsi-attribute-spec (spec)
  (avoiding-variable-capture (spec)
    `(if (and (consp ,spec)
	      (eq (car ,spec) 'attribute)
	      (null (resumable-attribute-class-qualifier? ,spec)))
	 (resumable-attribute-base-name ,spec)
	 ,spec)))

;;;
;;;There is an undeclared argument to this writer, gsi-vector-length.
;;;This is a special which is bound before calling any message which uses this
;;;icp-value-type.  -ncc, 7/28/94
;;;
(defun-simple check-gsi-value-vector (gsi-value-vector)
  (loop with length = (1-f (gsi-managed-array-length gsi-value-vector))
	for index from gsi-magic-offset below (+f length gsi-magic-offset)
	as attribute? = (gsi-managed-svref gsi-value-vector index)
	as value? = (if (gsi-attribute-p attribute?)
			(gsi-attribute-instance attribute?)
			(return-from check-gsi-value-vector
			  gsi-incompatible-structure))
	do
    (unless (gsi-instance-p value?)
      (return-from check-gsi-value-vector gsi-incompatible-structure)))
  nil)

(def-icp-value-writer gsi-value-vector
  (loop with length = (1-f (gsi-managed-array-length gsi-value-vector))
	initially (write-icp-byte length)
	for index from gsi-magic-offset below (+f length gsi-magic-offset)
	as attribute? = (gsi-managed-svref gsi-value-vector index)
	as value? = (if (gsi-attribute-p attribute?)
			(gsi-attribute-instance attribute?))
	as type-tag = (gsi-instance-value-type value?)
	as timestamped-p = (if (gsi-instance-p value?)
			       (not (null (gsi-instance-timestamp value?))))
	as write-value-of-gsi-item-p
	   = (not (or (eq type-tag gsi-sequence-type-tag)
		      (eq type-tag gsi-structure-type-tag)))
	do (with-bifurcated-version-for-output
	       (value-vector-names-are-symbols-icp-version)
	     (write-icp-text-string
	       (symbol-name-text-string (gsi-attribute-qualified-name attribute?)))
	     (write-icp-icp-tree
	       (simplify-gsi-attribute-spec (gsi-attribute-spec attribute?))))
	   (write-icp-remote-value value?)
	   (write-icp-boolean timestamped-p)
	   (when timestamped-p
	     (write-icp-gsi-timestamp (gsi-instance-timestamp value?)))))

(defun-simple check-transfer-wrapper (transfer-wrapper timestamp-p icp-socket)
  (let ((input-port (icp-input-port icp-socket))
	transfer-wrapper-p)
    (multiple-value-bind (handle value)
	(cond ((setq transfer-wrapper-p (gsi-transfer-wrapper-p transfer-wrapper))
	       (values (gsi-transfer-sensor-or-index transfer-wrapper)
		       (gsi-transfer-instance transfer-wrapper)))
	      ((gsi-instance-p transfer-wrapper)
	       (values (if (and (with-bifurcated-version-for-output
				    (gsi-sends-returned-gsi-sensor-as-reference-icp-version
				      icp-socket)
				  nil
				  t)
				(gsi-item-reference-flag-value transfer-wrapper))
			   transfer-wrapper
			   (get-icp-object-index-for-gsi-instance transfer-wrapper input-port))
		       transfer-wrapper))
	      (t
	       (return-from check-transfer-wrapper
		 gsi-incompatible-structure)))
      (unless (and handle (gsi-instance-p value))
	(return-from check-transfer-wrapper gsi-incompatible-structure))
      (when (gsi-transfer-wrapper-p transfer-wrapper)
	(cond ((gsi-sensor-p handle))
	      ((null (get-gsi-instance-from-icp-port-if-any input-port handle))
	       (return-from check-transfer-wrapper
		 gsi-incompatible-structure))))
      (when timestamp-p
	(unless (managed-float-p (gsi-instance-timestamp value))
	  (return-from check-transfer-wrapper gsi-invalid-timestamp)))))
  nil)

(defun transfer-wrapper-components (transfer-wrapper timestamp-p icp-socket)
  (let ((input-port (icp-input-port icp-socket))
	transfer-wrapper-p)
    (multiple-value-bind (handle status value)
	(cond ((setq transfer-wrapper-p (gsi-transfer-wrapper-p transfer-wrapper))
	       (values (gsi-transfer-sensor-or-index transfer-wrapper)
		       (gsi-transfer-status transfer-wrapper)
		       (gsi-transfer-instance transfer-wrapper)))
	      ((gsi-instance-p transfer-wrapper)
	       (values (if (and (with-bifurcated-version-for-output
				    (gsi-sends-returned-gsi-sensor-as-reference-icp-version
				      icp-socket)
				  nil
				  t)
				(gsi-item-reference-flag-value transfer-wrapper))
			   transfer-wrapper
			   (get-icp-object-index-for-gsi-instance transfer-wrapper input-port))
		       no-error
		       transfer-wrapper)))
      (when (and (gsi-transfer-wrapper-p transfer-wrapper)
		 (gsi-sensor-p handle))
	(setq handle (gsi-sensor-index handle)))
      (values handle status value
	      (when timestamp-p (gsi-instance-timestamp value))))))

(defvar send-timestamp-with-gsi-sensor-p nil)

(defun-simple-resumable-icp-function send-icp-receive-values-for-gsi-sensors-with-timestamp
    (gsi-values)
  (let ((send-timestamp-with-gsi-sensor-p t))
    (send-icp-receive-values-for-gsi-sensors gsi-values)))

(defun-simple-resumable-icp-function send-icp-receive-values-for-gsi-sensors-without-timestamp
    (gsi-values)
  (let ((send-timestamp-with-gsi-sensor-p nil))
    (send-icp-receive-values-for-gsi-sensors gsi-values)))

(def-icp-value-writer gsi-values
  (let ((count (1-f (gsi-managed-array-length gsi-values)))
	(timestamp-p send-timestamp-with-gsi-sensor-p))
    (write-icp-boolean timestamp-p)
    (write-icp-fixnum count)
    (loop for index from gsi-magic-offset to count
	  as transfer-wrapper = (gsi-managed-svref gsi-values index)
	  do
      (multiple-value-bind (handle status value timestamp)
	  (transfer-wrapper-components transfer-wrapper timestamp-p current-icp-socket)
	(write-icp-returned-gsi-sensor handle)
	(write-icp-unsigned-integer status)
	(let ((write-value-of-gsi-item-p
		(with-bifurcated-version-for-output
		    (gsi-dataservice-uses-full-remote-value-protocol-icp-version)
		  t nil))
	      (saved-reference-p (gsi-item-reference-flag-value value)))
	  (when saved-reference-p (setf (gsi-item-reference-flag-value value) nil))
	  (write-icp-remote-value value)
	  (when saved-reference-p (setf (gsi-item-reference-flag-value value) t))
	  (when (and timestamp-p
		     (or write-value-of-gsi-item-p
			 (gsi-item-is-value-p value)))
	    (write-icp-gsi-timestamp timestamp)))))))

(defun gsi-return-values-internal (transfer-wrappers context timestamp-p)
  (let ((derived-socket (get-icp-socket-from-context context t)))
    (with-bifurcated-version (resumable-gsi-ds-icp-version derived-socket)
      (writing-icp-message-group ((icp-output-port derived-socket))
	(loop with count = (1-f (gsi-managed-array-length transfer-wrappers))
	      with message-count = 0
	      for index from gsi-magic-offset to count
	      as transfer-wrapper = (gsi-managed-svref transfer-wrappers index)
	      do
	  (when (=f 50 (incff message-count))
	    (setq message-count 0)
	    (next-icp-message-group))
	  (multiple-value-bind (handle status value timestamp)
	      (transfer-wrapper-components transfer-wrapper timestamp-p derived-socket)
	    (if timestamp-p
		(send-icp-receive-value-for-gsi-sensor-with-timestamp
		  handle status value timestamp)
		(send-icp-receive-value-for-gsi-sensor
		  handle status value)))))
      (send-or-enqueue-icp-write-task
	(icp-output-port derived-socket)
	resumable-priority-of-gsi-data-service
	(if timestamp-p
	    #'send-icp-receive-values-for-gsi-sensors-with-timestamp
	    #'send-icp-receive-values-for-gsi-sensors-without-timestamp)
	(icp-list transfer-wrappers)
	nil
	nil))
    (gsi-flush-internal)))

(defun gsi-return-attrs-internal (transfer-wrapper attributes context timestamp-p)
  (let ((derived-socket (get-icp-socket-from-context context t)))
    (multiple-value-bind (handle status value timestamp)
	(transfer-wrapper-components transfer-wrapper timestamp-p derived-socket)
      (with-bifurcated-version (resumable-gsi-ds-icp-version derived-socket)
	(writing-icp-message-group ((icp-output-port derived-socket))
	  (if timestamp-p
	      (send-icp-receive-timestamped-gsi-sensor-value-vector
		handle status value timestamp attributes)
	      (send-icp-receive-gsi-sensor-value-vector
		handle status value attributes)))
	(send-or-enqueue-icp-write-task
	  (icp-output-port derived-socket)
	  resumable-priority-of-gsi-data-service
	  (if timestamp-p
	      #'send-icp-receive-timestamped-gsi-sensor-value-vector
	      #'send-icp-receive-gsi-sensor-value-vector)
	  (if timestamp-p
	      (icp-list handle status value timestamp attributes)
	      (icp-list handle status value attributes))
	  nil
	  nil)))
    (gsi-flush-internal)))

;;; gsi-return-values now flushes buffers after running.  -ncc, 18 Jan 1995
;;; Need to use gsi-invalid-handle-of-nth index as the error message.
(def-gsi-api-function (gsi-return-values (:return-type :null))
                      ((transfer-wrappers (gsi-temporary-displaced-array count))
		       (count		  gsi-fixnum-long)
		       (context		  gsi-fixnum-long))
  (loop with icp-socket = (resolve-gsi-context-for-writing context)
	for index from gsi-magic-offset to count
	as transfer-wrapper = (gsi-managed-svref transfer-wrappers index)
	for error = (check-transfer-wrapper transfer-wrapper nil icp-socket)
	when error do (gsi-api-error error))
  (gsi-return-values-internal transfer-wrappers context nil))

;;; gsi-return-timed-values now flushes buffers after running.	-ncc, 18 Jan 1995
(def-gsi-api-function (gsi-return-timed-values (:return-type :null))
		      ((transfer-wrappers (gsi-temporary-displaced-array count))
		       (count		  gsi-fixnum-long)
		       (context		  gsi-fixnum-long))
  (loop with icp-socket = (resolve-gsi-context-for-writing context)
	for index from gsi-magic-offset to count
	as transfer-wrapper = (gsi-managed-svref transfer-wrappers index)
	for error = (check-transfer-wrapper transfer-wrapper t icp-socket)
	when error do (gsi-api-error error))
  (gsi-return-values-internal transfer-wrappers context t))

;;; gsi-return-attrs now flushes buffers after running.	 -ncc, 18 Jan 1995
(def-gsi-api-function (gsi-return-attrs (:return-type :null))
		      ((transfer-wrapper :object)
		       (attributes	 (gsi-temporary-displaced-array count))
		       (count		 gsi-fixnum-long)
		       (context		 gsi-fixnum-long))
  (let* ((icp-socket (resolve-gsi-context-for-writing context))
	 (error (or (check-transfer-wrapper transfer-wrapper nil icp-socket)
		    (check-gsi-value-vector attributes))))
    (when error (gsi-api-error error)))
  (gsi-return-attrs-internal transfer-wrapper attributes context nil))

;;; gsi-return-timed-attrs now flushes buffers after running.  -ncc, 18 Jan 1995
(def-gsi-api-function (gsi-return-timed-attrs (:return-type :null))
		      ((transfer-wrapper  :object)
		       (attributes	 (gsi-temporary-displaced-array count))
		       (count		 gsi-fixnum-long)
		       (context	 gsi-fixnum-long))
  (let* ((icp-socket (resolve-gsi-context-for-writing context))
	 (error (or (check-transfer-wrapper transfer-wrapper t icp-socket)
		    (check-gsi-value-vector attributes))))
    (when error (gsi-api-error error)))
  (gsi-return-attrs-internal transfer-wrapper attributes context t))

(defun-simple gsi-make-array-for-user-or-gsi (count user-or-gsi)
  (let ((array (gsi-allocate-managed-array (+f count gsi-magic-offset))))
    (when (or (eq user-or-gsi 'gsi) (eq user-or-gsi 'context))
      (gsi-push-onto-appropriate-list (make-gsi-array-wrapper 'managed-array array)))
    (gsi-set-up-array-for-c-access array)
    array))

(defun-simple gsi-make-items-for-user-or-gsi (count user-or-gsi)
  (let ((items (gsi-make-array-for-user-or-gsi count user-or-gsi)))
    (loop for i from gsi-magic-offset below (+f count gsi-magic-offset)
	  do (setf (gsi-managed-svref items i)
		   (make-gsi-instance-for-user-or-gsi user-or-gsi)))
    items))

(defun-simple gsi-make-attributes-for-user-or-gsi (count user-or-gsi)
  (let ((attributes (gsi-make-array-for-user-or-gsi count user-or-gsi)))
    (loop for i from gsi-magic-offset below (+f count gsi-magic-offset)
	  do (setf (gsi-managed-svref attributes i)
		   (make-gsi-attribute-for-user-or-gsi user-or-gsi)))
    attributes))

(defun-simple gsi-make-attributes-with-items-for-user-or-gsi (count user-or-gsi)
  (let ((attributes (gsi-make-array-for-user-or-gsi count user-or-gsi)))
    (loop for i from gsi-magic-offset below (+f count gsi-magic-offset)
	  for attribute = (make-gsi-attribute-for-user-or-gsi user-or-gsi)
	  do (setf (gsi-managed-svref attributes i)
		   attribute)
	     (setf (gsi-attribute-instance attribute)
		   (make-gsi-instance-for-user-or-gsi user-or-gsi)))
    attributes))

(def-gsi-api-function (gsi-make-array (:return-type (gsi-managed-array count)))
		      ((count  gsi-fixnum-long))
  (when (<f 0 count)
    (gsi-allocate-managed-array (+f count gsi-magic-offset))))

(def-gsi-api-function (gsi-reclaim-array (:return-type :null))
		      ((array gsi-managed-array-with-unspecified-length))
  (when array
    (gsi-reclaim-managed-array array)))

(def-gsi-api-function (gsi-make-item (:return-type :object))
		      ()
  (make-gsi-instance-for-user-or-gsi 'user))

(def-gsi-api-function (gsi-reclaim-item (:return-type :null))
                      ((item :object))
  (when item (reclaim-gsi-instance-for-user item)))

(def-gsi-api-function (gsi-make-items (:return-type (gsi-managed-array count)))
		      ((count  gsi-fixnum-long))
  (when (<f 0 count)
    (gsi-make-items-for-user-or-gsi count 'user)))

(def-gsi-api-function (gsi-reclaim-items (:return-type :null))
                      ((items gsi-managed-array-with-unspecified-length))
  (when items
    (loop for i from gsi-magic-offset below (gsi-managed-array-length items)
	  for instance = (gsi-managed-svref items i)
	  when instance do (reclaim-gsi-instance-for-user instance)
	  finally (gsi-reclaim-managed-array items))))


(def-gsi-api-function (gsi-make-registered-items (:return-type (gsi-managed-array count)))
		      ((count  gsi-fixnum-long))
  (let ((registered-items (gsi-allocate-managed-array (+f count gsi-magic-offset))))
    (loop for i from gsi-magic-offset below (+f count gsi-magic-offset)
	  for transfer-wrapper = (make-gsi-user-transfer-wrapper)
	  do (setf (gsi-transfer-instance transfer-wrapper) (make-gsi-instance-for-user-or-gsi 'user))
	     (setf (gsi-managed-svref registered-items i) transfer-wrapper))
    registered-items))

(def-gsi-api-function (gsi-reclaim-registered-items (:return-type :null))
		      ((registered-items gsi-managed-array-with-unspecified-length))
  (when registered-items
    (loop for i from gsi-magic-offset below (gsi-managed-array-length registered-items)
	  for transfer-wrapper = (gsi-managed-svref registered-items i)
	  do (reclaim-gsi-instance-for-user (gsi-transfer-instance transfer-wrapper))
	     (reclaim-gsi-user-transfer-wrapper transfer-wrapper)
	  finally (gsi-reclaim-managed-array registered-items))))

(def-gsi-api-function (gsi-make-attrs (:return-type (gsi-managed-array count)))
		      ((count  gsi-fixnum-long))
  (gsi-make-attributes-for-user-or-gsi count 'user))

(def-gsi-api-function (gsi-reclaim-attrs (:return-type :null))
		      ((attributes gsi-managed-array-with-unspecified-length))
  (when attributes
    (loop for i from gsi-magic-offset below (length attributes)
	  do (reclaim-gsi-user-attribute (gsi-managed-svref attributes i))
	  finally (gsi-reclaim-managed-array attributes))))

(def-gsi-api-function (gsi-make-attrs-with-items (:return-type (gsi-managed-array count)))
		      ((count  gsi-fixnum-long))
  (gsi-make-attributes-with-items-for-user-or-gsi count 'user))

(def-gsi-api-function (gsi-reclaim-attrs-with-items (:return-type :null))
		      ((attributes gsi-managed-array-with-unspecified-length))
  (loop for i from gsi-magic-offset below (gsi-managed-array-length attributes)
	do (reclaim-gsi-instance-for-user (gsi-attribute-instance (gsi-managed-svref attributes i)))
	   (reclaim-gsi-user-attribute (gsi-managed-svref attributes i))
	finally (gsi-reclaim-managed-array attributes)))



(def-gsi-api-function (gsi-make-symbol (:return-type gsi-api-symbol))
                      ((symbol gsi-symbol))
  symbol)

(def-gsi-api-function (gsi-symbol-name (:return-type gsi-symbol))
                      ((symbol gsi-api-symbol))
  symbol)


(def-gsi-api-function (gsi-symbol-user-data (:return-type :object))
                      ((symbol gsi-api-symbol))
  (gsi-user-data-of-symbol symbol))

(def-gsi-api-function (gsi-set-symbol-user-data (:return-type :null))
                      ((symbol gsi-api-symbol)
		       (user-data :object))
  (setf (gsi-user-data-of-symbol symbol) user-data))



;;;; GSI Data Structure Access Functions (more API functions)

;; These are functions available to GSI applications developers (i.e.
;; customers) and are used to create, delete, pack, and unpack the data
;; structures passed between G2 and GSI.

(def-gsi-api-function (gsi-current-context
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ()
  (gsi-current-context-number))

(def-gsi-api-function (gsi-current-context-is-secure
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ()
  (if (icp-connection-is-secure current-icp-socket)
      1 0))

(def-gsi-api-function (gsi-context-is-secure
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ((context	gsi-fixnum-long))
  (check-gsi-context context t)
  (if (icp-connection-is-secure (resolve-gsi-context context))
      1 0))

(def-gsi-api-function (gsi-registration-of-handle (:return-type :object))
		      ((item-index gsi-fixnum-long)
		       (context	   gsi-fixnum-long))
  (when (<=f 0 item-index)
    (or (when (and (<=f 0 context)
		   (=f context (gsi-current-context-number))
		   (=f item-index index-of-gsi-sensor-to-deregister?))
	  gsi-sensor-to-deregister?)
	(progn
	  (check-gsi-context context t)
	  (let ((gsi-instance (get-gsi-instance-from-icp-port-if-any
				(icp-input-port (resolve-gsi-context context))
				item-index)))
	    (when (gsi-instance-p gsi-instance)
	      gsi-instance))))))

(def-gsi-api-function (gsi-user-data-of
			(:return-type :object)
			(:needs-catch-p nil))
		      ((gsi-sensor :object))
  (unless (gsi-instance-p gsi-sensor)
    (gsi-api-error gsi-incompatible-structure))
  (gsi-instance-user-data gsi-sensor))

(def-gsi-api-function (gsi-set-user-data
			(:return-type :null)
			(:needs-catch-p nil))
		      ((gsi-sensor :object)
		       (ptr-or-immediate :object)) ; the user data
  (unless (gsi-instance-p gsi-sensor)
    (gsi-api-error gsi-incompatible-structure))
  (setf (gsi-instance-user-data gsi-sensor) ptr-or-immediate))

(def-gsi-api-function (gsi-item-of-identifying-attr-of (:return-type :object))
		      ((gsi-sensor :object)
		       (index	   gsi-fixnum-long))
  (unless (gsi-sensor-p gsi-sensor)
    (gsi-api-error gsi-structure-has-no-identifying-attrs))
  (let ((attribute-count (gsi-attribute-count gsi-sensor)))
    (when (or (<f index 1) (>f index attribute-count))
      (gsi-api-error gsi-identifying-attribute-index-out-of-range index)))
  (let ((attributes (gsi-attributes gsi-sensor)))
    (gsi-attribute-instance (gsi-typed-array-ref gsi-item attributes (1-f index)))))

(def-gsi-api-function (gsi-item-of-attr (:return-type :object))
		      ((attribute  :object))
  (unless (gsi-attribute-p attribute)
    (gsi-api-error gsi-incompatible-structure))
  (let ((item? (gsi-attribute-instance attribute)))
    (unless item?
      (gsi-api-error gsi-missing-instance-structure))
    item?))

(def-gsi-api-function (gsi-set-item-of-attr (:return-type :null))
		      ((attribute :object)
		       (item	  :object))
  (unless (and (gsi-attribute-p attribute)
	       (gsi-instance-p item))
    (gsi-api-error gsi-incompatible-structure))
  (setf (gsi-attribute-instance attribute) item))

(def-gsi-api-function (gsi-item-of-registered-item (:return-type :object))
		      ((registered-item	 :object))
  (unless (gsi-transfer-wrapper-p registered-item)
    (gsi-api-error gsi-incompatible-structure))
  (let ((item? (gsi-transfer-instance registered-item)))
    (unless item?
      (gsi-api-error gsi-missing-instance-structure))
    item?))

(defun-simple get-instance-for-read-1 (gsi-structure nil-is-ok-p)
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (or (gsi-transfer-instance gsi-structure)
	     gsi-missing-instance-structure))
	((gsi-instance-p gsi-structure)
	 gsi-structure)
	((gsi-sensor-p gsi-structure)
	 (cond ((eq nil-is-ok-p 't)
		nil)
	       (nil-is-ok-p)
	       (t gsi-structure-has-no-instance)))
	((gsi-attribute-p gsi-structure)
	 (or (gsi-attribute-instance gsi-structure)
	     gsi-missing-instance-structure))
	(t
	 gsi-structure-has-no-instance)))

(defmacro get-instance-for-read (gsi-structure nil-is-ok-p)
  `(let ((instance (get-instance-for-read-1 ,gsi-structure ,nil-is-ok-p)))
     (when (fixnump instance)
	 (gsi-api-error instance))
     instance))

(defun-simple get-instance-for-write-1 (gsi-structure)
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (or (gsi-transfer-instance gsi-structure)
	     gsi-missing-instance-structure))
	((gsi-instance-p gsi-structure)
	 gsi-structure)
	((gsi-sensor-p gsi-structure)
	 gsi-item-definitions-are-read-only)
	((gsi-attribute-p gsi-structure)
	 (or (gsi-attribute-instance gsi-structure)
	     gsi-missing-instance-structure))
	(t
	 gsi-structure-has-no-instance)))

(defmacro get-instance-for-write (gsi-structure)
  `(let ((instance (get-instance-for-write-1 ,gsi-structure)))
     (when (fixnump instance)
       (gsi-api-error instance))
     instance))

(defun-void gsi-simple-content-copy-internal (destination-item source-item) ;use with-leftover-gsi-instance-value-reclamation !!!
  (case (gsi-instance-value-type destination-item)
    ((#.gsi-string-type-tag #.gsi-unsigned-short-vector-type-tag)
     (reclaim-text-or-gensym-string (gsi-instance-value destination-item)))
    (#.gsi-64bit-float-type-tag
     (reclaim-managed-float (gsi-instance-value destination-item))))
  (let ((value-type (gsi-instance-value-type source-item)))
    (setf (gsi-instance-value-type destination-item) value-type)
    (unless (gsi-instance-value source-item) (setq value-type #.gsi-null-type-tag))
    (case value-type
      ((#.gsi-integer-type-tag #.gsi-logical-type-tag #.gsi-symbol-type-tag)
       (setf (gsi-instance-value destination-item) (gsi-instance-value source-item)))
      ((#.gsi-string-type-tag #.gsi-unsigned-short-vector-type-tag)
       (let ((value (gsi-instance-value source-item)))
	 (setf (gsi-instance-value destination-item)
	       (if (wide-string-p value)
		   (copy-text-string value)
		   (copy-gensym-string value)))))
      (#.gsi-64bit-float-type-tag
       (setf (gsi-instance-value destination-item)
	     (copy-managed-float (gsi-instance-value source-item)))))))

(def-gsi-api-function (gsi-simple-content-copy (:return-type :null))
		      ((destination    :object)
		       (source         :object))
  (let ((destination-item?
	  (get-instance-for-write destination))
	(source-item?
	  (get-instance-for-read source nil)))
    (unless (simple-or-null-value-type-p (gsi-instance-value-type source-item?))
      (gsi-api-error gsi-incompatible-type))
    (gsi-simple-content-copy-internal destination-item? source-item?)))

(def-gsi-api-function (gsi-clear-item (:return-type :null))
		      ((gsi-structure :object))
  (let* ((instance? (get-instance-for-write gsi-structure)))
    (when instance?
      (reclaim-gsi-instance-value (gsi-instance-value-type instance?)
				  (gsi-instance-value instance?)
				  instance?
				  (gsi-instance-owner instance?))
      (setf (gsi-instance-value-type instance?) gsi-null-type-tag)
      (setf (gsi-instance-value instance?) nil)
      (reclaim-gsi-instance-extension instance? (gsi-instance-owner instance?)))))

(defconstant gsi-owner-is-USER    0)
(defconstant gsi-owner-is-GSI     1)
(defconstant gsi-owner-is-CONTEXT 2)

(def-gsi-api-function (gsi-owner-of
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
		      ((gsi-structure :object))
  (case (cond ((gsi-transfer-wrapper-p gsi-structure)
	       (gsi-transfer-owner gsi-structure))
	      ((gsi-instance-p gsi-structure)
	       (gsi-instance-owner gsi-structure))
	      ((gsi-attribute-p gsi-structure)
	       (gsi-attribute-owner gsi-structure))
	      (t
	       (gsi-api-error gsi-incompatible-structure)))
    (gsi     gsi-owner-is-GSI)
    (user    gsi-owner-is-USER)
    (context gsi-owner-is-CONTEXT)
    (t       gsi-owner-is-GSI)))

(def-gsi-api-function (gsi-class-name-of
			(:return-type gsi-api-symbol)
			(:needs-catch-p nil))
		      ((gsi-structure :object))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (gsi-api-error gsi-no-class-in-registered-item))
	((gsi-instance-p gsi-structure)
	 (gsi-instance-class gsi-structure))
	((gsi-sensor-p gsi-structure)
	 (gsi-sensor-class gsi-structure))
	((gsi-attribute-p gsi-structure)
	 (let ((instance? (gsi-attribute-instance gsi-structure)))
	   (if instance?
	       (gsi-instance-class instance?)
	       (gsi-api-error gsi-structure-has-no-instance))))
	(t
	  (gsi-api-error gsi-incompatible-structure))))

;; For safety's sake gsi-class-name-of should hand a managed copy of
;; the symbol name to the user code in case said code side effects the
;; LISP symbol. paf! 2may94

(def-gsi-api-function (gsi-set-class-name (:return-type :null))
			((gsi-structure :object)
			 (class-name?	gsi-api-symbol))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (gsi-api-error gsi-incompatible-structure))
	((gsi-instance-p gsi-structure)
	 (setf (gsi-instance-class gsi-structure) class-name?))
	((gsi-sensor-p gsi-structure)
	 (gsi-api-error gsi-item-definitions-are-read-only))
	((gsi-attribute-p gsi-structure)
	 (let ((instance? (gsi-attribute-instance gsi-structure)))
	   (if instance?
	       (setf (gsi-instance-class instance?) class-name?)
	       (gsi-api-error gsi-structure-has-no-instance))))
	(t
	 (gsi-api-error gsi-incompatible-structure))))

(def-gsi-api-function (gsi-name-of
			(:return-type gsi-api-symbol)
			(:needs-catch-p nil))
			((gsi-structure :object))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (gsi-api-error gsi-no-name-in-registered-item))
	((gsi-instance-p gsi-structure)
	 (gsi-instance-name gsi-structure))
	((gsi-sensor-p gsi-structure)
	 (gsi-sensor-name gsi-structure))
	((gsi-attribute-p gsi-structure)
	 (let ((instance? (gsi-attribute-instance gsi-structure)))
	   (if instance?
	       (gsi-instance-name instance?)
	       (gsi-api-error gsi-structure-has-no-instance))))
	(t
	  (gsi-api-error gsi-incompatible-structure))))

;; For safety's sake gsi-name-of should hand a managed copy of
;; the symbol name to the user code in case said code side effects the
;; LISP symbol. paf! 2may94

(def-gsi-api-function (gsi-set-name (:return-type :null))
		      ((gsi-structure :object)
		       (name?	      gsi-api-symbol))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (gsi-api-error gsi-incompatible-structure))
	((gsi-instance-p gsi-structure)
	 (setf (gsi-instance-name gsi-structure) name?))
	((gsi-sensor-p gsi-structure)
	 (gsi-api-error gsi-item-definitions-are-read-only))
	((gsi-attribute-p gsi-structure)
	 (let ((instance? (gsi-attribute-instance gsi-structure)))
	   (if instance?
	       (setf (gsi-instance-name instance?) name?)
	       (gsi-api-error gsi-structure-has-no-instance))))
	(t
	 (gsi-api-error gsi-incompatible-structure))))

(def-gsi-api-function (gsi-type-of
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
                      ((gsi-structure :object))
  (let ((instance (get-instance-for-read gsi-structure nil)))
    (if (and (gsi-sensor-p instance)
	     (not gsi-use-references-p))
	(gsi-sensor-value-type gsi-structure)
	(gsi-instance-value-type instance))))

;???
(def-gsi-api-function (gsi-item-has-a-value (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (let ((instance? (get-instance-for-read gsi-structure t)))
    (if (and instance? (gsi-instance-value instance?))
	1
	0)))

(def-gsi-api-function (gsi-set-type (:return-type :null))
                      ((gsi-structure :object)
		       (type          gsi-fixnum-long))
  (let* ((instance? (get-instance-for-write gsi-structure)))
    (when (and instance?
	       (not (=f type (gsi-instance-value-type instance?))))
      (let* ((arrayp (or (=f type gsi-sequence-type-tag)
			 (element-type-for-gsi-type type)))
	     (value (cond ((=f type gsi-null-type-tag)
			  nil)
			 ((=f type gsi-integer-type-tag)
			  0)
			 ((=f type gsi-string-type-tag)
			  (if (using-wide-gsi-api-p)
			      (obtain-simple-text-string 0)
			      (obtain-simple-gensym-string 0)))
			 ((=f type gsi-unsigned-short-vector-type-tag)
			  (obtain-simple-text-string 0))
			 ((=f type gsi-logical-type-tag)
			  0)
			 ((=f type gsi-64bit-float-type-tag)
			  (allocate-managed-float 0.0))
			 ((=f type gsi-structure-type-tag)
			  nil)
			 (arrayp
			  nil)
			 (t
			  (let ((fn (cond
				      ((=f type gsi-symbol-type-tag) "gsi_set_sym")
				      ((=f type gsi-item-type-tag) "gsi_set_type with GSI_NULL_TAG")
				      ((=f type gsi-item-handle-type-tag) "gsi_set_handle"))))
			    (when fn
			      (gsi-message "error in gsi_set_type: use ~A instead" fn)))
			  (gsi-api-error gsi-invalid-type type)))))
	(with-leftover-gsi-instance-value-reclamation (instance?)
	  (setf (gsi-instance-value-type instance?) type)
	  (setf (gsi-instance-value instance?) value)
	  (when arrayp
	    (setf (gsi-element-count instance?) 0)))))))

(def-gsi-api-function (gsi-handle-of
			(:return-type gsi-fixnum-long)
			(:needs-catch-p nil))
                      ((gsi-structure :object))
  (let* ((type? nil)
	 (handle?
	   (cond ((gsi-transfer-wrapper-p gsi-structure)
		  (let ((sensor-or-index (gsi-transfer-sensor-or-index gsi-structure)))
		    (cond ((fixnump sensor-or-index)
			   sensor-or-index)
			  ((and sensor-or-index
				(eq sensor-or-index gsi-sensor-to-deregister?))
			   index-of-gsi-sensor-to-deregister?)
			  ((gsi-sensor-p sensor-or-index)
			   (or (gsi-sensor-index sensor-or-index) 0)))))
		 (t
		  (let ((instance? (get-instance-for-read gsi-structure
							  gsi-structure-has-no-handle)))
		    (setq type? (gsi-instance-value-type instance?))
		    (if (eq type? gsi-item-handle-type-tag)
			(gsi-instance-value instance?)
			(if (eql instance? gsi-sensor-to-deregister?)
			    index-of-gsi-sensor-to-deregister?
			    (or (gsi-sensor-index instance?) 0))))))))
    (unless handle?
      (gsi-api-error gsi-incompatible-type type?))
    handle?))

(def-gsi-api-function (gsi-set-handle (:return-type :null))
		      ((gsi-structure  :object)
		       (handle-value   gsi-fixnum-long))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (setf (gsi-transfer-sensor-or-index gsi-structure) handle-value))
	((gsi-sensor-p gsi-structure)
	 (gsi-api-error gsi-item-definitions-are-read-only))
	(t
	 (let* ((instance? (get-instance-for-write gsi-structure)))
	   (with-leftover-gsi-instance-value-reclamation (instance?)
	     (setf (gsi-instance-value-type instance?) gsi-item-handle-type-tag)
	     (setf (gsi-instance-value instance?) handle-value))))))

(def-gsi-api-function (gsi-registration-of-item (:return-type :object))
		      ((gsi-structure  :object))
  (cond ((gsi-transfer-wrapper-p gsi-structure)
	 (let ((sensor-or-index (gsi-transfer-sensor-or-index gsi-structure)))
	   (unless (fixnump sensor-or-index)
	     sensor-or-index)))
	((gsi-sensor-p gsi-structure)
	 gsi-structure)))

(def-gsi-api-function (gsi-item-append-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-item-append-flag-value instance) 1 0)))

(def-gsi-api-function (gsi-set-item-append-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-item-append-flag-value instance) (not (=f value 0)))))

(def-gsi-api-function (gsi-item-delete-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-item-delete-flag-value instance) 1 0)))

(def-gsi-api-function (gsi-set-item-delete-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-item-delete-flag-value instance) (not (=f value 0)))))

; gsi-update-items-in-lists-and-arrays-flag
(def-gsi-api-function (gsi-update-items-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-update-items-in-lists-and-arrays-flag-value instance) 1 0)))

; gsi-set-update-items-in-lists-and-arrays-flag
(def-gsi-api-function (gsi-set-update-items-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-update-items-in-lists-and-arrays-flag-value instance) (not (=f value 0)))))

(def-gsi-api-function (gsi-item-reference-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-item-reference-flag-value instance) 1 0)))

(def-gsi-api-function (gsi-set-item-reference-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-item-reference-flag-value instance) (not (=f value 0)))))

(def-gsi-api-function (gsi-item-name-is-ident-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-item-name-is-identifying-flag-value instance) 1 0)))

(def-gsi-api-function (gsi-set-item-name-is-ident-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-item-name-is-identifying-flag-value instance) (not (=f value 0)))))

(def-gsi-api-function (gsi-item-class-is-ident-flag
			(:return-type :fixnum-int)
			(:needs-catch-p nil))
                      ((item :object))
  (let ((instance (get-instance-for-read item nil)))
    (if (gsi-item-class-is-identifying-flag-value instance) 1 0)))

(def-gsi-api-function (gsi-set-item-class-is-iden-flag
			(:return-type :null)
			(:needs-catch-p nil))
                      ((item :object)
		       (value :fixnum-int))
  (let ((instance (get-instance-for-read item nil)))
    (setf (gsi-item-class-is-identifying-flag-value instance) (not (=f value 0)))))

(defmacro def-gsi-api-primitive-reader-function (name type &optional type-tag)
  (let ((typed-array-p (and (consp type) (eq (car type) 'gsi-typed-array))))
    (when typed-array-p
      (setq type-tag (type-tag-from-gsi-type type))
      (setq type (append type '((gsi-element-count instance?) instance?))))
    `(def-gsi-api-function (,name (:return-type ,type))
	 ((gsi-structure :object) &aux (instance? (get-instance-for-read gsi-structure nil)))
       (let ((value-type (gsi-instance-value-type instance?)))
	 (unless (eq value-type ,type-tag)
	   (gsi-api-error gsi-incompatible-type value-type)))
       (let ((value? (gsi-instance-value instance?)))
	 ,@(unless typed-array-p
	     `((unless value?
		 (gsi-api-error gsi-item-has-no-value))))
	 ,(case type-tag
	    (gsi-64bit-float-type-tag
	     `(managed-float-value value?))
	    (t
	     `value?))))))

(defmacro def-gsi-api-primitive-writer-function (name type &optional type-tag)
  (let ((typed-array-p (and (consp type) (eq (car type) 'gsi-typed-array)))
	(usv-p (eq type-tag 'gsi-unsigned-short-vector-type-tag)))
    (when typed-array-p
      (setq type-tag (type-tag-from-gsi-type type))
      (setq type (append type '(element-count instance?))))
    (when usv-p
      (setq type (append (list type) '(length))))
    `(def-gsi-api-function (,name (:return-type :null))
			   ((gsi-structure :object)
			    (new-value ,type)
			    ,@(when typed-array-p
				`((element-count gsi-fixnum-long)))
			    ,@(when usv-p
				`((length gsi-fixnum-long)))
			    &aux (instance? (get-instance-for-write gsi-structure)))
       ,@(when (eq type-tag 'gsi-logical-type-tag)
	   `((when (or (<f new-value -1000)
		       (>f new-value  1000))
	       (gsi-api-error gsi-g2-logical-out-of-bounds new-value))))
       (with-leftover-gsi-instance-value-reclamation (instance?)
	 (setf (gsi-instance-value-type instance?) ,type-tag)
	 ;;  XXX I think gsi-set-flt ought to check if there's already a float there,
	 ;;  and mutate-managed-float-value it if so rather than calling
	 ;;  with-leftover-gsi-instance-value-reclamation and allocate-managed-float
	 ;;  unconditionally, -ncc, 7/11/94
	 (setf (gsi-instance-value instance?)
	       ,(case type-tag
		  (gsi-64bit-float-type-tag
		   `(allocate-managed-float new-value))
		  (gsi-long-type-tag
		   `(allocate-managed-long new-value))
		  (t
		   `new-value)))
	 ,@(when typed-array-p
	     `((setf (gsi-element-count instance?) element-count)))))))

(def-gsi-api-primitive-reader-function gsi-int-of  gsi-fixnum-long gsi-integer-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-int gsi-fixnum-long gsi-integer-type-tag)

(def-gsi-api-primitive-reader-function gsi-i64-of  gsi-long gsi-long-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-i64 gsi-long gsi-long-type-tag)

(def-gsi-api-primitive-reader-function gsi-flt-of  gsi-float gsi-64bit-float-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-flt gsi-float gsi-64bit-float-type-tag)

(def-gsi-api-primitive-reader-function gsi-log-of  gsi-fixnum-long gsi-logical-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-log gsi-fixnum-long gsi-logical-type-tag)

(def-gsi-api-primitive-reader-function gsi-str-of  permanent-gsi-string gsi-string-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-str permanent-gsi-string gsi-string-type-tag)

(def-gsi-api-primitive-reader-function gsi-usv-of
    permanent-unsigned-short-vector gsi-unsigned-short-vector-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-usv
    permanent-unsigned-short-vector gsi-unsigned-short-vector-type-tag)

;; For safety's sake gsi-sym-of should hand a managed copy of
;; the symbol name to the user code in case said code side effects the
;; LISP symbol. paf! 30dec93
(def-gsi-api-primitive-reader-function gsi-sym-of  gsi-api-symbol gsi-symbol-type-tag)
(def-gsi-api-primitive-writer-function gsi-set-sym gsi-api-symbol gsi-symbol-type-tag)

(def-gsi-api-function (gsi-element-count-of (:return-type gsi-fixnum-long))
			((gsi-structure :object))
  (let* ((instance (get-instance-for-read gsi-structure nil))
	 (type (gsi-instance-value-type instance)))
    (cond ((gsi-element-count instance))
	  ((and (or (=f type gsi-string-type-tag)
		    (=f type gsi-unsigned-short-vector-type-tag))
		(gsi-instance-value instance))
	   (lengthw (gsi-instance-value instance)))
	  ((and (=f type gsi-symbol-type-tag) (gsi-instance-value instance))
	   (lengthw
	     (if gsi-wide-api-p
		 (symbol-name-text-string (gsi-instance-value instance))
		 (symbol-name (gsi-instance-value instance)))))
	  (t
	   0))))

(def-gsi-api-function (gsi-set-element-count (:return-type :null))
			((gsi-structure :object)
			 (element-count gsi-fixnum-long))
  (setf (gsi-element-count (get-instance-for-write gsi-structure))
	element-count))

(def-gsi-api-primitive-reader-function gsi-int-array-of  (gsi-typed-array integer array))
(def-gsi-api-primitive-reader-function gsi-int-list-of   (gsi-typed-array integer list))

(def-gsi-api-primitive-writer-function gsi-set-int-array (gsi-typed-array integer array))
(def-gsi-api-primitive-writer-function gsi-set-int-list  (gsi-typed-array integer list))

(def-gsi-api-primitive-reader-function gsi-flt-array-of  (gsi-typed-array 64bit-float array))
(def-gsi-api-primitive-reader-function gsi-flt-list-of   (gsi-typed-array 64bit-float list))

(def-gsi-api-primitive-writer-function gsi-set-flt-array (gsi-typed-array 64bit-float array))
(def-gsi-api-primitive-writer-function gsi-set-flt-list  (gsi-typed-array 64bit-float list))

(def-gsi-api-primitive-reader-function gsi-log-array-of  (gsi-typed-array logical array))
(def-gsi-api-primitive-reader-function gsi-log-list-of   (gsi-typed-array logical list))

(def-gsi-api-primitive-writer-function gsi-set-log-array (gsi-typed-array logical array))
(def-gsi-api-primitive-writer-function gsi-set-log-list  (gsi-typed-array logical list))

(def-gsi-api-primitive-reader-function gsi-sym-array-of  (gsi-typed-array symbol array))
(def-gsi-api-primitive-reader-function gsi-sym-list-of   (gsi-typed-array symbol list))

(def-gsi-api-primitive-writer-function gsi-set-sym-array (gsi-typed-array symbol array))
(def-gsi-api-primitive-writer-function gsi-set-sym-list  (gsi-typed-array symbol list))

(def-gsi-api-primitive-reader-function gsi-str-array-of  (gsi-typed-array string array))
(def-gsi-api-primitive-reader-function gsi-str-list-of   (gsi-typed-array string list))

(def-gsi-api-primitive-writer-function gsi-set-str-array (gsi-typed-array string array))
(def-gsi-api-primitive-writer-function gsi-set-str-list  (gsi-typed-array string list))


;; Note that `gsi-elements-of' had to be modified such that it translates
;; into code that does NOT use the x ? y : z form.  This because gsi-extract-c-array
;; returns (Object *) which conflicts with the (Object) type returned by gsi-error.
;; This was a problem only on an old cc compiler (gcc did not mind the type
;; inconsistency). -paf!8jul94


(def-gsi-api-function (gsi-elements-of (:return-type (gsi-managed-array (gsi-element-count instance?))))
		      ((gsi-structure :object)
		       &aux (instance? (get-instance-for-read gsi-structure nil)))
  (let ((instance-type (gsi-instance-value-type instance?)))
    (unless (or (eq instance-type gsi-value-array-type-tag)
		(eq instance-type gsi-value-list-type-tag)
		(eq instance-type gsi-item-array-type-tag)
		(eq instance-type gsi-item-list-type-tag)
		(eq instance-type gsi-quantity-array-type-tag)
		(eq instance-type gsi-quantity-list-type-tag)
		(eq instance-type gsi-item-or-value-array-type-tag)
		(eq instance-type gsi-item-or-value-list-type-tag)
		(eq instance-type gsi-sequence-type-tag))
      (gsi-api-error gsi-incompatible-type (gsi-instance-value-type instance?)))
    (gsi-instance-value instance?)))

(def-gsi-api-function (gsi-set-elements (:return-type :null))
		      ((gsi-structure	:object)
		       (element-array	(gsi-managed-array element-count))
		       (element-count	gsi-fixnum-long)
		       (type-tag	gsi-fixnum-long))
  (let ((instance? (get-instance-for-write gsi-structure)))
    (unless (or (=f type-tag gsi-value-array-type-tag)
		(=f type-tag gsi-item-array-type-tag)
		(=f type-tag gsi-value-list-type-tag)
		(=f type-tag gsi-item-list-type-tag)
		(=f type-tag gsi-quantity-array-type-tag)
		(=f type-tag gsi-quantity-list-type-tag)
		(=f type-tag gsi-item-or-value-array-type-tag)
		(=f type-tag gsi-item-or-value-list-type-tag)
		(=f type-tag gsi-sequence-type-tag))
      (gsi-api-error gsi-incompatible-type type-tag))
    (setf (gsi-instance-value instance?) element-array)
    (setf (gsi-element-count instance?) element-count)
    (setf (gsi-instance-value-type instance?) type-tag)))

(def-gsi-api-function (gsi-attr-count-of (:return-type gsi-fixnum-long))
		      ((gsi-structure :object))
  (gsi-attribute-count (get-instance-for-read gsi-structure nil)))

(def-gsi-api-function (gsi-set-attr-count (:return-type :null))
		      ((gsi-structure	 :object)
		       (attribute-count gsi-fixnum-long))
  (let ((instance (get-instance-for-write gsi-structure)))
    (when (>f attribute-count 0)
      (let* ((attributes (gsi-attributes instance))
	     (array-count (length attributes)))
	(when (>f attribute-count (-f array-count gsi-magic-offset))
	  (gsi-api-error gsi-count-out-of-array-bounds attribute-count
			 (-f array-count gsi-magic-offset)))))
  (setf (gsi-attribute-count instance) attribute-count)))

(def-gsi-api-function (gsi-attrs-of (:return-type :object))
		      ((gsi-structure :object))
  (let* ((instance? (get-instance-for-read gsi-structure nil)))
    (if (<f (gsi-attribute-count instance?) 1)
	nil
	(let* ((attributes (gsi-attributes instance?))
	       (magic-number? (gsi-managed-svref attributes 0)))
	  (unless (and (fixnump magic-number?)
		       (=f magic-number? gsi-magic-number))
	    (gsi-api-error gsi-bad-magic-number-in-query))
	  (gsi-extract-c-array attributes)))))

(def-gsi-api-function (gsi-set-attrs (:return-type :null))
		      ((gsi-structure	 :object)
		       (attribute-array	 (gsi-managed-array attribute-count))
		       (attribute-count	 gsi-fixnum-long))
  (let* ((instance (get-instance-for-write gsi-structure)))
    (setf (gsi-attributes instance) attribute-array)
    (setf (gsi-attribute-count instance) attribute-count)))

(defun lookup-attr-by-name-1 (enclosing-instance? search-name)
  (loop with attributes = (gsi-attributes enclosing-instance?)
	for i from gsi-magic-offset
	      below (+f (gsi-attribute-count enclosing-instance?)
			gsi-magic-offset)
	for attribute = (gsi-managed-svref attributes i)
	for attribute-name = (gsi-attribute-qualified-name attribute)
	do (when (eq search-name attribute-name)
	     (return-from lookup-attr-by-name-1
	       (values attribute attributes i)))))

(defun-simple gsi-get-item-of-attribute-named (instance symbol)
  (loop with attributes = (gsi-attributes instance)
	for i from gsi-magic-offset
	      below (+f (gsi-attribute-count instance)
			gsi-magic-offset)
	for attribute = (gsi-managed-svref attributes i)
	for attribute-spec = (gsi-attribute-spec attribute)
	when (and (eq 'attribute (resumable-attribute-type attribute-spec))
		  (null (resumable-attribute-class-qualifier? attribute-spec))
		  (eq symbol (resumable-attribute-base-name attribute-spec)))
	  do (return (gsi-attribute-instance attribute))))

(defmacro with-attr-by-name ((vars gsi-structure search-name) &body forms)
  `(multiple-value-bind ,vars
       (lookup-attr-by-name-1 (get-instance-for-read ,gsi-structure nil) ,search-name)
     (unless ,(car vars)
       (gsi-api-warning gsi-attribute-name-not-found ,search-name))
     ,@forms))

(def-gsi-api-function (gsi-attr-by-name (:return-type :object))
		      ((gsi-structure :object)
		       (search-name   gsi-api-symbol))
  (with-attr-by-name ((attribute) gsi-structure search-name)
    attribute))

(def-gsi-api-function (gsi-set-attr-by-name (:return-type :null))
		      ((gsi-structure :object)
		       (search-name   gsi-api-symbol)
		       (gsi-attr      :object))
  (with-attr-by-name ((existing-attr attributes i) gsi-structure search-name)
    (when existing-attr
      ;; maybe reclaim existing attr
      (setf (gsi-managed-svref attributes i) gsi-attr)))
  nil)

(def-gsi-api-function (gsi-item-of-attr-by-name (:return-type :object))
		      ((gsi-structure :object)
		       (search-name   gsi-api-symbol))
  (with-attr-by-name ((attr) gsi-structure search-name)
    (when attr
      (let ((item? (gsi-attribute-instance attr)))
	(unless item?
	  (gsi-api-error gsi-missing-instance-structure))
	item?))))

(def-gsi-api-function (gsi-set-item-of-attr-by-name (:return-type :null))
		      ((gsi-structure :object)
		       (search-name   gsi-api-symbol)
		       (gsi-instance  :object))
  (with-attr-by-name ((attr) gsi-structure search-name)
    (when attr
      ;; maybe reclaim existing value of (gsi-attribute-instance attribute)
      (setf (gsi-attribute-instance attr) gsi-instance)))
  nil)

(def-gsi-api-function (gsi-status-of (:return-type gsi-fixnum-long))
		      ((gsi-item :object))
  (unless (gsi-transfer-wrapper-p gsi-item)
    (gsi-api-error gsi-structure-has-no-status))
  (gsi-transfer-status gsi-item))

(def-gsi-api-function (gsi-set-status (:return-type :null))
		      ((gsi-item    :object)
		       (new-status  gsi-fixnum-long))
  (unless (gsi-transfer-wrapper-p gsi-item)
    (gsi-api-error gsi-structure-has-no-status))
  (setf (gsi-transfer-status gsi-item) new-status))

(def-gsi-api-function (gsi-interval-of (:return-type gsi-float))
		      ((gsi-intervaled-structure :object))
  (managed-float-value
    (cond ((gsi-transfer-wrapper-p gsi-intervaled-structure)
	   (gsi-transfer-update-interval gsi-intervaled-structure))
	  ((gsi-sensor-p gsi-intervaled-structure)
	   (gsi-sensor-collection-interval gsi-intervaled-structure))
	  (t
	   (gsi-api-error gsi-structure-has-no-interval)))))

(def-gsi-api-function (gsi-set-interval (:return-type :null))
		      ((gsi-intervaled-structure :object)
		       (new-interval		 gsi-float))
  (cond ((gsi-transfer-wrapper-p gsi-intervaled-structure)
	 (setf (gsi-transfer-update-interval gsi-intervaled-structure)
	       (allocate-managed-float new-interval))
	 (gsi-message 'gsi-set-interval gsi-unexpected-operation))
	((gsi-sensor-p gsi-intervaled-structure)
	 (gsi-api-error gsi-item-definitions-are-read-only))
	(t
	 (gsi-api-error gsi-structure-has-no-interval))))

(defmacro gsi-get-attribute-spec (gsi-structure attribute-type)
  `(let ((code (unless (gsi-attribute-p ,gsi-structure)
		 gsi-structure-has-no-attribute-name))
	 (attribute-spec? nil))
     (unless code
       (setq attribute-spec? (gsi-attribute-spec ,gsi-structure))
       (unless attribute-spec?
	 (setq code gsi-structure-has-no-attribute-name))
       (unless (or (null ,attribute-type)
		   (eq (resumable-attribute-type attribute-spec?) ,attribute-type))
	 (setq code gsi-invalid-attribute-type)))
     (when code
       (gsi-api-error code))
     attribute-spec?))

(def-gsi-api-function (gsi-attr-name-of (:return-type gsi-api-symbol))
                      ((gsi-structure :object))
  (gsi-get-attribute-spec gsi-structure 'attribute)
  (gsi-attribute-qualified-name gsi-structure))

(defun-void set-gsi-attribute-name (attribute attribute-name)
  (let* ((attribute-name-text-string (symbol-name-text-string attribute-name))
	 (length (lengthw attribute-name-text-string))
	 (double-colon-p (position-of-two-colons attribute-name-text-string))
	 (attribute-spec (gsi-attribute-spec attribute)))
    (setf (resumable-attribute-class-qualifier? attribute-spec)
	  (when double-colon-p
	    (gsi-intern
	      (copy-partial-text-string attribute-name-text-string double-colon-p))))
    (setf (gsi-attribute-qualified-name-1 attribute) attribute-name)
    (setf (resumable-attribute-base-name attribute-spec)
	  (if double-colon-p
	      (gsi-intern
		(text-string-substring attribute-name-text-string (+f double-colon-p 2) length))
	      attribute-name))))

(def-gsi-api-function (gsi-set-attr-name (:return-type :null))
		      ((gsi-structure  :object)
		       (attribute-name gsi-api-symbol))
  (gsi-get-attribute-spec gsi-structure 'attribute) ; does error checking
  (set-gsi-attribute-name gsi-structure attribute-name))

(def-gsi-api-function (gsi-unqualified-attr-name-of
			(:return-type gsi-api-symbol))
		      ((gsi-structure :object))
  (resumable-attribute-base-name
    (gsi-get-attribute-spec gsi-structure 'attribute)))

(def-gsi-api-function (gsi-set-unqualified-attr-name (:return-type :null))
		      ((gsi-structure  :object)
		       (attribute-name gsi-api-symbol))
  (setf (resumable-attribute-base-name
	  (gsi-get-attribute-spec gsi-structure 'attribute))
	attribute-name))

(def-gsi-api-function (gsi-attr-name-is-qualified (:return-type gsi-fixnum-long))
		      ((gsi-structure :object))
  (if (resumable-attribute-class-qualifier?
	(gsi-get-attribute-spec gsi-structure 'attribute))
      1
      0))

(def-gsi-api-function (gsi-class-qualifier-of (:return-type gsi-api-symbol))
		      ((gsi-structure :object) )
  (let ((class-qualifier? (resumable-attribute-class-qualifier?
			    (gsi-get-attribute-spec gsi-structure 'attribute))))
    (unless class-qualifier?
      (gsi-api-error gsi-structure-has-no-class-qualifier))
    class-qualifier?))

(def-gsi-api-function (gsi-set-class-qualifier (:return-type :null))
		      ((gsi-structure  :object)
		       (attribute-name gsi-api-symbol))
  (setf (resumable-attribute-class-qualifier?
	  (gsi-get-attribute-spec gsi-structure 'attribute))
	attribute-name))

(def-gsi-api-function (gsi-attr-is-array-index (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (if (eq 'vector-element
	  (resumable-attribute-type (gsi-get-attribute-spec gsi-structure nil)))
      1
      0))

(def-gsi-api-function (gsi-attr-array-index-of (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (let ((index (resumable-vector-or-list-index
		 (gsi-get-attribute-spec gsi-structure 'vector-element))))
    (unless index
      (gsi-api-error gsi-structure-has-no-class-qualifier)) ; fix this error code
    index))

(def-gsi-api-function (gsi-set-attr-array-index (:return-type :null))
                      ((gsi-structure  :object)
		       (attribute-index gsi-fixnum-long))
  (let ((attr-spec (gsi-get-attribute-spec gsi-structure nil)))
    (unless (eq 'vector-element (resumable-attribute-type attr-spec))
      (reclaim-resumable-attribute-spec-if-any attr-spec)
      (setq attr-spec (make-resumable-vector-index))
      (setf (gsi-attribute-spec gsi-structure) attr-spec))
    (setf (resumable-vector-or-list-index attr-spec) attribute-index)))

(def-gsi-api-function (gsi-attr-is-list-index (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (if (eq 'list-element
	  (resumable-attribute-type
	    (gsi-get-attribute-spec gsi-structure nil)))
      1
      0))

(def-gsi-api-function (gsi-attr-list-index-of (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (let ((index (resumable-vector-or-list-index
		 (gsi-get-attribute-spec gsi-structure 'list-element))))
    (unless index
      (gsi-api-error gsi-structure-has-no-class-qualifier)) ; fix this error code
    index))

(def-gsi-api-function (gsi-set-attr-list-index (:return-type :null))
                      ((gsi-structure  :object)
		       (attribute-index gsi-fixnum-long))
  (let ((attr-spec (gsi-get-attribute-spec gsi-structure nil)))
    (unless (eq 'list-element (resumable-attribute-type attr-spec))
      (reclaim-resumable-attribute-spec-if-any attr-spec)
      (setq attr-spec (make-resumable-list-index))
      (setf (gsi-attribute-spec gsi-structure) attr-spec))
    (setf (resumable-vector-or-list-index attr-spec) attribute-index)))

(def-gsi-api-function (gsi-attr-is-transient (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (unless (gsi-attribute-p gsi-structure)
    (gsi-api-error gsi-incompatible-type))
  (if (gsi-attribute-is-transient-p gsi-structure) 1 0))

(def-gsi-api-function (gsi-set-attr-is-transient (:return-type :null))
                      ((gsi-structure :object)
		       (new-value gsi-fixnum-long))
  (unless (gsi-attribute-p gsi-structure)
    (gsi-api-error gsi-incompatible-type))
  (setf (gsi-attribute-is-transient-p gsi-structure) (/=f 0 new-value)))

(def-gsi-api-function (gsi-attr-is-identifying (:return-type gsi-fixnum-long))
                      ((gsi-structure :object))
  (unless (gsi-attribute-p gsi-structure)
    (gsi-api-error gsi-incompatible-type))
  (if (gsi-attribute-is-identifying-p gsi-structure) 1 0))

(def-gsi-api-function (gsi-set-attr-is-identifying (:return-type :null))
                      ((gsi-structure :object)
		       (new-value gsi-fixnum-long))
  (unless (gsi-attribute-p gsi-structure)
    (gsi-api-error gsi-incompatible-type))
  (setf (gsi-attribute-is-identifying-p gsi-structure) (/=f 0 new-value)))

(def-gsi-api-function (gsi-is-item (:return-type gsi-fixnum-long))
		      ((gsi-structure :object))
  (if (gsi-instance-class
	(get-instance-for-read gsi-structure gsi-incompatible-structure))
      1
      0))

(def-gsi-api-function (gsi-class-type-of (:return-type gsi-fixnum-long))
		      ((gsi-structure :object))
  (let ((instance (get-instance-for-read gsi-structure
					 gsi-incompatible-structure)))
    (gsi-instance-class-type instance)))

(def-gsi-api-function (gsi-set-class-type (:return-type :null))
		      ((gsi-structure :object)
		       (type          gsi-fixnum-long))
  (let* ((instance (get-instance-for-write gsi-structure))
	 (instance-type (gsi-instance-value-type instance)))
    (cond ((not (=f instance-type gsi-null-type-tag))
	   (unless (or (=f instance-type type)
		       (and (=f type gsi-quantity-type-tag)
			    (or (=f instance-type gsi-integer-type-tag)
				(=f instance-type gsi-64bit-float-type-tag))))
	     (gsi-api-error gsi-invalid-type type)))
	  ((not (or (=f type gsi-null-type-tag)
		    (=f type gsi-integer-type-tag)
		    (=f type gsi-logical-type-tag)
		    (=f type gsi-string-type-tag)
		    (=f type gsi-64bit-float-type-tag)
		    (=f type gsi-symbol-type-tag)
		    (=f type gsi-quantity-type-tag)))
	   (gsi-api-error gsi-invalid-type type)))
    (setf (gsi-instance-class-type instance) type)))

(def-gsi-api-function (gsi-history-count-of (:return-type gsi-fixnum-long))
		      ((gsi-structure :object))
  (let ((history? (gsi-instance-history (get-instance-for-read gsi-structure
							       gsi-incompatible-structure))))
    (if history?
	(gsi-history-length history?)
	0)))

;; Unpublished for now (I don't believe it is useful). -paf! 29dec94
#|
( def-gsi-api-function (gsi-set-history-count (:return-type :null))
		      ((gsi-structure :object)
		       (history-count gsi-fixnum-long))
  (setf (gsi-history-length
	  (gsi-instance-history
	    (get-instance-for-write gsi-structure)))
	history-count))
|#

(def-gsi-api-function (gsi-extract-history (:return-type :null))
		      ((gsi-structure	   :object)
		       (values_result	   (gsi-return-value :object))
		       (timestamps_result  (gsi-return-value :object))
		       (type_result	   (gsi-return-value :fixnum)))
  (let* ((instance (get-instance-for-read gsi-structure
					  gsi-incompatible-structure))
	 (history? (gsi-instance-history instance)))
    (unless history?
      (gsi-api-error gsi-structure-has-no-history))
    (let* ((history-type (gsi-instance-class-type instance))
	   (history-values (gsi-history-values history?)))
      (return-gsi-values
	(dynamic-extract-c-array
	  history-type history-values
	  (gsi-api-error gsi-invalid-history-type))
	(typed-extract-c-array 64bit-float (gsi-history-timestamps history?))
	history-type))))

(def-gsi-api-function (gsi-extract-history-spec (:return-type :null))
		      ((gsi-structure	:object)
		       (max-count_result    (gsi-return-value :fixnum))
		       (max-age_result	    (gsi-return-value :fixnum))
		       (granularity_result  (gsi-return-value :fixnum)))
  (let* ((instance (get-instance-for-read gsi-structure
					  gsi-incompatible-structure))
	 (history? (gsi-instance-history instance)))
    (unless history?
      (gsi-api-error gsi-structure-has-no-history))
    (let* ((history-spec (gsi-history-internals history?))
	   (max-count? (second history-spec))
	   (max-age? (third history-spec))
	   (granularity? (fourth history-spec)))
      (return-gsi-values
	(or max-count? 0)
	(or max-age? 0)
	(or granularity? 1000)))))

(def-gsi-api-function (gsi-set-history (:return-type :null))
		      ((gsi-structure	      :object)
		       (c-value-array	      :object)
		       (c-timestamp-array     :object)
		       (tuple-count	      gsi-fixnum-long)
		       (history-type	      gsi-fixnum-long)
		       (c-max-count	      gsi-fixnum-long)
		       (c-max-age	      gsi-fixnum-long)
		       (c-granularity	      gsi-fixnum-long))
  (when (and (>f c-max-count 0) (>f tuple-count c-max-count))
    (gsi-api-error gsi-incompatible-history-spec tuple-count c-max-count))
  (unless (and c-value-array c-timestamp-array)
    (gsi-api-error gsi-null-pointer-argument))
  (let* ((instance (get-instance-for-write gsi-structure))
	 (max-count? (if (=f c-max-count 0) nil c-max-count))
	 (max-age? (if (=f c-max-age 0) nil c-max-age))
	 (granularity? (if (=f c-granularity 1000) nil c-granularity))
	 (old-history? (gsi-instance-history gsi-structure))
	 (history-structure
	   (let ((new-values nil))
	     (gsi-set-history-type instance history-type)
	     (when (or (eq history-type gsi-value-type-tag)
		       (eq history-type gsi-quantity-type-tag))
	       (setq new-values (gsi-get-array-from-c-contents c-value-array))
	       (let ((value-count (gsi-managed-array-length new-values)))
		 (when (>f tuple-count (-f value-count gsi-magic-offset))
		   (gsi-api-error gsi-count-out-of-array-bounds tuple-count
				  (-f value-count gsi-magic-offset)))))
	     (make-gsi-history instance tuple-count new-values nil nil
			       max-count? max-age? granularity?)))
	 (history-values (gsi-history-values history-structure))
	 (history-timestamps (gsi-history-timestamps history-structure)))
    (copy-c-array-into-array 64bit-float c-timestamp-array history-timestamps tuple-count)
    (dynamic-copy-c-array-into-array
      history-type c-value-array history-values tuple-count
      (unless (or (eq history-type gsi-value-type-tag)
		  (eq history-type gsi-quantity-type-tag)) ; handled in binding of history-structure above.
	(gsi-api-error gsi-invalid-history-type)))
    (setf (gsi-instance-history gsi-structure) history-structure)
    (when old-history?
      (reclaim-gsi-history old-history?))))




;;;; GSI TIMESTAMP API


(def-gsi-api-function (gsi-set-timestamp (:return-type :null))
		      ((gsi-instance :object)
		       (timestamp    gsi-float))
  (let* ((instance (get-instance-for-write gsi-instance))
	 (instance-timestamp? (gsi-instance-timestamp instance)))
    (with-temporary-gensym-float-creation gsi-set-timestamp
      ;; with-guarded-timestamp conses a float, if the timestamp is invalid.
      (with-guarded-timestamp-api (timestamp)
	(if (and instance-timestamp?
		 (managed-float-p instance-timestamp?))
	    (mutate-managed-float-value instance-timestamp? timestamp)
	    ;; we gotta allocate a new one
	    ;; (no leak, since there's no old value here)
	    (setf (gsi-instance-timestamp instance)
		  (allocate-managed-float timestamp)))))))


;;; XXX this conses double-floats as noted below.  Not sure how to fix this.
;;;  -ncc, 7/29/94
(def-gsi-api-function (gsi-timestamp-of (:return-type gsi-float))
		      ((gsi-structure :object))
  (let* ((instance (get-instance-for-read gsi-structure nil))
	 (timestamp? (gsi-instance-timestamp instance)))
    (cond (timestamp?
	   (managed-float-value timestamp?))
	  (t
	   ;; We are forced to return a double, but in the case of a nil
	   ;; timestamp should probably also issue a warning -paf! 10apr95
	   (gsi-warning 'timestamp_of gsi-timestamp-not-found)
	   0.0))))

;; the nonsense with mangled-float-value and stamp is needed to get the float
;; out of the with-temporary-gensym-float-creation form inside of
;; gensym-float-creation, and not leak managed-float-values.
(def-gsi-api-function (gsi-encode-timestamp (:return-type gsi-float))
		      ((year   gsi-fixnum-long) ; order of args based on GSI 3.2
		       (month  gsi-fixnum-long)
		       (day    gsi-fixnum-long)
		       (hour   gsi-fixnum-long)
		       (minute gsi-fixnum-long)
		       (second gsi-fixnum-long))
  (let* ((mangled-float
	   (gensym-encode-unix-time-as-managed-float second minute hour
						     day month year))
	 (stamp (managed-float-value mangled-float)))
    (declare (type gensym-float stamp))
    (reclaim-managed-float mangled-float)
    (inline-convert-to-local-float-format
      stamp
      (if (gsi-option-is-set-p gsi-use-gfloats) 1 0))))

(def-gsi-api-function (gsi-decode-timestamp (:return-type :null))
		      ((timestamp     gsi-float)
		       (year_result   (gsi-return-value :fixnum)) ; order of args based on GSI 3.2
		       (month_result  (gsi-return-value :fixnum))
		       (day_result    (gsi-return-value :fixnum))
		       (hour_result   (gsi-return-value :fixnum))
		       (minute_result (gsi-return-value :fixnum))
		       (second_result (gsi-return-value :fixnum)))
  (with-temporary-gensym-float-creation gsi-decode-timestamp
    (multiple-value-bind (second minute hour day month year)
	(gensym-decode-unix-time
	  (inline-convert-from-local-float-format
	    timestamp
	    (if (gsi-option-is-set-p gsi-use-gfloats) 1 0)))
      (return-gsi-values year month day hour minute second))))



;;;; Development-only Testing Code and Testing Suites

#+development
(defparameter validation-suite-for-derive-network-listeners
  '(
    ; Command line				   TCP-IP
    ; ------------				   ------
    (""						   22041 )
    ("99999"					   99999 )
    ("99999 ABCDEF"				   99999 )
    ("-network tcpip"				   22041 )
    ("99999 -network tcpip"			   99999 )
    ("ABCDEF 99999"				   99999 )

    ("-network tcpip ABCDEF"			   22041 )
    ("ABCDEF 99999 -network tcpip"		   99999 )
    ("ABCDEF"					   nil	 )
    ("-network decnet"				   nil	 )
    ("99999 -network decnet"			   nil	 )
    ("A1B2C3 -network decnet"			   nil	 )
    ("ABCDEF -network decnet"			   nil	 )
    ("-network tcpip -network decnet"		   22041 )
    ("-network decnet -network tcpip"		   22041 )
    ("-network decnet 99999"			   99999 )
    ("-network tcpip ABCDEF -network decnet"	   22041 )
    ("-network decnet 99999 -network tcpip"	   99999 )
    ("99999 99999 -network decnet"		   99999 )
    ("A1B2C3 -network decnet 99999 -network tcpip" 99999 )
    ("99999 -network tcpip A1B2C3 -network decnet" 99999 )
    ))

#+development
(defun-simple test-derive-network-listeners ()
  (loop for (rest-of-command-line expected-tcp-address) in validation-suite-for-derive-network-listeners
	do
    (let* ((unix-command-line-arguments nil)
	   (unix-command-line-arguments-as-text-strings nil)
	   (command-line-to-test (concatenate 'string "gsi " rest-of-command-line)))
      (replace-command-line command-line-to-test)
      (setf gsi-extension-tcp-address? nil)
      (derive-network-listeners)
      (when (not (equalw gsi-extension-tcp-address? expected-tcp-address))
        (cerror "resume?" "~%Failure: ~s generated ~s.  I had expected ~a. ~%"
               command-line-to-test gsi-extension-tcp-address?
               expected-tcp-address)))))


;;; `gsi-major-version' - just returns the value of the constant from delta.lisp

(def-gsi-api-function (gsi-major-version
			(:return-type :fixnum-long)
			(:needs-catch-p nil))
                      ()
  major-version-number-of-current-gensym-product-line)


;;; `gsi-minor-version' - just returns the value of the constant from delta.lisp

(def-gsi-api-function (gsi-minor-version
			(:return-type :fixnum-long)
			(:needs-catch-p nil))
                      ()
  (floorf minor-version-number-of-current-gensym-product-line 10))


;;; `gsi-revision-number' - just returns the value of the constant from delta.lisp

(def-gsi-api-function (gsi-revision-number
			(:return-type :fixnum-long)
			(:needs-catch-p nil))
                      ()
  revision-number-of-current-gensym-product-line)


;;; `gsi-release-quality' - just returns the value of the constant from delta.lisp

(def-gsi-api-function (gsi-release-quality
			(:return-type :fixnum-long)
			(:needs-catch-p nil))
                      ()
  release-quality-of-current-gensym-product-line)


;;; `build-id-{letter,digit}-offset' - convert from characters to offets from the
;;; "base" character.

(defconstant max-build-id-digit 9)
(defconstant max-build-id-letter 26)

(defun build-id-letter-offset (letter)
  (minf (-f (char-code letter) #.(1-f (char-code #\A))) max-build-id-letter))

(defun build-id-digit-offset (letter)
  (minf (-f (char-code letter) #.(char-code #\0)) max-build-id-digit))



;;; `build-identification-integer' et al... encodes the build string into an integer
;;; This section could use a bit more documentation.

;;; We also are adding a scheme to export the build-identification string.
;;; Passing strings from Lisp into C for the user to do with as he pleases is
;;; somewhat problematic.  Instead, we're exporting it as a fixnum.  It only
;;; takes 15 bits.  The build id is always four characters; the first character
;;; is a letter from 'A' - 'Z' representing the year offset from 1998; the next
;;; character is a letter from 'A' - 'L' representing the month; the final two
;;; characters are an integer from "01" to "31" representing the day.  Note,
;;; however, that we don't document this, and although we hardly go out of our
;;; way to obfuscate it, we don't want to document it or promise it.  The build
;;; ID is simply a unique four-character string.  To make the math work out
;;; bitwise, and also with a very slight preference for not completely "giving
;;; away" what we're doing, we allow year, month, and day to be 0 - 31.  The day
;;; is the low five bits, the month is the "middle" five bits, and the year is
;;; the most significant five (of the 15).

(defconstant max-number-of-bits-for-day-code 5)
(defconstant max-number-of-bits-for-month-code 5)
(defconstant max-number-of-bits-for-year-code 5)

(defconstant day-bit-offset 0)
(defconstant month-bit-offset max-number-of-bits-for-day-code)
(defconstant year-bit-offset (+f month-bit-offset max-number-of-bits-for-month-code))
				 
(defun encode-build-identification-integer (build-id-string)
  (let ((year-offset
	  (build-id-letter-offset (char build-id-string 0)))
	(month-offset
	  (build-id-letter-offset (char build-id-string 1)))
	(day
	  (+f (*f 10 (build-id-digit-offset (char build-id-string 2)))
	      (build-id-digit-offset (char build-id-string 3)))))
    (+f (ashf day day-bit-offset)
	(ashf month-offset month-bit-offset)
	(ashf year-offset year-bit-offset))))


(defparameter build-identification-integer
  (encode-build-identification-integer build-identification-string))


#+development
(progn
(defun code-to-upper-case-letter (code)
  (code-char (+f code (char-code #\A) -1)))

(defconstant max-day-code (1-f (ashf 1 max-number-of-bits-for-day-code)))
(defconstant max-month-code (1-f (ashf 1 max-number-of-bits-for-month-code)))
(defconstant max-year-code (1-f (ashf 1 max-number-of-bits-for-year-code)))

(defconstant day-code-mask (ashf max-day-code day-bit-offset))
(defconstant month-code-mask (ashf max-month-code month-bit-offset))
(defconstant year-code-mask (ashf max-year-code year-bit-offset))

(defun reconstruct-build-id-string (build-id-integer)
  (let* ((year-letter
	   (code-to-upper-case-letter
	     (right-shiftf (logandf build-id-integer year-code-mask)
			   year-bit-offset)))
	 (month-letter
	   (code-to-upper-case-letter
	     (right-shiftf (logandf build-id-integer month-code-mask)
			   month-bit-offset)))
	 (day (logandf build-id-integer day-code-mask)))
    (format nil "~c~c~d" year-letter month-letter day)))
)

(def-gsi-api-function (gsi-build-id-integer
			(:return-type :fixnum-long)
			(:needs-catch-p nil))
                      ()
  build-identification-integer)



;;; `handle-extend-current-text-string-error' - called (via funcall) from
;;; UNICODE.

(defun handle-extend-current-text-string-error ()
  ;; ASK JH TO DECIDE WHAT TO DO! (MHD 11/17/95)
  (error "wide-string-extension failure (unimplemented GSI error!)"))
