;; -*- Mode: Lisp; Package: AB; Base: 10; Syntax: Common-Lisp -*-
(in-package "AB")

;;;; Module OS-ERROR

;;; Copyright (c) 1986 - 2017 Gensym Corporation.
;;; All Rights Reserved.

;;; John Hodgkinson

;; 11 December 1991



;;; This module contains the machinery with which G2 traps internal errors,
;;; i.e., errors generated by the underlying Lisp implementation or by the host
;;; operating system.



;;;; Forward References

(declare-forward-references
  (current-system-name                         variable LAUNCH)
  (maybe-wait-for-return-key                   function LAUNCH)
  )

(declare-forward-references (:suppress-module-checks-for gsi gw ctest)
  (system-is-running                           variable SCHEDULE)
  (system-has-paused                           variable SCHEDULE)
  (notify-user                                 function DEBUG)
  (notify-engineer                             function BOOKS)
  (pause-for-internal-error                    function RUN)
  (signal-floating-point-exception-stack-error function SETS)
  )

(declare-forward-references (:suppress-module-checks-for ab telewindows ctest gensym-site)
  (entering-signal-handler-function            function GSI))



;;;; Bombout Cleanup

;;; The function `def-bombout-cleanup-function' takes a symbol as its argument.
;;; This symbol should name a function which will be called to attempt clean up
;;; of the system's data structures after a bombout error has occurred (i.e. an
;;; error which is caught by our last resort error catching mechanism).  This
;;; function will uniquely add the given symbol to a list of such functions to
;;; be called.  These functions should be as simple as possible so as to avoid
;;; bombing out while executing them, since at this point there is no safety net
;;; error catcher surrounding the execution of this function.


(defvar bombout-clean-up-functions nil)

(defun def-bombout-clean-up-function (function-name)
  (if (not (memq function-name bombout-clean-up-functions))
      (with-dynamic-creation (push function-name bombout-clean-up-functions))))

;; jh, 12/12/91.  Moved the following form fron UTILITIES2 because it tries to
;; call def-bombout-cleanup-function before it is defined.  This might not be the
;; final fix, but we ahould keep the error-handling material together in one
;; module, so this is the way it has to be for now.

(def-bombout-clean-up-function 'reset-structure-being-reclaimed-after-bombout)


;;;; Signal Codes

;;; A `signal' is an event generated by the host operating system to notify the
;;; program of an anomaly.  For many signals, G2 is unable to proceed and will put
;;; up an "internal error" placard advising the user to shut down G2.  G2 will
;;; ignore other signals, however.  Furthermore, G2 is designed to proceed from
;;; some signals, and should even be able to call an arbitrary function when
;;; certain signals occur.

;;; Note that Lisp Machines generate no signals per se, though they generate some
;;; conditions which denote system problems as opposed to Lisp problems.  Lisp
;;; machine errors are included in the section Errors from the Lisp
;;; Implementation, below.

;;; The basic model mirrors that of UNIX.  Associated with each signal is a
;;; `signal code', an integer.  Catching a signal involves notifying the operating
;;; system to call a `signal function' with that code as argument whenever the
;;; signal occurs.  Signal functions are defined by def-g2-signal-handler (see
;;; below).

;;; Signal codes are defined by the top-level form def-signal-code, which stores
;;; information in the global variable signal-code-registry.  This information
;;; includes:

;;;   code-number              (the integer signal code)
;;;   name-in-operating-system (a symbol from the errno.h file)
;;;   causes-core-dump-p       (t or nil)
;;;   g2-signal-handler?       (a funcallable symbol or nil)
;;;   arithmetic-error-p       (t or nil)
;;;   description-string       (a string)


(defvar signal-code-registry nil)

(defmacro def-signal-code
          (name-in-operating-system?
           code-number?
           (causes-core-dump-p
             g2-signal-handler?
             arithmetic-error-p)
           description-string)
  ;; jh, 12/28/94.  Eliminated needless defvars in GSI, or in any distribution
  ;; image for that matter.
  (if (and (eval-feature :no-macros)
           (not arithmetic-error-p))
      ;; Note that code-number? could be a form to evaluate rather than a
      ;; constant, hence it only appears once, as the initform of the following
      ;; let-spec.
      `(let ((,name-in-operating-system? ,code-number?))
         (when ,name-in-operating-system?
           (pushnew (list ,name-in-operating-system?
                          ',name-in-operating-system?
                          ,description-string
                          ,causes-core-dump-p
                          ,(if g2-signal-handler?
                               `',g2-signal-handler?
                               nil)
                          ,arithmetic-error-p)
                    signal-code-registry
                    :test #'equal))
         ',name-in-operating-system?)
      `(progn
         ;; Note that code-number? could be a form to evaluate rather than a
         ;; constant, hence it only appears once, as the initform of the
         ;; following defvar.
         (defvar ,name-in-operating-system? ,code-number?)
         (when ,name-in-operating-system?
           (pushnew (list ,name-in-operating-system?
                          ',name-in-operating-system?
                          ,description-string
                          ,causes-core-dump-p
                          ,(if g2-signal-handler?
                               `',g2-signal-handler?
                               nil)
                          ,arithmetic-error-p)
                    signal-code-registry
                    :test #'equal))
         ',name-in-operating-system?)))

;; jh, 6/21/94.  Added def-platform-specific-signal-code to take into account
;; the fact that the actual signal codes may vary across platforms.  After
;; comparing data supplied by Mark Staknis with the def-signal-code forms for
;; which causes-core-dump-p is non-nil, I find that the signals SIGQUIT, SIGILL,
;; SIGTRAP, SIGIOT, SIGEMT, SIGFPE, SIGBUS, SIGSEGV, and SIGSYS are identical
;; across those UNIX platforms where we ship, as of this date.  Therefore at
;; this time, macro def-platform-specific-signal-code is used to provide
;; platform-dependent signal codes only for SIGCHLD and SIGLOST.

;; jh, 6/22/94.  An additional bit of information.  According to Mark Staknis:
;;   "For signals 1 to 15 they were identical to g2's values.  No signals above 15
;;   were recognized by the compilers; i.e., they were undefined symbols."
;; This means that the signals SIGQUIT, SIGILL, SIGTRAP, SIGIOT, SIGEMT, SIGFPE,
;; SIGBUS, SIGSEGV, and SIGSYS are identical between UNIX and VMS platforms.
;; Although calling signal() on VMS platforms with the "over 15" codes seems to
;; have had no ill effect in 3.0, we should consider changing these codes to
;; def-platform-specific-signal-code someday.

(defmacro def-platform-specific-signal-code
    ((name text) platform-specific-code-form)
  `(def-signal-code ,name ,platform-specific-code-form (t nil nil) ,text))

;; Add this macro to simplify the definition of non-Windows signal code,
;; Using reader macros could cause translated code different between platforms,
;; but this can be prevent, so that translated code could commit to SVN again.
;;
;; -- Chun Tian (binghe) / Glority for GENSYMCID-584, 2011/10/10

(defmacro unix-code (code)
  `(case g2-operating-system
     (unix ,code)
     (otherwise nil)))

;; jh, 5/22/91.  We only want to catch signals that cause a core dump.  Added a
;; new field to entries in signal-code-registry which is non-nil when the signal
;; can cause a core dump, nil otherwise.  Then we only establish handlers for
;; these signals.  Note that all platforms agree pretty much on which signals
;; cause a dump, except that Suns dump on 29 and no-one else does.

;; jh, 5/22/91.  Added another field to def-signal-code which allows us to specify
;; a function G2 should run upon catching the signal.  If this field is nil, G2
;; defaults to printing putting up an "internal error" placard.  If this field is
;; non-nil, it names a handler function to be run instead.  In this case, there is
;; no automatic transfer of control -- the handler function simply returns.  One
;; use of this facility is to respond to ^C by calling stack-error, instead of
;; going into the Lisp debugger.  Note that we can supply a signal handler only
;; after G2 launches.  Before launch, our only alternative is to exit.

;; jh, 5/23/91.  While we're debugging Chestnut, it is helpful to cause errors
;; with a ^C.  Changed SIGINT to make it this way in development only.
;; jh, 6/27/91.  Removed this feature because of a bug in Chestnut implementation
;; of top-level variable defining forms like defconstant and defvar.  When
;; Chestnut fixes this problem, we can restore the conditionality.

;; jh, 6/24/91.  The arithmetic-error-p field in def-signal-code is no longer
;; used.  Keep it around for a bit in case we want to make def-signal-code a
;; compile-time construct.

(def-signal-code     SIGHUP    (unix-code 1)  (nil nil nil)        "hangup")
(def-signal-code     SIGINT    2  (nil nil nil)        "interrupt")
(def-signal-code     SIGQUIT   (unix-code 3)  (t   nil nil)        "quit")
(def-signal-code     SIGILL    4  (t   nil nil)        "illegal instruction")
(def-signal-code     SIGTRAP   (unix-code 5)  (t   nil nil)        "trace trap")
(def-signal-code     SIGIOT    (unix-code 6)  (t   nil nil)        "IOT instruction or abort")
(def-signal-code     SIGEMT    (unix-code 7)  (t   nil nil)        "EMT instruction")
(def-signal-code     SIGFPE    8  (t   nil t)        "floating point exception")
(def-signal-code     SIGKILL   (unix-code 9)  (nil nil nil)        "kill") ;never caught: for information only
(def-signal-code     SIGBUS    (unix-code 10) (t   nil nil)        "bus error")
(def-signal-code     SIGSEGV   11 (t   nil nil)        "segmentation violation")
(def-signal-code     SIGSYS    (unix-code 12) (t   nil nil)        "bad argument to system call")
(def-signal-code     SIGPIPE   (unix-code 13) ;jh, 10/17/91.  Added handler for broken pipe
  (t handle-broken-pipe-signal nil)             "write on a pipe with no one to read it")

;; jh, 4/26/93.  The SIGALRM signal is special-cased elsewhere because we want
;; an efficient fixnum clock.  It has a Lisp function we want to call, but for
;; efficiency's sake we won't use the funcallable handler mechanism here.  See
;; note under "Timeout Signal Handling" in PRIMITIVES.
(def-signal-code     SIGALRM   (unix-code 14) (nil nil nil)        "alarm clock")

(def-signal-code     SIGTERM   15 (nil nil nil)        "software termination signal from kill")
(def-signal-code     SIGUSR1   (unix-code 16) (nil nil nil)        "user defined signal 1")
(def-signal-code     SIGUSR2   (unix-code 17) (nil nil nil)        "user defined signal 2")

;; POSIX names the following SIGCHLD; non-conforming implementations could use
;; SIGCLD.
;(def-signal-code     SIGCHLD   18 (t   nil nil)        "death of a child")

;; jh, 6/22/94.  Mark Staknis provided the platform-specific data for the
;; following def-platform-specific-signal-code form, in case there are future
;; questions.

(def-platform-specific-signal-code (SIGCHLD "death of a child")
    (case g2-machine-type
      ((alphaosf rs6000) 20)
      ((hp9000s700 sparcstation sparcsol intelsol) 18)
      (linux 17)
      (otherwise nil)))

(def-signal-code     SIGPWR    (unix-code 19) (nil nil nil)        "power-fail restart")
(def-signal-code     SIGVTALRM (unix-code 20) (nil nil nil)        "virtual time alarm")
(def-signal-code     SIGPROF   (unix-code 21) (nil nil nil)        "profiling time alarm")
(def-signal-code     SIGIO     (unix-code 22) (nil nil nil)        "input/output possible signal")
(def-signal-code     SIGWINDOW (unix-code 23) (nil nil nil)        "window system signal")
(def-signal-code     SIGSTOP   (unix-code 24) (nil nil nil)        "sendable stop signal not from tty")
(def-signal-code     SIGTSTP   (unix-code 25) (nil nil nil)        "stop signal from tty")
(def-signal-code     SIGCONT   (unix-code 26) (nil nil nil)        "continue a stopped process")
(def-signal-code     SIGTTIN   (unix-code 27) (nil nil nil)        "background tty read")
(def-signal-code     SIGTTOU   (unix-code 28) (nil nil nil)        "background tty write")

;(def-signal-code     SIGLOST   29 (t   nil nil)        "resource lost")


;; jh, 6/22/94.  Mark Staknis provided the platform-specific data for the
;; following def-platform-specific-signal-code form, in case there are future
;; questions.

(def-platform-specific-signal-code (SIGLOST "resource lost")
    (case g2-machine-type
      ((alphaosf rs6000)
       29)
      (otherwise nil)))

(def-signal-code     SIG30     (unix-code 30) (nil nil nil)        "signal 30 (unknown error)")
(def-signal-code     SIG31     (unix-code 31) (nil nil nil) "signal 31 (unknown error)")
(def-signal-code     SIGDIL    (unix-code 32) (nil nil nil) "DIL signal")

;;; The function get-signal-description-string returns a string which should not
;;; be reclaimed.

(defun get-signal-description-string (code-number)
  (let ((entry?
          (assoc code-number signal-code-registry)))
    (if entry?
        (third entry?)
        "unknown signal")))

(defun get-g2-signal-handler (code-number)
  (let ((entry?
          (assoc code-number signal-code-registry)))
    (if entry?
        (fifth entry?)
        nil)))



;;;; Arithmetic Signals

;;; For efficiency reasons, G2 cannot check for arithmetic errors (overflow,
;;; underflow, division by zero, and the like) at each operation.  It relies on
;;; the signal mechanism in the host operating system to perform this task.  ...

;; Inside-avoid-arithmetic-errors-p and arithmetic-error-catcher are obsolescent,
;; since we plan to remove avoid-arithmetic-errors soon.  jra & jh, 11/5/91.

(def-system-variable inside-avoid-arithmetic-errors-p OS-ERROR nil)
(defmacro arithmetic-error-catcher ()
  `(quote arithmetic-error-catcher))

;; Arithmetic-errors-are-stack-errors-p is set to true by the stack evaluator.
;; This enables us to throw to the stack error handler whenever a floating point
;; exception occurs in Chestnut.  This machinery will soon replace
;; avoid-arithmetic-errors.  jra & jh, 11/5/91.

(def-system-variable arithmetic-errors-are-stack-errors-p OS-ERROR nil)

(defmacro arithmetic-signal-p (signal-code)
  `(=f ,signal-code SIGFPE))




;;;; Post-Mortem Facility

;;; We are often left with too little information when G2 crashes.  This section
;;; contains tools to help us acquire more diagnostic information.  So far
;;; (1/17/91), a single facility exists: a ring-buffer of recently-reached
;;; checkpoints in G2 execution.

;;; Post-mortem Ring-buffer

;;; The idea is to maintain a circular buffer of symbolic checkpoints.  These
;;; constitute a backtrace of sorts, but of G2-level information rather than
;;; function-call frames.  This information could help when we must diagnose a
;;; crash.

;;; If you are left in Lisp after a crash, calling collect-post-mortem-checkpoints
;;; with no argument will allow you to see the last
;;; current-post-mortem-ring-buffer-length checkpoints, in the order in which they
;;; occurred.

;;; The size of the post-mortem ring buffer currently (1/17/91) defaults to 50,
;;; but can be set at launch time in UNIX by the command-line argument -pmsize or
;;; the environment variable G2PMSIZE, or in VMS by the logical name G2$PMSIZE.

;;; The post-mortem buffer may be dumped to a logfile.  Although this makes things
;;; slower, it could give valuable information in cases where G2 crashes directly
;;; to the operating system or beyond.  The logfile facility is also configured at
;;; launch time, in UNIX by the command-line argument -pmlog or the environment
;;; variable G2PMLOG, or in VMS by the logical name G2$PMLOG.  These entities
;;; should take a string argument naming the log file.  Since the VMS file system
;;; supports multiple versions, it is recommended that the logfile name include a
;;; version number, so that the same file is reused.



;; We do not use the facility in RING-BUFFERS, since the ring buffers it supports
;; are too complex for our needs.

;; Currently (1/17/91), checkpoints happen when the scheduler does the following:
;;    schedules waiting tasks   (in take-actions-at-start-of-clock-tick in CYCLES)
;;    services data servers     (in take-actions-at-start-of-clock-tick in CYCLES)
;;    performs tasks            (each task checkpointed in execute-block in SCHEDULE)
;;    services network packets  (in process-icp-sockets in INT2)
;;      checks for connects        "
;;      handles shutdowns          "
;;      handles input              "
;;      handles output             "
;;    services workstations     (in service-workstation in WORKSTATIONS)
;;      tries loading g2-init      "
;;      maybe enters login         "
;;      polls for events           "
;;      keeps refreshing image     "
;;      keeps parsing              "
;;      handles enqueued events    "
;;      handles search states      "
;;    updates memory info       (in run-scheduler-1 in CYCLES)
;;    prepares to loop          (in run-scheduler-1 in CYCLES)







(defun initialize-post-mortem-ring-buffer-length ()
  (or (get-command-line-keyword-argument-as-integer "pmsize")
      (read-number-for-gensym-environment-variable "G2PMSIZE")
      #.post-mortem-ring-buffer-default-length))

(def-system-variable current-post-mortem-ring-buffer-length OS-ERROR
  (:funcall initialize-post-mortem-ring-buffer-length))



(defun initialize-post-mortem-ring-buffer ()
  (let ((new-post-mortem-ring-buffer
          (loop for index from 0
                          below current-post-mortem-ring-buffer-length
                collect nil)))
    (setf (cdr (last new-post-mortem-ring-buffer))
          new-post-mortem-ring-buffer)
    new-post-mortem-ring-buffer))

(def-system-variable current-post-mortem-ring-buffer OS-ERROR
  (:funcall initialize-post-mortem-ring-buffer))



(def-system-variable log-post-mortem-ring-buffer-to-file-p OS-ERROR
  nil)

(def-system-variable post-mortem-ring-buffer-logfile-namestring OS-ERROR
  (:funcall initialize-post-mortem-ring-buffer-logfile-namestring))

(defun initialize-post-mortem-ring-buffer-logfile-namestring ()
  (let ((provided-logfile-name?
          (or (copy-if-text-string
                (get-command-line-keyword-argument
                  #w"pmlog"))
              (get-gensym-environment-variable
                #w"G2PMLOG"))))
    (cond (provided-logfile-name?
           (setq log-post-mortem-ring-buffer-to-file-p t)
           provided-logfile-name?)
          (t nil))))

(def-system-variable post-mortem-ring-buffer-logfile-stream OS-ERROR
  nil)

(def-system-variable post-mortem-ring-buffer-logfile-line-count OS-ERROR
  0)

;; paf & jh, 8/12/94.  Following code appear to be obsolete, since we now use a
;; true backtrace instead of mere checkpoints.  Flush someday, and review this
;; file for other dead code.

;(def-system-variable most-recent-post-mortem-checkpoint OS-ERROR nil)



;(defun-allowing-unwind log-post-mortem-checkpoint (checkpoint)
;  (unless post-mortem-ring-buffer-logfile-stream
;    (setq post-mortem-ring-buffer-logfile-stream
;          (g2-stream-open-for-output
;            post-mortem-ring-buffer-logfile-namestring)))
;  (when post-mortem-ring-buffer-logfile-stream
;    (protected-let ((checkpoint-line
;                      (tformat-text-string "~a" checkpoint)
;                      (reclaim-text-string checkpoint-line)))
;      (g2-stream-write-line
;        checkpoint-line
;        post-mortem-ring-buffer-logfile-stream)))
;  (when (>= (incf post-mortem-ring-buffer-logfile-line-count)
;            current-post-mortem-ring-buffer-length)
;    (setq post-mortem-ring-buffer-logfile-line-count 0)
;    (unless post-mortem-ring-buffer-logfile-stream
;      (format *standard-output* "~&Trouble writing to PM logfile~%"))
;    (when post-mortem-ring-buffer-logfile-stream
;      (g2-stream-close
;        post-mortem-ring-buffer-logfile-stream))
;    (setq post-mortem-ring-buffer-logfile-stream
;          (g2-stream-open-for-output
;            post-mortem-ring-buffer-logfile-namestring))))



;(defmacro record-post-mortem-checkpoint (checkpoint)
;  (avoiding-variable-capture (checkpoint)
;    `(progn
;       (setf (car current-post-mortem-ring-buffer) ,checkpoint)
;       (setq most-recent-post-mortem-checkpoint ,checkpoint)
;       (setf current-post-mortem-ring-buffer
;             (cdr-of-cons current-post-mortem-ring-buffer))
;       (when log-post-mortem-ring-buffer-to-file-p
;         (log-post-mortem-checkpoint ,checkpoint)))))

;(defun collect-post-mortem-checkpoints ()
;  (loop for index from 0 below current-post-mortem-ring-buffer-length
;        for checkpoint in (cdr current-post-mortem-ring-buffer)
;        when checkpoint
;          collect checkpoint into all-checkpoints using gensym-cons
;        finally (return (nreverse all-checkpoints))))


;; jh, 11/6/91.  Added reporting the the several most recent checkpoints instead
;; of just one.  This involved defining post-mortem-internal-buffer to hold 5
;; checkpoints in most-recent order, and post-mortem-report-buffer to hold the
;; same checkpoints with backwards arrows between them.  This makes the error placard
;; more readable without complicated formatting, risky during error reporting.

(defvar depth-of-post-mortem-checkpoint-reporting 5)

(defun initialize-post-mortem-internal-buffer ()
  (loop for index from 0 below depth-of-post-mortem-checkpoint-reporting
        collect nil))

(def-system-variable post-mortem-internal-buffer OS-ERROR
  (:funcall initialize-post-mortem-internal-buffer))

(def-system-variable post-mortem-report-buffer OS-ERROR
  (:funcall initialize-post-mortem-report-buffer))

(defun initialize-post-mortem-report-buffer ()
  (let ((final-index (1-f depth-of-post-mortem-checkpoint-reporting)))
    (declare (type fixnum final-index))
    (loop for index from 0 to final-index
          collect nil
          if (=f index final-index)
            collect "<- ..."
          else
            collect "<-")))

#+unused
(defun update-post-mortem-report-buffer ()
  (loop with depth-adjusted-post-mortem-ring-buffer =
             (nthcdr (-f current-post-mortem-ring-buffer-length
                         (1-f depth-of-post-mortem-checkpoint-reporting))
                     current-post-mortem-ring-buffer)
        for index from 0 below depth-of-post-mortem-checkpoint-reporting
        for post-mortem-checkpoint in depth-adjusted-post-mortem-ring-buffer
        for pointer-to-checkpoint on post-mortem-internal-buffer
        do
    (setf (car pointer-to-checkpoint) post-mortem-checkpoint)
    finally
      (setq post-mortem-internal-buffer
            (nreverse post-mortem-internal-buffer))
      (loop for pointer-to-checkpoint-report
                on post-mortem-report-buffer by 'cddr
            for ordered-checkpoint in post-mortem-internal-buffer
            do
        (setf (car pointer-to-checkpoint-report) ordered-checkpoint))))

;; jh per bah, 2/1/91.  The probability that print-post-mortem-checkpoints conses
;; is fairly low, although print does not appear in our list of Common Lisp
;; function proscribed from consing.  It was thought that
;; print-post-mortem-checkpoints might be safer to evaluate in an error context
;; than collect-post-mortem-checkpoints, which conses.

#+development
(defun print-post-mortem-checkpoints ()
  (declare (eliminate-for-gsi))
  (loop for index from 0 below current-post-mortem-ring-buffer-length
        for checkpoint in current-post-mortem-ring-buffer
        when checkpoint
          do
          (print checkpoint)))


(defun warn-user-of-previously-aborted-g2 ()
  (notify-user
    "This G2 image is operating after an internal error occurred.  ~
     It is not recommended that you continue using this image.  ~
     A KB saved from this image should be used ~
     for reference purposes only.  ~
     Please shut down this image and start a fresh G2 image."
    ))





;;;; Debugging Information Stack

;;; Since G2 is delivered as a C image, we cannot present a backtrace of the
;;; Lisp function call stack to the user when G2 crashes.  We can, however,
;;; maintain a stack of debugging information analogous to the call stack.  The
;;; facility with-backtrace-for-internal-error performs this task.  This
;;; facility maintains a a pre-allocated array holding information intended to
;;; be useful in reporting the state of a G2 or Telewindows that has sustained
;;; an internal error.  This array is called a `backtrace stack'.  When an
;;; internal error occurs, the contents of the backtrace stack are written to a
;;; pre-allocated text-string called the `backtrace text buffer'.

;;; with-backtrace-for-internal-error <name-or-spec> &body <body>
;;; <name-or-spec> := <name> | <spec-list>
;;; <name> := <evaluated-symbol> | <quoted-constant> | <self-evaluating-constant>
;;; <spec-list> := ( <unevaluated-symbol>
;;;                  <backtrace-form>
;;;                  <twrite-function> )

;;; With-backtrace-for-internal-error returns as many values as <body> returns.
;;; The <name-or-spec> subform pushes one or more elements onto the backtrace
;;; stack when the form is entered.  With-backtrace-for-internal-error makes no
;;; attempt to reclaim these elements.

;;; With-backtrace-for-internal-error has two varieties, simple and complex.
;;; The simple variety is in effect when <name-or-spec> is either a symbol
;;; (which will be evaluated) or a value known at macroexpansion time.  The
;;; complex variety is in effect in all other cases.  Loosely and syntactically
;;; speaking, anything that looks like an atom (e.g. two, 'two, "two", or 2)
;;; signifies the simple variety and anything that looks like a list signifies
;;; the complex variety.

;;; In either variety, a token that names this particular backtrace point is
;;; placed on the backtrace stack whenever a with-backtrace-for-internal-error
;;; form is entered and there is room on the stack.  If an internal error occurs
;;; within the dynamic scope of this form, the token is written to the backtrace
;;; text buffer in order to make a report to the user, using the appropriate
;;; twrite function.  The write is followed by a twrite of a newline.  It is in
;;; the interest of the user of this macro to make the token unique, mnemonic,
;;; and easily located in the source files.

;;; The complex variety of with-backtrace-for-internal-error makes it possible
;;; to push additional elements onto the backtrace stack, and to format these
;;; elements readably when reporting an internal error to the G2/TW user.

;;; In the complex variety, <backtrace-form> will be evaluated on entry to
;;; with-backtrace-for-internal-error if the stack has enough room to store a
;;; minimal amount of information about the backtrace point (see
;;; room-for-basic-backtrace-information-p below).  The local macro
;;; push-backtrace-information is available to request that elements be added to
;;; the backtrace stack inside <backtrace-form>.  Elements will be actually be
;;; added to the backtrace stack only if there is room for all of them plus the
;;; minimal backtrace information.

;;; If an error occurs within a with-backtrace-for-internal-error form,
;;; <twrite-function> will be called with no arguments, in a context in which
;;; current-text-string is bound to the backtrace text buffer.  Inside this
;;; function, the various twrite functions may be called to format backtrace
;;; information before displaying to the end user.  The substitution macro
;;; pop-backtrace-information is available to remove elements from the backtrace
;;; stack.  A single newline is inserted after each <twrite-function> is called.

;;; Care is taken not to give <twrite-function> free rein.  Instead, the number
;;; of actual arguments to be consumed by each <twrite-function> is stored on
;;; the backtrace stack, so that the stack can be placed in synch before
;;; subsequent <twrite-function> calls.

;;; The rationale for requiring <backtrace-form> to be a form rather than a
;;; function is to avoid a mandatory function call whenever a
;;; with-backtrace-for-internal-error is entered.  This requirement also allows
;;; us to test for stack overflow only once per entry, probably worth the
;;; confusion resulting from the fact that push-backtrace-information is a local
;;; macro whereas pop-backtrace-information is a global function.
;;; <Twrite-function> must be a function rather than a form because Gensym
;;; programming style forbids closures, even downward ones.

;;; Currently (jh, 10/13/93), the cost of the simple variety of
;;; with-backtrace-for-internal-error in the usual case (when the stack has
;;; room) is
;;;   4 fixnum adds
;;;   1 fixnum comparison
;;;   3 setfs of an svref
;;;   1 special binding

;;; Currently (jh, 10/13/93), the cost of the complex variety of
;;; with-backtrace-for-internal-error in the usual case (when the stack has
;;; room) is as follows (n is the number of arguments <backtrace-form> pushes
;;; onto the backtrace stack).
;;;   n+4 fixnum adds
;;;   2   fixnum comparisons
;;;   n   setfs of an svref
;;;   n   consings
;;;   n   cdrings
;;;   n   setqs of a local variable
;;;   1   list reclamation
;;;   1   special binding

;;; Examples:

;;; The following form stores the symbol MY-BACKTRACE-POINT on the backtrace
;;; stack during the execution of the form (DO-THINGS).
;;; (with-backtrace-for-internal-error 'my-backtrace-point
;;;   (do-things))
;;; If no error occurs during the execution of the form (DO-THINGS), all the
;;; values returned by (DO-THINGS) will be returned from the form.  If an error
;;; does occur, the following text-string will be added to the backtrace text
;;; buffer.
;;; "MY-BACKTRACE-POINT
;;; "

;;; The following forms store three symbols on the backtrace stack.
;;; (defun twrite-for-my-backtrace-point-2 ()
;;;   (twrite-string "  ")
;;;   (loop for index from 1 to 3
;;;        do (twrite-symbol (pop-backtrace-information))
;;;           (when (<f index 3) (twrite-string ", "))))
;;;
;;; (with-backtrace-for-internal-error
;;;     (my-backtrace-point-2
;;;     (progn
;;;       (push-backtrace-information 'larry)
;;;       (push-backtrace-information 'curly)
;;;       (push-backtrace-information 'moe))
;;;      twrite-for-my-backtrace-point-2)
;;;   (do-things-2))
;;; If no error occurs during the execution of the form (DO-THINGS-2), all the
;;; values returned by (DO-THINGS-2) will be returned from the form.  If an
;;; error does occur, the following text-string will be added to the backtrace
;;; text buffer
;;; "MY-BACKTRACE-POINT-2
;;;   MOE, CURLY, LARRY
;;; "

(defconser backtrace)



;;; The global variable `backtrace-stack-for-internal-error' contains entries
;;; for the backtrace stack.  Each entry is an element placed there by the local
;;; macro push-backtrace-information inside a with-backtrace-for-internal-error
;;; form.  This variable is internal to the backtrace facility and should not be
;;; explicitly referenced outside of it.

;;; The top element on the backtrace stack is always a symbol naming the
;;; backtrace point.  The second element is either a symbol naming a twrite
;;; function, or nil.  The third element is the number of remaining args, so we
;;; can shrug off the effect of a bad <twrite-function>.  Remaining elements are
;;; pushed by <backtrace-form>, to be popped by <twrite-function> in case of an
;;; internal error.

(defvar backtrace-stack-for-internal-error
  (make-array
    size-of-backtrace-stack-for-internal-error
    :element-type t
    :initial-element nil))

;;; The global variable `index-of-top-of-backtrace-stack' is bound to the index
;;; in backtrace-stack-for-internal-error that holds the most recently recorded
;;; backtrace information.  This variable is internal to the backtrace facility
;;; and should not be explicitly referenced outside of it.

(defvar index-of-top-of-backtrace-stack -1)

;;; The substitution macro `initialize-backtrace-stack' is called by
;;; do-error-trapping after the stack has formatted to
;;; backtrace-text-buffer-for-internal-error, so any subsequent errors are
;;; reported with a fresh backtrace stack.

(def-substitution-macro initialize-backtrace-stack ()
  (setq index-of-top-of-backtrace-stack -1))

;;; The substitution macro `pop-backtrace-information' pops an element from the
;;; backtrace stack and returns it.  If the backtrace stack is empty, this macro
;;; returns nil.  Pop-backtrace-stack is external to this facility and may be
;;; used by any twrite function specified in a
;;; with-backtrace-for-internal-error-form.

(def-substitution-macro pop-backtrace-information ()
  (if (<f index-of-top-of-backtrace-stack 0)
      nil
      (prog1
        (svref
          backtrace-stack-for-internal-error
          index-of-top-of-backtrace-stack)
        (decff index-of-top-of-backtrace-stack))))



;;; The substitution macro `room-for-basic-backtrace-information-p' returns
;;; non-nil if the backtrace stack can hold the essential information
;;; for a single backtrace point.  Currently (jh, 10/13/93) this
;;; information includes
;;;   (1) the name of the backtrace point,
;;;   (2) the name of a twrite function or nil, and
;;;   (3) the number of associated elements pushed onto the backtrace stack
;;;       by calls to push-backtrace-information within the lexical scope
;;;       of a with-backtrace-for-internal-error form.
;;; (For further details on the layout of the backtrace stack, see the
;;; documentation of the variable backtrace-stack-for-internal-error above.)  If
;;; there is not sufficient room to hold the essential backtrace information,
;;; room-for-basic-backtrace-information-p returns nil.  This macro is internal
;;; to the backtrace facility and should not be explicitly called outside of it.

(def-substitution-macro room-for-basic-backtrace-information-p ()
  (<=f (+f index-of-top-of-backtrace-stack size-of-basic-backtrace-information)
       maximum-index-in-backtrace-stack-for-internal-error))

;;; The substitution macro `push-basic-backtrace-information' unconditionally
;;; places the name of a backtrace point and a twrite function onto the
;;; backtrace stack.  This function assumes there is room on the stack for these
;;; elements, i.e., it assumes that room-for-basic-backtrace-information-p is
;;; true.  Push-basic-backtrace-information is internal to the backtrace
;;; facility and should not be explicitly called outside of it.

(def-substitution-macro push-basic-backtrace-information
                        (info-symbol twrite-function? number-of-args)
  (incff index-of-top-of-backtrace-stack)
  (setf (svref
          backtrace-stack-for-internal-error
          index-of-top-of-backtrace-stack)
        number-of-args)
  (incff index-of-top-of-backtrace-stack)
  (setf (svref
          backtrace-stack-for-internal-error
          index-of-top-of-backtrace-stack)
        twrite-function?)
  (incff index-of-top-of-backtrace-stack)
  (setf (svref
          backtrace-stack-for-internal-error
          index-of-top-of-backtrace-stack)
        info-symbol))

;;; The macro `with-backtrace-for-internal-error-simple' implements the simple
;;; variety of with-backtrace-for-internal-error.  It is internal to the
;;; backtrace facility and should not be explicitly used outside of it.

(defmacro with-backtrace-for-internal-error-simple
          (token-naming-backtrace-point &body body)
  `(let ((index-of-top-of-backtrace-stack index-of-top-of-backtrace-stack))
     (when (room-for-basic-backtrace-information-p)
       (push-basic-backtrace-information ,token-naming-backtrace-point nil 0))
       ,@body))

;;; The macro `with-backtrace-for-internal-error-complex' implements the complex
;;; variety of with-backtrace-for-internal-error.  It is internal to the
;;; backtrace facility and should not be explicitly used outside of it.

;;; Since backtrace-stack-for-internal-error (q.v.) has an expected layout,
;;; with-backtrace-for-internal-error-complex has to batch all calls to
;;; push-backtrace-information.  Otherwise, the backtrace stack would get out of
;;; synch at a stack overflow.

(defmacro with-backtrace-for-internal-error-complex
    ((name-of-backtrace-point
       backtrace-form
       twrite-function)
     &body body)
  (avoiding-variable-capture (&aux old-top-of-stack elements-to-push?)
    `(let ((index-of-top-of-backtrace-stack index-of-top-of-backtrace-stack))

       ;; When there is room for at least the backtrace name and twrite
       ;; function:
       (when (room-for-basic-backtrace-information-p)

         ;; Save the top of the stack and establish a buffer to hold backtrace
         ;; values until we can check for stack overflow.
         (let ((,old-top-of-stack index-of-top-of-backtrace-stack)
               (,elements-to-push? nil))

           ;; The local macro `push-backtrace-information' allows the backtrace
           ;; form to place an arbitrary number of elements on the backtrace
           ;; stack.  Until we know the stack will not overflow, these elements
           ;; are stored in the local variable elements-to-push? using a
           ;; distinctive kind of cons.
           (macrolet ((push-backtrace-information (backtrace-info)
                        `(progn
                           (incff index-of-top-of-backtrace-stack)
                           (backtrace-push ,backtrace-info
                                           ,',elements-to-push?))))

             ;; Run the backtrace form, which may call
             ;; push-backtrace-information an arbitrary number of times.
             ,backtrace-form

             (cond

               ;; If there is room on the backtrace stack for all the elements
               ;; plus basic information:
               ((room-for-basic-backtrace-information-p)

                ;; Actually put the elements into the array that implements the
                ;; backtrace stack.
                (let ((stored-elements-to-push ,elements-to-push?))
                  (loop while ,elements-to-push?
                        with index
                        = index-of-top-of-backtrace-stack
                        do
                    (setf (svref backtrace-stack-for-internal-error index)
                          (pop ,elements-to-push?))
                    (decff index))
                  ;; Reclaim all at once for efficiency (backtrace-pop uses
                  ;; globals).
                  (reclaim-backtrace-list stored-elements-to-push))

                ;; Record the name of the backtrace point, the user's twrite
                ;; function, and the number of elements pushed.
                (push-basic-backtrace-information
                  ',name-of-backtrace-point
                  ',twrite-function
                  (-f index-of-top-of-backtrace-stack ,old-top-of-stack)
                  ))

               ;; Otherwise, there is only room on the stack for basic backtrace
               ;; information.
               (t (setq index-of-top-of-backtrace-stack
                        ,old-top-of-stack)

                  ;; Record the name of the backtrace point and ignore the
                  ;; twrite function.
                  (push-basic-backtrace-information
                    ',name-of-backtrace-point
                    nil
                    0))))))

       ,@body)))

;;; The macro `with-backtrace-for-internal-error' simply dispatches to one of
;;; the internal macros with-backtrace-for-internal-error-complex or
;;; with-backtrace-for-internal-error-simple.

(defmacro with-backtrace-for-internal-error (name-or-spec-list &body body)
  (if (or (symbolp name-or-spec-list) (constantp name-or-spec-list))
      `(with-backtrace-for-internal-error-simple ,name-or-spec-list
         ,@body)
      `(with-backtrace-for-internal-error-complex ,name-or-spec-list
         ,@body)))




#+(and chestnut-3 chestnut-trans)
(def-gensym-c-function c-get_backtrace (:void "inline_get_backtrace")
  ())

#+(and chestnut-3 chestnut-trans)
(def-gensym-c-function c-print_backtrace_into_string
    (:fixnum-int "inline_print_backtrace_into_string")
  ((:string-buffer buffer) (:fixnum-int offset)))



;; jh, 10/14/93.  The following two macros, def-preallocated-text-string and
;; with-output-to-preallocated-text-string actually belong in UTILITIES1, but
;; for now I am keeping them out of the way of Jim's ongoing work on the string
;; allocators.

;;; The macro `def-preallocated-text-string' creates defvars holding input and
;;; output text-strings and a defconstant holding the maximum length of these
;;; strings, all for use in twith-output-to-preallocated-text-string.  The input
;;; text-string is named input-string-for-<name>, the output string is names
;;; <name>, and the length constant is named length-of-<name>.
;;; Def-preallocated-text-string creates data objects of identical type to
;;; text-strings allocated from Gensym's string pools, but outside the context
;;; in which such pools are used.

;;; The macro `def-preallocated-gensym-string' does the same for the
;;; gensym-string data type.


(defun-for-macro get-name-of-preallocated-input-string
                 (name-of-output-string)
  (intern (format nil "INPUT-STRING-FOR-~a" name-of-output-string)))

(defun-for-macro get-name-of-length-of-preallocated-string
                 (name-of-output-string)
  (intern (format nil "LENGTH-OF-~a" name-of-output-string)))

(defmacro def-preallocated-text-string (name-of-output-string length)
  (unless (fixnump length)
    (error "DEF-PREALLOCATED-TEXT-STRING: length should be an integer, not ~a"
           length))
  (let ((name-of-input-string
          (get-name-of-preallocated-input-string name-of-output-string))
        (name-of-length-constant
          (get-name-of-length-of-preallocated-string name-of-output-string)))
    `(progn
       (eval-when (:compile-toplevel :load-toplevel :execute)
         (defconstant ,name-of-length-constant ,length))
       (defvar ,name-of-input-string
         (make-wide-string ,length))
       (defvar ,name-of-output-string
         (make-wide-string ,length)))))

(defun-for-macro get-name-of-preallocated-input-gensym-string
                 (name-of-output-gensym-string)
  (intern (format nil "INPUT-GENSYM-STRING-FOR-~a" name-of-output-gensym-string)))

(defun-for-macro get-name-of-length-of-preallocated-gensym-string
                 (name-of-output-gensym-string)
  (intern (format nil "LENGTH-OF-~a" name-of-output-gensym-string)))

(defmacro def-preallocated-gensym-string (name-of-output-string length)
  (unless (fixnump length)
    (error "DEF-PREALLOCATED-GENSYM-STRING: length should be an integer, not ~a"
           length))
  (let ((name-of-input-gensym-string
          (get-name-of-preallocated-input-gensym-string name-of-output-string))
        (name-of-length-constant
          (get-name-of-length-of-preallocated-gensym-string name-of-output-string)))
    `(progn
       (eval-when (:compile-toplevel :load-toplevel :execute)
         (defconstant ,name-of-length-constant ,length))
       (defvar ,name-of-input-gensym-string
         (make-string ,length))
       (defvar ,name-of-output-string
         (make-array
           ,length
           :element-type (gensym-string-char-type)
           :fill-pointer 0)))))






;;; twith-output-to-preallocated-text-string <name> &body <body>

;;; The macro `twith-output-to-preallocated-text-string' is like
;;; twith-output-to-text-string, except that its body writes into a
;;; pre-allocated simple text-string and copies the results into a pre-allocated
;;; adjustable text-string.  Both input and output strings are defined by
;;; def-preallocated-text-string.  Twith-output-to-preallocated-text-string does
;;; not return a useful value.

;;; As in twith-output-to-text-string, a twrite function may call
;;; extend-current-text-string indirectly within the dynamic scope of this
;;; macro, possibly reclaiming the contents of the input text-string in order to
;;; extend it.  Since these strings are typically preallocated for safe error
;;; reporting, the hope is that they are long enough so that reclamation will
;;; never happen.  However, if reclamation does occur, the variable holding the
;;; input string is setq'd to the new extended string upon exit from this macro.
;;; Doing so does not corrupt the string pool because the input text-string is
;;; not shared anywhere else.

;;; The macro `twith-output-to-preallocated-gensym-string' works the same way,
;;; but creates gensym strings.

(defmacro twith-output-to-preallocated-text-string
    (output-text-string-name &body body)
  (unless (symbolp output-text-string-name)
    (error "TWITH-OUTPUT-TO-PREALLOCATED-TEXT-STRING: ~
            text-string must be a symbol, not ~a"
           output-text-string-name))
  (let ((input-string
         (get-name-of-preallocated-input-string output-text-string-name)))
    `(let ((current-wide-string-list 'do-not-use)) ; per convention in UNICODE
       (with-designated-current-wide-string ,input-string
         (let ((original-input-string ,input-string))
           (progn ,@body)
           (unless (eq current-wide-string original-input-string)
             (setq ,input-string current-wide-string))
           (setf (wide-string-length ,output-text-string-name) ; "fill-pointerw"?!
                 fill-pointer-for-current-wide-string)
           (copy-portion-of-wide-string-into-wide-string
             current-wide-string 0 fill-pointer-for-current-wide-string
             ,output-text-string-name 0)
           nil)))))



(defmacro twith-output-to-preallocated-gensym-string
          (output-gensym-string-name &body body)
  (unless (symbolp output-gensym-string-name)
    (error "TWITH-OUTPUT-TO-PREALLOCATED-GENSYM-STRING: ~
            gensym-string must be a symbol, not ~a"
           output-gensym-string-name))
  (let ((input-string
          (get-name-of-preallocated-input-gensym-string output-gensym-string-name)))
    `(with-designated-current-gensym-string ,input-string
         (let ((original-input-string ,input-string))
           (progn ,@body)
           (unless (eq current-gensym-string original-input-string)
             (setq ,input-string current-gensym-string))
           (setf (fill-pointer ,output-gensym-string-name)
                 fill-pointer-for-current-gensym-string)
           (copy-portion-of-string-into-gensym-string
             current-gensym-string 0 fill-pointer-for-current-gensym-string
             ,output-gensym-string-name 0)
           nil))))


;;; The global variable `backtrace-text-buffer-for-internal-error' is a
;;; pre-allocated simple text-string which holds the result of twriting the
;;; backtrace stack.  This variable is referenced in the various
;;; def-g2-signal-handler functions.

(def-preallocated-text-string backtrace-text-buffer-for-internal-error 4000)

;;; The function `update-backtrace-text-buffer-for-internal-error' updates the
;;; variable backtrace-text-buffer-for-internal-error.  This function is called
;;; by various def-g2-signal-handler functions before throwing to
;;; (top-level-error-catcher), at which point the contents of
;;; backtrace-text-buffer-for-internal-error are further formatted.  In each
;;; handler, backtrace-text-buffer-for-internal-error is formatted into larger
;;; text-strings that report the error to the G2/TW user.

(defun update-backtrace-text-buffer-for-internal-error ()
  (twith-output-to-preallocated-text-string
    backtrace-text-buffer-for-internal-error
    #+(and chestnut-3 chestnut-trans)
    (loop with len = (c-print_backtrace_into_string
                       buffer-for-internal-error-on-console 0)
          for i from 0 below len
          for ch = (gchar buffer-for-internal-error-on-console i nil)
          do (twrite-char (if (char= #\newline ch)
                              #.%line-separator
                              (code-wide-character (char-code ch)))))
    (tformat "Backtrace:")
    (loop until (<f index-of-top-of-backtrace-stack 0)
          do
      (let ((old-top-of-stack index-of-top-of-backtrace-stack))
        (tformat "~%  ~A" (pop-backtrace-information))
        (let* ((twrite-function? (pop-backtrace-information))
               (number-of-args (pop-backtrace-information)))
          (when twrite-function?
            (tformat "~%  ")
            (funcall twrite-function?))
          ;; The twrite function may have popped the wrong number of args, so we
          ;; sidestep whatever it did by adjusting the stack pointer according
          ;; to the number of actual arguments pushed by the backtrace form.
          (setq index-of-top-of-backtrace-stack
                (-f old-top-of-stack
                    (+f number-of-args size-of-basic-backtrace-information))))))
    (tformat "~%")))

#+development
(progn

(defun twrite-for-my-backtraceables ()
  (twrite-string "  ")
  (loop for index from 1 to 3
        do (twrite-symbol (pop-backtrace-information))
           (when (<f index 3) (twrite-string ", "))))


(defmacro def-backtracable-function (n next-p)
  (let ((name (intern (format nil "BACKTRACEABLE-~a" n)))
        (next-name (intern (format nil "BACKTRACEABLE-~a" (1+ n)))))
    (flet ((intern-subinfo (n)
             (intern (format nil "~a-~a" name n))))
      `(defun ,name ()
         (format t "~&entering backtraceable-~a~%" ,n)
         (with-backtrace-for-internal-error
             (,name
                (progn
                  (push-backtrace-information ',(intern-subinfo 1))
                  (push-backtrace-information ',(intern-subinfo 2))
                  (push-backtrace-information ',(intern-subinfo 3)))
                twrite-for-my-backtraceables)
           (format t "~&entering with-backtracing scope ~a~%" ,n)
           ,(if next-p
                `(,next-name)
                `(cerror "Resume" "Test of backtracing"))
           (format t "~&leaving with-backtracing scope ~a~%" ,n))
         (format t "~&leaving backtraceable-~a~%" ,n)))))

(def-backtracable-function 3 nil)
(def-backtracable-function 2 t)
(def-backtracable-function 1 t)
)

;; To test:
;; (backtracable-1)
;;
;; entering backtraceable-1
;; entering with-backtracing scope 1
;;   stack: 5
;; entering backtraceable-2
;; entering with-backtracing scope 2
;;   stack: 11
;; entering backtraceable-3
;; entering with-backtracing scope 3
;;   stack: 17
;; >>Error: Test of backtracing
;;
;; (update-backtrace-text-buffer-for-internal-error)
;;
;; NIL
;;
;; backtrace-text-buffer-for-internal-error
;;
;; "BACKTRACEABLE-3
;;   backtraceable-3-3, backtraceable-3-2, backtraceable-3-1
;; BACKTRACEABLE-2
;;   backtraceable-2-3, backtraceable-2-2, backtraceable-2-1
;; BACKTRACEABLE-1
;;   backtraceable-1-3, backtraceable-1-2, backtraceable-1-1
;; "



;;; multiple-value-bind-if-necessary <var-or-vars> <initform> &body <body>

;;; The macro `multiple-value-bind-if-necessary' uses the multiple-values-bind
;;; special form only if needed.  If <var-or-vars> is nil, the macro expands
;;; into a PROGN that executes <initform> followed by <body>..  If <var-or-vars>
;;; is a symbol or a list of a single symbol, multiple-value-bind-if-necessary
;;; expands into a LET form that binds that symbol to <initform> and executes
;;; <body> with that binding.  Otherwise, multiple-value-bind-if-necessary
;;; expands into a MULTIPLE-VALUE-BIND form that binds the variables in
;;; <var-or-vars> to the values returned by <initform> and executes <body> with
;;; these bindings.

;; jh, 10/8/93.  Multiple-value-bind-if-necessary is no longer used in
;; with-backtrace-for-internal-error.

(defmacro multiple-value-bind-if-necessary
    (var-or-var-list initform  &body body)
  (assert (or (symbolp var-or-var-list)
              (listp var-or-var-list)))
  (cond ((null var-or-var-list)
         `(progn ,initform ,@body))
        ((symbolp var-or-var-list)
         `(let ((,var-or-var-list ,initform)) ,@body))
        ((null (cdr var-or-var-list))
         `(let ((,(first var-or-var-list) ,initform)) ,@body))
        (t `(multiple-value-bind ,var-or-var-list ,initform ,@body))))





;;;; Internal Errors

;; Added error-within-error-p for Chestnut.  This will not affect G2 behavior on
;; any other platform, since we call internal-error outside the scope of the error
;; catcher, and so it will never get called recursively.  In Chestnut, we will
;; re-establish the signal handler before we call internal-error to report the
;; first error, and so it is entirely possible for internal-error to get called
;; recursively.  jh, 3/18/91.

(def-system-variable error-within-error-p OS-ERROR nil nil t)

;; jh, 3/22/91.  Internal-error now sets error-within-error-p so we can detect
;; recursive errors.  So far this only works in Chestnut images, but it can be
;; retrofitted if necessary.  Error-within-error-p is a system variable defined in
;; PRIMITIVES.

;; jh, 5/22/91.  Changed internal error to allow for the possibility that we are
;; sure the error format control-string will work with the argument list.  If this
;; is so, we can risk giving them to apply.  As of this date, we are only sure of
;; the format info when we are in Chestnut, since we created it ourselves.



;;; The global variable `buffer-for-internal-error-on-console' is a
;;; pre-allocated adjustable string that holds the complete string to be printed
;;; to the machine console in case of an internal error.  It is pre-allocated to
;;; minimize the chance that we could exhaust memory while reporting the error
;;; itself.  This is an ASCII string, not a G2 text-string, and is not suitable
;;; for printing on the G2 logbook.  For that, see
;;; buffer-for-internal-error-on-logbook.

(def-preallocated-gensym-string buffer-for-internal-error-on-console 4000)

;;; The global variable `buffer-for-internal-error-on-logbook' is a
;;; pre-allocated adjustable string which holds the complete text-string to be
;;; displayed in the G2 logbook in case of an internal error.  It is
;;; pre-allocated to minimize the chance that we could exhaust memory while
;;; reporting the error itself.  This is a G2 text-string, not an ASCII string,
;;; not suitable for printing on the machine console.  For that, see
;;; buffer-for-internal-error-on-console.

(def-preallocated-text-string buffer-for-internal-error-on-logbook 4000)

(defvar idling-wait-state-string)

;;; The function `internal-error-given-format-info' takes three arguments, The
;;; first argument, <raw-format-string>, is a Lisp string intended to be a
;;; format control string.  The second argument, <list-of-format-args> is a Lisp
;;; list intended to provide the arguments for <raw-format-string>.  The string
;;; <raw-format-string> and the list <list-of-format-args> may or may not have
;;; been allocated from Gensym memory pools, so this function will not reclaim
;;; them.  The third argument, <sure-of-format-info-p>, indicates whether or not
;;; the format string and arguments originated from Gensym code.  If so, we can
;;; produce a prettier formatted result, since we feel justified in actually
;;; handing the control string to tformat.  Internal-error-given-format-info
;;; will use the format control string and arguments to write an error message
;;; to the user's console (loosely speaking, a `console' is a place in which
;;; error messages are displayed with little further risk of crashing).  Then
;;; internal-error-given-format-info will display a dialog which forces the user
;;; to acknowledge the fact that an error has occurred in order to continue.




;;;; Dealing with Ascii Strings

(defun-void twrite-ascii-from-gensym-string (gensym-string)
  (loop with escape-character?
        with string-is-simple? = (simple-gensym-string-p gensym-string)
        with length-of-string fixnum = (glength gensym-string string-is-simple?)
        with i fixnum = 0
        while (<f i length-of-string)
        as character-or-character-code
          = (read-gensym-character-from-gensym-string
              gensym-string i string-is-simple? escape-character?)
        do (cond
             ((null escape-character?)
              (twrite-char character-or-character-code))
             ((char= escape-character? #\~)
              (character-case character-or-character-code
                ((#\~ #\@ #\\)
                 (twrite-char character-or-character-code))
                (t
                  (twrite-char #\~)
                  (twrite-char character-or-character-code)
                  ;; this character cannot be translated into ascii -- for now,
                  ;; we write the next character using Gensym charset notation,
                  ;; but that's probably not the right thing!  (MHD 2/14/94)
                  )))
             ((char= escape-character? #\@)
              (character-case character-or-character-code
                ((#\L #\P)                ; #\P may not be used at present
                 (twrite-char #\Newline))
                (t
                  ;; this character cannot be translated into ascii -- for now,
                  ;; we write the next character using Gensym charset notation,
                  ;; but that's probably not the right thing!  (MHD 2/14/94)
                  (twrite-char #\@)
                  (twrite-char character-or-character-code))))
             ((char= escape-character? #\\)
              ;; this character cannot be translated into ascii -- for now,
              ;; we write the next character using Gensym charset notation,
              ;; but that's probably not the right thing!
              ;;
              ;; This is an asian ("kanji") character.
              ;;
              ;; NOTE: prior to 4.0, we would translate the ~'s and @'s embedded
              ;; in in the 2/3 character sequence after a \ into ASCII.  That
              ;; was wrong, and this code now does not have that problem.
              ;; (MHD 2/14/94)
              (twrite-kanji-character character-or-character-code)))))

;; Twrite-ascii-from-gensym-string used to "mistranslate" Japanese characters into
;; ASCII or into the Gensym character encoding.  The set of all JIS characters
;; that this mistranslated is exactly the set of characters that would be
;; encoded using the ~ or @ character.  (Note that \'s embedded were ok.) A function
;; used to exist here that determines this set, but that has not been needed since
;; 3.0, and I'm now flusing it rather than maintain unneeded code through all the
;; stages of the wide-string conversion project (MHD 6/12/96).


(defun notify-console-of-internal-error
       (raw-format-string list-of-format-args)
  (twith-output-to-preallocated-gensym-string
    buffer-for-internal-error-on-console
    (tformat "~%------------------------------------")
    (tformat "~%AN INTERNAL ERROR OCCURRED!~%")
    (tformat "~a " (system-alias current-system-name))
    (twrite-system-version (system-version current-system-name))
    (tformat " (~a)~%" build-identification-string)
    (write-local-identification-info-text-string-1 nil)
    (tformat "~%Raw internal error data follows:")
    (tformat "~%")
    (apply #'tformat raw-format-string list-of-format-args)
    (tformat "~%")
    (multiple-value-bind (second minute hour date month year)
        (get-decoded-real-time)
      ;; e.g. "10 Dec 1986  8:05:19"
      (tformat "~%[~d ~a ~d"
               date
               (nth (-f month 1)
                    '("Jan" "Feb" "Mar" "Apr" "May" "Jun"
                      "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"))
               year)
      (tformat "  ~d:~a~d:~a~d]"
               hour
               (if (<f minute 10) "0" "")
               minute
               (if (<f second 10) "0" "")
               second))
    (tformat "~%------------------------------------")
    (tformat "~%"))
  (twith-output-to-preallocated-gensym-string
    buffer-for-internal-error-on-console
    (twrite-ascii-from-gensym-string
      buffer-for-internal-error-on-console))
  (let ((length-of-buffer (length buffer-for-internal-error-on-console)))
    ;; jh, 7/7/94.  The following works around a Chestnut bug in printing strings
    ;; with fill pointers.  I will email a small example to Chestnut to get an
    ;; actual fix.
    (when (<f length-of-buffer length-of-buffer-for-internal-error-on-console)
      (setf (char buffer-for-internal-error-on-console length-of-buffer)
            #\Null)))                        ; = #.(code-char 0)
  (print-internal-error-data-on-console buffer-for-internal-error-on-console))

(defun print-internal-error-data-on-console (error-report-string)
  (format t "~a" error-report-string)
  (maybe-write-abort-file error-report-string)
  (maybe-email-error-report error-report-string))

(defvar abort-file-written-p nil)

(defun maybe-write-abort-file (error-report-string)
  (unless abort-file-written-p
    (setq abort-file-written-p t)
    (maybe-write-string-to-directory
      "abort"
      (get-gensym-environment-variable "G2_ABORT_DIRECTORY")
      error-report-string)))

(defun maybe-write-string-to-directory (name directory string)
  (let ((temporary-file (when directory
                          (write-string-to-temporary-file
                            "g2_internal_error_report" string))))
    (when temporary-file
      (multiple-value-bind (host-name port-list)
          (get-raw-network-info)
        (let* ((command-string
                 (tformat-text-string
                   "cd ~A;/usr/bin/mv -f ~A `date +~A-%y-%m-%d-%H-%M-%S`-~(~A~)-~A-~A.log"
                   directory
                   temporary-file
                   name
                   (system-alias current-system-name)
                   host-name
                   (second (first port-list)))))
          (c-spawn_command_line_process command-string)
          (reclaim-text-string command-string))
        (reclaim-raw-network-info host-name port-list))
      (reclaim-text-string temporary-file)
      t)))

(defvar email-abort-message-sent-p nil)

(defun maybe-email-error-report (error-report-string)
  (unless email-abort-message-sent-p
    (setq email-abort-message-sent-p t)
    (maybe-email-string-to-address
      "G2 Internal Error Report"
      (get-gensym-environment-variable "G2_ABORT_EMAIL_ADDRESS")
      error-report-string)))

(defun maybe-email-string-to-address (subject address string)
  (let ((temporary-file (when address
                          (write-string-to-temporary-file
                            "g2_internal_error_report" string))))
    (when temporary-file
      (let* ((command-string
               (tformat-text-string
                 "/usr/ucb/mail -s '~A' ~A < ~A ; rm ~A"
                 subject address temporary-file temporary-file)))
        (c-spawn_command_line_process command-string)
        (reclaim-text-string command-string))
      (reclaim-text-string temporary-file)
      t)))

(defvar temporary-file-count 0)

(defun write-string-to-temporary-file (name-prefix string)
  (let* ((temporary-file (tformat-text-string
                          (case g2-operating-system
                            (unix
                             "/tmp/~A_~D")
                            (win32
                             "c:\\temp\\~A_~D.txt")
                            (t
                             "~A_~D"))
                           name-prefix
                           (incff temporary-file-count)))
         (stream-or-error
           (c-g2_stream_open
             temporary-file
             g2-stream-open-mode-for-output)))
    (cond ((=f stream-or-error g2-stream-foreign-file-op-failure)
           (reclaim-text-string temporary-file)
           nil)
          (t
           (let ((gensym-string (if (gensym-string-p string)
                                    string
                                    (export-text-string
                                     string
                                     'utf-8-gensym-string-with-newline))))
             (c-g2_stream_write_string gensym-string stream-or-error 0)
             (unless (eq gensym-string string)
               (reclaim-gensym-string gensym-string)))
           (c-g2_stream_close stream-or-error)
           temporary-file))))

(defun internal-error-given-format-info
    (raw-format-string list-of-format-args sure-of-format-info-p)
  (declare (eliminate-for-gsi))
  (with-dynamic-creation ;safer?
    (let ((error-within-error-p t))

      ;; Put up message on console (safest bet).
      (notify-console-of-internal-error
        raw-format-string
        list-of-format-args)

      ;; Put up logbook message.
      (twith-output-to-preallocated-text-string
        buffer-for-internal-error-on-logbook
        (write-internal-error
          raw-format-string
          list-of-format-args
          sure-of-format-info-p))
      (notify-engineer
        "~a"
        buffer-for-internal-error-on-logbook)
      (unless (exit-on-abort-p)
        (pause-for-internal-error
          buffer-for-internal-error-on-logbook))
      (loop for bombout-function in bombout-clean-up-functions
            do (funcall bombout-function))
      (when (exit-on-abort-p)
        (c-exit -1))
      (notify-engineer
        "~a"
        (twith-output-to-text-string
          (tformat "Error acknowledged.")
          (when (and system-is-running (not system-has-paused))
            (tformat "  System is now paused.  ")
            (tformat "You may resume, reset, or restart.")))))))


;; jh, 10/18/91.  Moved print-internal-error-data-on-console to PRIMITIVES, since
;; it is used by Telewindows in error reporting and Telewindows has no other need
;; to load this module (RUN).

;; This has to be maximally safe!  [Consider implementing this in terms of
;; even lower level primitives to insure that.]

;; jh per ac, 5/21/91.  Changed print-internal-error-data-on-console to use
;; minimal format directives.  The ~2,'0d directive was confusing Chestnut.  By
;; the way, this function is still not yet safe enough, unless we are sure that
;; format never conses with these directives.





;;; The global variable `buffer-for-write-internal-error' is a pre-allocated
;;; simple text-string which holds the formatted error text to be printed in
;;; case of an internal error.  It is pre-allocated to minimize the chance that
;;; we could exhaust memory while reporting the error itself.

(def-preallocated-text-string buffer-for-write-internal-error 4000)

(defun write-internal-error
       (raw-format-string list-of-format-args sure-of-format-info-p)
  (tformat
    "G2 ABORTED DUE TO AN INTERNAL ERROR.  ~
     For this reason, it may not be safe to run or save a knowledge base, ~
     and you will be prevented from proceeding ~
     until you acknowledge this warning.  ~
     It is recommended that you ~
     save out the current KB under a different name ~
     (to avoid overwriting the original KB), ~
     shut down G2, ~
     restart G2 using the original KB (not the KB saved after the internal error), ~
     and report the problem to Gensym.  ~
     The internal error message was: \"")
  (cond
    (sure-of-format-info-p
     (twith-output-to-preallocated-text-string
       buffer-for-write-internal-error
       (apply #'tformat raw-format-string list-of-format-args))
     (twrite-string buffer-for-write-internal-error))
    (t
     ;; This case is never to be reached.  The special variable
     ;; sure-of-format-info-p is always true by the time write-internal-error is
     ;; called.  This applies to signals and errors in both distribution and
     ;; development. (MHD/JH 6/5/96)
     (twrite-string "internal error; no further information available")))
  (twrite-string "\"."))

;; jh, 5/23/91.  Changed with-output-to-text-string to twith-output-to-text-string
;; in write-internal-error so Chestnut would report error strings correctly on the
;; "internal error" placard.  With-output-to-text-string uses the Lisp wrapper
;; with-output-to-string, which Chestnut has not yet implemented, and which we
;; don't want anyway because it is not on the list of required cons-free Lisp
;; functions.  I realize that this change makes it impossible to call
;; write-internal-error before system variables are bound yet.  But system
;; variables are always bound by the time we enter the do-error-trapping scope, so
;; using twith-output-to-text-string will always work.







;;;; Def-error-reporter

;; After a G2 crash, we want to run functions that place useful information in a
;; file for use in debugging.  For example, we would like a readout of the many
;; VMS system parameters and account quotas.  Furthermore, we would like to get
;; as much information as possible out of the error report, so we would like to
;; prioritze these functions in order of risk.

;; An example of the scale of risk:

;; 0 foreign call to a C function that allocates no new memory and uses printf()
;; 1 allocates no new memory and uses Lisp print
;; 2 uses format on a control string (risk of runtime error from control string)
;; 3 prints a tree structure (risk of sharing)
;; 4 prints arbitrary slots in frames (risk of corruption)
;; 5 runs a shell script or command file from the image (risks exhausting process space)

;; def-error-reporter ( <filename> <risk> ) &body body





;;;; Signal Functions

;;; In G2, the signal function is usually g2-signal-handler, which throws to a
;;; Lisp catch point established by the macro do-error-trapping (vide infra).
;;; Other signal functions exist, some called at special times in the life of the
;;; G2 process (like g2-signal-handler-for-launch), some called for a particular
;;; signal (like handle-broken-pipe-signal).

;; jh, 10/1/91.  Since we now handle both signals and internal calls to
;; ab-lisp:error, we use gensym-error-format-string and gensym-error-argument-list to
;; hold the format strings and arglists from either signals or errors.  The only
;; cons lossage is when we drop an empty string the first time
;; gensym-error-format-string is setq'd.  (It is initially an empty string as
;; defensive programming, in case it ever gets handed to our formatter.)

(defvar gensym-error-format-string "")
(defvar gensym-error-argument-list nil)
(defvar gensym-error-sure-of-format-info-p nil)



;; jh, 3/18/91.  Added a simple, non-consing signal handler for Chestnut images.
;; The handler takes advantage of the signal facility in C.  It uses this facility
;; to register a single interrupt handler for all possible interrupts.  The
;; handler function, called g2-signal-handler, is defined on the Lisp side but
;; registered on the C side.  Such hybridization is possible because of the
;; straightforward way in which Chestnut represents Lisp functions.  JRA also
;; mentions that we could not establish signal handlers for Lucid images because
;; Lucid uses the signal system internally.

;; Registering the signal handler is done by a call to the foreign function
;; cc_establish_signal_handler through the interface point
;; c-establish_signal_handler.  When a signal is caught, it is passed to a C
;; overlay function called c_gensym_error_handler.  This overlay transforms the
;; Chestnut type Object to the Lisp type fixnum before passing it on to
;; g2-signal-handler in the Lisp code.  The reason g2-signal-handler is
;; written in Lisp is so it can throw to the G2 error-trapping catchpoint
;; established in the do-error-trapping wrapper.  When g2-signal-handler is
;; called, it re-establishes itself as the handler for the next signal, sets some
;; debugging information into a system variable, and throws to the error-trapping
;; catchpoint.  Simple provision is made for errors which occur while reporting an
;; error: G2 will print a message to the terminal and quit.

;; Note that not all signals can be caught.  The main example of this is the UNIX
;; kill signal, which cannot be diverted.

;; Note that in general we only want to catch signals that cause a core dump.
;; Other signals are sometimes necessary for normal operation of the G2 image.
;; These signals include ...


(def-gensym-c-function c-establish_signal_handler
                       (:fixnum-int "g2ext_establish_signal_handler")
  ((:fixnum-int error-code)))

(def-gensym-c-function c-unestablish_signal_handler
                       (:fixnum-int "g2ext_unestablish_signal_handler")
  ((:fixnum-int error-code)))


(def-system-variable all-signal-handlers-registered-p OS-ERROR nil)

(defun signal-code-number-from-name-symbol (name-symbol)
  (loop for (signal-code-number registry-name-symbol) in signal-code-registry
        thereis (and (eq name-symbol registry-name-symbol)
                     signal-code-number)))

(defmacro signal-code-from-name (name)
  `(signal-code-number-from-name-symbol ',name))

(defun register-all-signal-handlers ()
  (cond
    ((do-not-catch-aborts-p)
     ;; maybe we should establish the signals that satisfy
     ;; (arithmetic-signal-p signal-code), too.
     (c-establish_signal_handler (signal-code-from-name SIGPIPE))
     (c-establish_signal_handler (signal-code-from-name SIGCHLD))
     (unless (eq current-system-name 'gsi)
       (loop for (code-number name-in-operating-system nil causes-core-dump-p g2-signal-handler-p)
                 in signal-code-registry
             when (and causes-core-dump-p
                       (not (or (eq name-in-operating-system 'SIGPIPE)
                                (eq name-in-operating-system 'SIGCHLD))))
               do (c-unestablish_signal_handler code-number))))
    (t
     (c-inhibit_core_dumping)
     (unless (or all-signal-handlers-registered-p
                 (eq current-system-name 'gsi))
       (register-all-signal-handlers-unconditionally)
       (setq all-signal-handlers-registered-p t)))))

(defun register-all-signal-handlers-unconditionally ()
  (loop for (code-number nil nil causes-core-dump-p g2-signal-handler-p)
            in signal-code-registry
        when (or causes-core-dump-p g2-signal-handler-p)
          do (c-establish_signal_handler code-number)))

;; jh, 8/23/91.  Changed ' to ` in internal-signal-caught-format-string for
;; esthetic reasons.  If platforms have problems with backquotes, it should be
;; changed back.  jh, 9/3/91.  Removed final period; more esthetics.

;; jh, 11/6/91.  Changed checkpoint reporting to list the last 5 checkpoints.

(defvar internal-signal-caught-format-string
         "Signal ~a (`~a') caught.~%~a")

;; We use a list instead of a fixed-length vector for
;; information-from-caught-signal because we want to pass it along to an apply to
;; format when reporting the error.

(defun initialize-information-from-caught-signal ()
  (list nil nil backtrace-text-buffer-for-internal-error))

(def-system-variable information-from-caught-signal OS-ERROR
  (:funcall initialize-information-from-caught-signal))



;;; The macro `def-g2-signal-handler' defines signal functions, which can handle both
;;; signals generated by the host operating system and errors from the underlying
;;; Lisp implementation.  ...

(defmacro def-g2-signal-handler (name arglist &rest body)
  `(progn
     (declare-funcallable-symbol ,name)
     (declare-gsi-api-symbol ,name)
     (defun ,name ,arglist ,@body)))



;; jh, 12/11/91.  Note that turning off do-error-trapping?  doesn't make much
;; sense in Chestnut, since there is no debugger there.  Indeed, it can only be
;; turned off in a dbx-ready image.

(defparameter do-error-trapping? t)

(defvar top-level-error-catcher-tag nil)

(defvar top-level-error-seen nil)


;;; The function `c-most-recent-signal-code' returns the most recent signal code
;;; G2 encounters as a fixnum.

;; jh, 8/16/93.  Now we use c-most-recent-signal-code in g2-signal-handler and
;; g2-signal-handler-for-launch in lieu of boxing a long by hand in the signal
;; handler on the C side and passing it as an argument to these Lisp functions.
;; The rationale is that tag conventions vary with the Lisp implementation.  In
;; addition, there is no standard callback facility from C into Lisp, which
;; means there is no reliable way to pass arguments into Lisp from C.  (Although
;; Lucid and Chestnut each have a def-foreign-callable facility, it is safer not
;; to take chances until we need such a facility elsewhere.)

(def-gensym-c-function c-most-recent-signal-code
                       (:fixnum-int "g2ext_most_recent_signal_code")
  ())

(defmacro entering-signal-handler ()
  `(current-system-case
     (gsi (entering-signal-handler-function))))


;;; The function `G2-signal-handler' notifies the user of the signal number, the
;;; post-mortem symbol, and the description string for the signal, all without
;;; consing.

(def-g2-signal-handler g2int-signal-handler ()
  (entering-signal-handler) ; for GSI
  (when error-within-error-p
    (format *terminal-io*
            "~%An error occurred while G2 was reporting a signal.~%")
    (format *terminal-io*
            "Sorry, cannot continue.~%")
    (current-system-case
      (gsi)
      (t (maybe-wait-for-return-key)))
    (exit-lisp-process))
  (let ((signal-code (c-most-recent-signal-code)))
    (c-establish_signal_handler signal-code) ;  necessary only for WIN32
    (cond ((and (arithmetic-signal-p signal-code)
                arithmetic-errors-are-stack-errors-p)
           (signal-floating-point-exception-stack-error))
          (t (setq gensym-error-format-string
                   internal-signal-caught-format-string)
             (setq gensym-error-argument-list
                   information-from-caught-signal)
             (setq gensym-error-sure-of-format-info-p t)
             (setf (first information-from-caught-signal)
                   signal-code)
             (setf (second information-from-caught-signal)
                   (get-signal-description-string signal-code))
             ;; (third information-from-caught-signal) is updated in the
             ;; following form.
             (update-backtrace-text-buffer-for-internal-error)
             (let ((g2-signal-handler?
                    (get-g2-signal-handler signal-code)))
               (cond (g2-signal-handler?
                      (funcall g2-signal-handler?))
                     (top-level-error-catcher-tag
                      (setq top-level-error-seen t)
                      (throw top-level-error-catcher-tag t))
                     (t
                      (format *terminal-io*
                              "~%An error ocurred outside of the top-level-error-catcher:~%")
                      (if error-within-error-p
                          (format *terminal-io*
                                  "~%An error ocurred while reporting another error~%")
                          (minimal-internal-error-given-format-info
                            gensym-error-format-string
                            gensym-error-argument-list
                            gensym-error-sure-of-format-info-p))
                      (shutdown-or-exit))))))))

;; jh per ac, 6/24/91.  Changed g2-signal-handler to throw to the arithmetic
;; catcher if appropriate.  For further details, see avoid-arithmetic-errors,
;; later in this file.



;; jh, 12/11/91.  Currently, the only individual signal for which a function is
;; invoked is broken-pipe.  The function in this case does nothing, mimicing the
;; effect of a SIG_IGN flag at the C level.  All other signals are handled either
;; by g2-signal-handler (if the signal causes a core dump) or ignored (if it
;; doesn't).

;; jh, 10/17/91.  The current theory is that broken-pipe signals are part of
;; normal ICP operation and should be ignored.  Thus we set up a signal handler
;; that does nothing.  This is the equivalent on the Lisp side of calling signal
;; with SIG_IGN on the C side.  To get the 3.0 alpha out, Anne has wired this C
;; side fix into g2_main.c this date, but after the alpha the correct abstraction
;; is probably to keep the handler on the Lisp side.

(def-g2-signal-handler g2int-handle-broken-pipe-signal ()
  nil)






;;;; Errors from the Lisp Implementation

;; jh, 10/2/91.  Modified error-trapping code to improve upon Chestnut's
;; implementation of error (it simply exits).  We want to put up an "internal
;; error" placard, just as we do for caught signals.  To do this, we write to the
;; string buffer gensym-error-message-buffer inside the Chestnut kernel, and then
;; have it call g2-error-handler before exiting.  Since g2-error-handler always
;; throws, this should get the results we want.

;; A translation of the following was inserted into the Chestnut kernel code
;; which reports the error to the console:
;;   (progn
;;     (setf (fill-pointer gensym-error-message-buffer) 0)
;;     (with-output-to-string (error-buffer-stream gensym-error-message-buffer)
;;       ;; code reporting errors to error-buffer-stream (duplicate of the existing
;;       ;; kernel code which reports to *standard-output*)
;;       ))

;; As of 10/2/91, the changes are in fe:/disc/chestnut/runtime/c/work/errors.c.
;; The write to Gensym_error_message_buffer is in error_nargs_aux() and the call
;; to g2_error-handler() is in lexit().  The kernel does check the special
;; variable Break_function and funcall it if non-nil before exiting, but the
;; funcall has no arguments.  Since we need access to the error format string and
;; arguments, writing to Gensym_error_message_buffer is the way to go for now.





(def-preallocated-gensym-string gensym-error-message-buffer 1000)
(declare-gsi-api-symbol gensym-error-message-buffer)

;;; The global variable `internal-error-trapped-format-string' is a string
;;; designed to be passed to internal-error-given-format-info as a control
;;; string tformat when a translated image calls the Lisp functions error or
;;; cerror.

(defvar internal-error-trapped-format-string "~a~%~a")

;;; The system variable `information-from-trapped-error' is a list designed to
;;; be passed to internal-error-given-format-info as arguments to tformat when a
;;; translated image calls the Lisp functions error or cerror.

(def-system-variable information-from-trapped-error OS-ERROR
  (:funcall initialize-information-from-trapped-error))

(defun initialize-information-from-trapped-error ()
  (list gensym-error-message-buffer
        backtrace-text-buffer-for-internal-error))

;; jh, 2/21/92.  Changed inside-top-level-error-catcher-p to be a defvar
;; instead of a system variable on distribution platforms.  This was
;; causing problems when errors occurred during initialization of system
;; variables themselves.  The promimal cause for this fix is that the HP
;; 9000s800 is experiencing as-yet unexplained compilation or
;; translation errors which prevent it from initializing
;; route-locality-info-p, and at that point
;; inside-top-level-error-catcher-p has not yet been initialized.  Since
;; UNBOUND is not nil, it took the wrong branch in g2-error-handler,
;; causing a endless loop of errors within errors.




;; G2-error-handler-given-updated-message-buffer refers to (first
;; information-from-trapped-error), which points to gensym-error-message-buffer.
;; By the time this function is called, gensym-error-message-buffer has been
;; updated.  In Chestnut images, Gensym has modified the runtime library to do
;; the update during the call to error() or cerror().  In Lucid development
;; images, the update happens during the call to handle-lucid-development-error.

(defun g2-error-handler-given-updated-message-buffer ()
  (cond (inside-avoid-arithmetic-errors-p
         (throw (arithmetic-error-catcher) t))
        (top-level-error-catcher-tag
         (setq gensym-error-format-string internal-error-trapped-format-string)
         ;; (first information-from-trapped-error) is updated either in the
         ;; Chestnut runtime library or in handle-lucid-development-error.
         ;; (second information-from-trapped-error) is updated in the following
         ;; form.
         (update-backtrace-text-buffer-for-internal-error)
         (setq gensym-error-argument-list information-from-trapped-error)
         (setq gensym-error-sure-of-format-info-p t)
         (cond (do-error-trapping?
                (setq top-level-error-seen t)
                (throw top-level-error-catcher-tag t)) ; delivery
               (t
                nil)))  ; development

        ;; jh, 1/7/92.  If a Lisp error happens before we have established
        ;; top-level-error-catcher, we simply abort.  This ends up throwing to a
        ;; catcher established in run-system-process, which shuts down G2.
        ;; Note that this can happen either in Telewindows or G2.
        ;;
        ;; jh, 6/30/94.  Actually, the handler in run-system-process just
        ;; re-enters an endless loop instead of shutting down G2.  We need to
        ;; throw farther, to the shutdown tag established in
        ;; run-ab-process-top-level, defined by the define-system-access macro.
        ;; This came up trying to load a non-OK file from the command line into
        ;; G2.  G2 loops endlessly rather than giving up as it should (since a
        ;; partial load of the file might have introduced corruption).

        (t (shutdown-or-exit))))

(defvar shutdown-catch-tag nil)

;;; The function shutdown-or-exit can be used by G2 or TW
;;; to cleanly quit the program.

(defun shutdown-or-exit (&optional status)
  #+SymScale
  (when (and (not legacy-mode-p) scheduler-worker-vector)
    (loop for index from 1 below number-of-all-threads
	  for thread = (svref scheduler-worker-vector index)
	  do
      (when (and (tx:threadp thread)
		 (tx:thread-alive-p thread))
	(tx:kill-thread thread))))
  (cond (shutdown-catch-tag (throw shutdown-catch-tag status))
        (t (g2-unrecoverable-error-exit))))

(defun-simple g2-unrecoverable-error-exit ()
  #+development
  (break "g2-unrecoverable-error-exit called")
  #-development
  (exit-lisp-process)) ; print a message, maybe?



;; jh, 4/10/95.  See the C comments above update_gensym_error_buffer() in
;; rtl/c/rtlcore/errors.c for the purpose and operation of
;; update-message-buffer-for-gsi-if-appropriate.

(defmacro update-message-buffer-for-gsi-if-appropriate ()
  (if (and (eq current-system-being-loaded 'gsi)
           (eval-feature :chestnut-3)
           (eval-feature :chestnut-trans))
      `(c-update_gensym_error_buffer)
      nil))

(def-g2-signal-handler g2int-error-handler ()
  (when error-within-error-p
    (format *terminal-io*
            "~%An error occurred while G2 was reporting an error.~%")
    (format *terminal-io*
            "Sorry, cannot continue.~%")
    (current-system-case
      (gsi)
      (t (maybe-wait-for-return-key)))
    (exit-lisp-process))
  #+(and chestnut-3 chestnut-trans)
  (c-get_backtrace)
  (update-message-buffer-for-gsi-if-appropriate)
  (g2-error-handler-given-updated-message-buffer))




;;;; Lucid development errors

(defmacro body-of-handle-lucid-development-error (condition)
  (with-package-specific-symbols (lcl |::| simple-condition-format-string
                                  lcl |::| simple-condition-format-arguments
                                  lcl |::| simple-condition
                                  user |::| supported-floating-point-conditions)
    `(progn
       (cond
         ((typep condition 'simple-condition)
          (setf (fill-pointer gensym-error-message-buffer) 0)
          (with-output-to-string (buffer-stream gensym-error-message-buffer)
            ;; We dare to rely on Lucid format control strings matching their
            ;; arguments because we are in development.  Nothing like this
            ;; happens in distribution images.
            ;; jh, 11/15/94.  Note that only simple conditions have format
            ;; strings and arguments; indeed, I believe this is what
            ;; differentiates them from other conditions (in Lucid at least).
            (apply (lisp-format)
                   buffer-stream
                   (simple-condition-format-string ,condition)
                   (simple-condition-format-arguments ,condition))))
         ((and arithmetic-errors-are-stack-errors-p
               (loop for floating-point-condition-type
                         in supported-floating-point-conditions
                     thereis (typep condition floating-point-condition-type)))
          (signal-floating-point-exception-stack-error))
         (t (setf (fill-pointer gensym-error-message-buffer) 0)
            (with-output-to-string (buffer-stream gensym-error-message-buffer)
              (format
                buffer-stream
                "Can't handle condition ~s: it is neither ~
                 simple nor a known floating-point condition ~
                 occurring in an evaluation context.  ~
                 This state of affairs would probably cause ~
                 a distribution image to crash!"
                condition))))
       (g2-error-handler-given-updated-message-buffer))))

#+(and lucid development)
(defun handle-lucid-development-error (condition)
  (body-of-handle-lucid-development-error condition))



;;;; Signal and Error Trapping While Running

;;; The term `error trapping' covers the response of G2 both to errors signaled by
;;; the Lisp implementation and to signals (q.v.  above) generated by the
;;; operating system.

;;; `Do-error-trapping' is a macro used around the call to run-scheduler-1 in
;;; CYCLES.  It depends on functions and macros defined in later modules.

;;; Do-error-trapping normally catches the error, prints "G2 internal error.",
;;; pauses if the system is running and prints a message to that effect, prints
;;; "Internal error message was:", and finally prints the text of the message.
;;; The routines should call the function internal-error in order to accomplish
;;; this.  This function is defined in the RUN module.

;;; The values returned by do-error-trapping are not defined.

;;; Do-error-trapping?  is a lisp parameter which directs run-workstations to run
;;; run-workstations-1 inside a do-error-trapping form.  In all implementations,
;;; this is by default bound to T.  This is now (jh, 12/12/91) only useful on Lisp
;;; Machines, to test error handling on distribution machines.

;;; On the Lisp Machine implementations, the user sees the message in the upper
;;; left hand part of the screen and then may hit the Break (or Suspend) key in
;;; order to enter the debugger.



;; jh, 12/13/91.  The possibility remains that on some platforms some core-dumping
;; signals will get by our signal catchers.  Added a foreign function which
;; inhibits core dumps on platforms where it is possible to do this.  Currently,
;; core dumping may be inhibited on all platforms except the HP and Windows.

(def-gensym-c-function c-inhibit_core_dumping
                       (:fixnum-int "g2ext_inhibit_core_dumping")
  ())

(defun do-not-catch-aborts-p ()
  (or (get-command-line-flag-argument "-do-not-catch-aborts")
      (get-command-line-flag-argument "-DO-NOT-CATCH-ABORTS")))



;; jh, 11/7/91.  Added a switch which will make the run-scheduler-1 warn the user
;; (diplomatically) that the G2 image may not be reliable after an internal error.
;; This will give us something to point to when users insist on working with G2
;; afterwards.  The function which does the warning is
;; warn-user-of-previously-aborted-g2, above.

;; jh, 6/1/95.  Made the warning into a realtime task, instead of a function
;; activated by a countdown in run-scheduler-1.

(def-system-variable task-to-warn-user-of-previously-aborted-g2 OS-ERROR nil)

;; bind inside-top-level-error-catcher-p instead of setting it.
;; this has the effect of creating an implicit, simple unwind-protect: when
;; GSI throws out of the initial invocation of gsi-run-loop, the
;; value of inside-top-level-error-catcher-p will properly return to nil.
;;    -ncc, 3/16/94

(defmacro do-error-trapping-1 (&body body)

  ;; Added compile-time switching to eliminate error-handling from Chestnut
  ;; images.  This is a precursor to adding our own signal catchers.  Note that we
  ;; cannot use a #+chestnut-trans read-macro directly for this, since Chestnut
  ;; images are built from within Lucid.  jh per jra & blm, 3/18/91.
  ;; Added signal-handling to Chestnut.  jh, 3/22/91.
  ;; jh, 11/25/91.  We now establish signal handlers inside the catcher which they
  ;; throw to.  This addresses the (hopefully rare) case of such a throw happening
  ;; because a signal occurs while the handlers are being established.
  #+(or chestnut chestnut-3)
  `(let ((error-occurred-p
           (let ((top-level-error-catcher-tag
                   'top-level-error-catcher))
             (setq top-level-error-seen nil)
             (catch top-level-error-catcher-tag
               (register-all-signal-handlers)
               ,@body
               nil))))
     (cond (error-occurred-p
            (internal-error-given-format-info
              gensym-error-format-string
              gensym-error-argument-list
              gensym-error-sure-of-format-info-p)
            (initialize-backtrace-stack)
            (with-future-scheduling
                (task-to-warn-user-of-previously-aborted-g2
                  1
                  (g2-future-interval 30)
                  30.0 nil t)
              (warn-user-of-previously-aborted-g2)))
           (t nil) ;the return value from do-error-trapping is undefined
           ))

  ;; jh, 10/14/93.  Note the similarity of the following Lucid development
  ;; implementation of do-error-trapping to the Chestnut implementation above.
  ;; The Lucid implementation can't be any more similar, however, because Lucid
  ;; establishes its own signal handlers and possibly core-dump protection as
  ;; well.  Hopefully, the duplicated code makes things clearer by separating
  ;; behavior based on the type of G2 image that is getting the error.
  #+(and lucid development)
  (with-package-specific-symbols (lcl |::| handler-bind
                                  lcl |::| condition)
    `(let ((error-occurred-p
             (let ((top-level-error-catcher-tag
                     'top-level-error-catcher))
               (catch top-level-error-catcher-tag
                 (setq top-level-error-seen nil)
                 (handler-bind
                   ((condition 'handle-lucid-development-error))
                   ,@body)
                 nil))))
       (cond (error-occurred-p
              (internal-error-given-format-info
                gensym-error-format-string
                gensym-error-argument-list
                gensym-error-sure-of-format-info-p)
              (initialize-backtrace-stack)
              (with-future-scheduling
                (task-to-warn-user-of-previously-aborted-g2
                  1
                  (g2-future-interval 30)
                  30.0 nil t)
                (warn-user-of-previously-aborted-g2)))
             (t nil) ;the return value from do-error-trapping is undefined
             )))

  #-(or (or chestnut chestnut-3) (and lucid development))
  `(progn . ,body)
  )

(defmacro do-error-trapping (&body body)
  `(if do-error-trapping?
      (do-error-trapping-1
        ,@body)
      (progn
        ,@body)))




;;;; Minimal Error Trapping

;;; Some Gensym products (such as Telewindows) are unable to use G2's graphical
;;; user interface to notify the user of an error or a signal.  For these
;;; products, there is a stripped-down version of do-error-trapping called
;;; do-minimal-eror-trapping which notifies the user on the console and then
;;; exits.

;; jh, 10/18/91.  Moved print-internal-error-data-on-console to OS-ERROR, so
;; Telewindows can make use of it.

;; jh, 1/7/92.  Changed the warning string in print-internal-error-data-on-console
;; to refrain from mentioning either G2 or Telewindows.  The notion of a system
;; needs a complete revamping, and adding another argument to this function would
;; just make things more confusing.

(defun minimal-internal-error-given-format-info
       (raw-format-string list-of-format-args sure-of-format-info-p)
  (declare (ignore sure-of-format-info-p))
  (let ((error-within-error-p t))
    (notify-console-of-internal-error
      raw-format-string
      list-of-format-args)))


(defmacro do-minimal-error-trapping (form-to-execute-if-error &body body)

  ;; jh, 11/25/91.  We now establish signal handlers inside the catcher to which
  ;; they will throw.  This addresses the (hopefully rare) case of such a throw
  ;; happening because a signal occurs while the handlers are being established.
  #+(or chestnut chestnut-3)
  `(let ((error-occurred-p
           (let ((top-level-error-catcher-tag
                   'top-level-error-catcher))
             (catch top-level-error-catcher-tag
               (setq top-level-error-seen nil)
               (register-all-signal-handlers)
               ,@body
               nil))))
     (when error-occurred-p
       (minimal-internal-error-given-format-info
         gensym-error-format-string
         gensym-error-argument-list
         gensym-error-sure-of-format-info-p)
       ,form-to-execute-if-error))

  #+(and lucid development)
  (with-package-specific-symbols (lcl |::| handler-bind
                                  lcl |::| condition)
    `(let ((error-occurred-p
             (let ((top-level-error-catcher-tag
                     'top-level-error-catcher))
               (catch top-level-error-catcher-tag
                 (setq top-level-error-seen nil)
                 (handler-bind
                   ((condition 'handle-lucid-development-error))
                   ,@body)
                 nil))))
       (when error-occurred-p
         (minimal-internal-error-given-format-info
           gensym-error-format-string
           gensym-error-argument-list
           gensym-error-sure-of-format-info-p)
         ,form-to-execute-if-error)))

  #-(or (or chestnut chestnut-3) (and lucid development))
  (declare (ignore form-to-execute-if-error))
  #-(or (or chestnut chestnut-3) (and lucid development))
  `(progn ,@body)
  )

;; jh, 11/20/91.  Added an argument to do-minimal-error-trapping which will
;; provide a form to execute if an error is detected.  This macro is currently
;; only used in run-telewindows, and the right thing to do there is call
;; abort-telewindows-top-level.  Previously, upon sustaining an error, we would
;; print an error message on the console, resume at the instruction that was being
;; executed when we caught the signal, and get another error almost instantly
;; since we were proceeding when we should have aborted.





;;;; Error Trapping During Launch

;;; The signal handlers in effect during launch are simpler because the
;;; post-mortem mechanism isn't set up yet, nor can we trap errors within errors
;;; (since system variables are not set up either).

;; These will be used in with-standard-error-restart-loop, part of the
;; with-primitive-bindings macro defined in PRIMITIVES.  Since no uses of this
;; macro occur until later (i.e., PLATFORMS), dependencies should not be a
;; problem.

(defmacro with-standard-error-restart-loop (&body body)
  `(progn
    ,@(when (eval-feature :translator)
            `((unless (eq current-system-name 'gsi)
                (register-all-signal-handlers-for-launch))))
    ,@body))


;; jh, 4/3/91.  Added signal handlers for launch time in Chestnut images.

(def-gensym-c-function c-establish_signal_handler_for_launch
                       (:fixnum-int "g2ext_establish_launch_sig_handler")
  ((:fixnum-int error-code)))

(defun register-all-signal-handlers-for-launch ()
  (cond ((do-not-catch-aborts-p))
        (t
         (loop for (code-number nil nil causes-core-dump-p) in signal-code-registry
               when causes-core-dump-p
                 do (c-establish_signal_handler_for_launch code-number)))))




;;; `G2-signal-handler-for-launch' can only notify the user of the signal number
;;; and offer to enter a read-eval-print loop.  The post-mortem mechanism is not
;;; yet set up inside the image yet.

(def-g2-signal-handler g2int-signal-handler-for-launch ()
  (entering-signal-handler)
  (let ((signal-code (c-most-recent-signal-code)))
    (c-establish_signal_handler_for_launch signal-code)
    (format *terminal-io*
            "~&Signal ~a caught during launch.~%~
             Sorry, must exit.~%"
            signal-code)
    (current-system-case
      (gsi)
      (t (maybe-wait-for-return-key)))
    (exit-lisp-process)))

;; End file with CR
