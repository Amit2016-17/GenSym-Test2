package com.gensym.g2export;

import java.beans.PropertyChangeSupport;
import java.beans.PropertyChangeListener;
import javax.naming.NameAlreadyBoundException;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Field;
import java.lang.ClassLoader;
import com.gensym.fida.ObjectContainer;
import com.gensym.fida.ObjectProxy;
import com.gensym.fida.message.Message;
import com.gensym.fida.MobilityEvent;
import java.util.Enumeration;
import java.util.Hashtable;
import com.gensym.util.Sequence;
import com.gensym.util.Symbol;
import com.gensym.util.Structure;
import com.gensym.fida.RemoteObjectAccessException;
import com.gensym.fida.support.message.CallIndexedMethodMessage;
import com.gensym.fida.support.message.IndexedMethodCallHandler;
import com.gensym.fida.support.RemoteStubProvider;
import com.gensym.fida.message.MessageNotHandledException;
import com.gensym.fida.message.MessageException;
import com.gensym.fida.message.CallReflectiveMethodMessage;

public class G2__BaseImpl implements G2__Base,  
  java.io.Serializable, 
  IndexedMethodCallHandler,
  RemoteStubProvider {

  static final long serialVersionUID = -645850668589677256L;

  protected boolean allowDynamicClassChanges = true;
  protected transient PropertyChangeSupport changeSupport;
  protected transient ObjectContainer container;
  protected ObjectProxy remoteProxy;

  public G2__BaseImpl() {
    RuntimeItemManager runtime = RuntimeItemManager.getRuntimeItemManager();
    runtime.registerItem(this);
    // force interface to be loaded
    Class clazz = this.getImplementedInterface();
  }

  public G2__BaseImpl(ObjectContainer container) {
    this();
    this.container = container;
  }

  protected final G2__Base _getCurrentSelf() {
    if (false) { //(allowDynamicClassChanges) {
      RuntimeItemManager runtime = RuntimeItemManager.getRuntimeItemManager();
      return runtime.getCurrentItem(this);
    } else
      return this;
  }

  public final ObjectProxy _getObjectProxy() {
    return remoteProxy;
  }

  // Implement Implementor

  /**
   * Returns the Main Interface class name that this object implements.
   * @return the non-null Interface Class.
   */
  public Class getImplementedInterface()
  {
    // This method will be autogenerated for user classes.
    return G2__Base.class;   
  }

  /**
   * Informs the Implementor that there is a new Implementation of its specified Interface
   * available, the Implementor may then clone itself using the new Implementation Class.
   * Of course, the Implementor may refuse to move to the new Implementation.
   * @param newImplementation The version of the Implementor's Interface Implementation.
   * @return The Implementor cloned using the new Class, or null, if the Implementor did not migrate.
   */
  public java.lang.Object newImplementation(Class newImplementation) 
  {
    if (disableUpdates) return this;
    if (!(newImplementation == this.getClass()) && !newImplementation.isInterface())
      RuntimeItemManager.getRuntimeItemManager().implementationChanged(getImplementedInterface(), newImplementation);
    return _getCurrentSelf();
  }

  private boolean disableUpdates = false;

  /**
   * Informs the Implementor to disable any updates to new Implementations.
   */
  public void disableImplementationUpdates()
  {
    disableUpdates = true;
  }

  // Implement MessageHandler
  
  /**
   * Receive a message and process it.
   * @return True if the message was successfully processed.
   */
  public boolean handleMessage(Message message)
  {
    return false;
  }

  // Implement DistributedObject

  // Allowed to be overridden
  public void onCreation(java.lang.Object init)
  {
  }

  // Should not be overridden by generated classes
  public void onRegistration(ObjectContainer container)
  {
    this.container = container; 
    //com.gensym.g2export.denali.DenaliServiceImpl.getDenaliService(container.getApplicationEnvironment()).registerItem(this);
    onObjectRegistration(container);
  }

  // not allowed to be overridden
  public final void onDeregistration()
  {
    onObjectDeregistration();
    this.container = null;
  }

  // This should not be overriden, can not make final, as there
  // are some special impls that specfically direct a generated method to this one.
  public ObjectContainer getObjectContainer()
  {
    return container;
  }

  public void setObjectContainer(ObjectContainer container)
  {
    if (this.container != null)
      throw new RuntimeException("This object has already been associated with a Container");
    this.container = container;
  }

  // Support Puesdo DistributedObject exported from G2 G2RT-DISTRIBUTED-OBJECT
  // These will be optionally overridden

  public void onObjectRegistration(ObjectContainer container)
  {
  }

  public void onObjectDeregistration()
  {
  }

  // Implement MobilityListener
  public void dispatching(MobilityEvent event)
  {
  }


  public void arrived(MobilityEvent event)
  {
  }

  /**
   * This method will add a PropertyChangeListener to the PropertyChangeListener
   * list.
   * The PropertyChangeListener will be notifed when an Attribute Changes in
   * the wrapped G2 item.
   *@param pl The PropertyChangeListener to add to the PropertyChangeListener list
   */
  public final void addPropertyChangeListener (PropertyChangeListener pl) {
    if (changeSupport == null)
      changeSupport = new PropertyChangeSupport (this);
    changeSupport.addPropertyChangeListener (pl);
  }


  /**
   * This method removes a PropertyChangeListener from the
   * PropertyChangeListener List.
   *@param pl The PropertyChangeListener to remove from the
   * PropertyChangeListener list
   */
  public final void removePropertyChangeListener (PropertyChangeListener pl) {
    if (changeSupport == null)
      return;
    changeSupport.removePropertyChangeListener (pl);
  }

 /**
  *This method fires a property change event to all of the object registered
  * to the property change event of this item.
  *
  *@param propertyName a string representing the property that has changed.
  *@param oldValue the old value of the changed property.
  *@param newValue the new value of the changed property.
  */
  protected final void firePropertyChange(String propertyName,
                                    java.lang.Object oldValue,
                                    java.lang.Object newValue) {
    if (changeSupport == null)
      return;
    changeSupport.firePropertyChange(propertyName, oldValue, newValue);
    // Should sent event to any remote stubs so they can fire there local listener lists
    // TBD
  }

  @Override
  public Symbol getG2ClassName()
  {
    Class itsInterface = getImplementedInterface();
    try {
      Field g2ClassNameField = itsInterface.getField("g2ClassName");
      return (Symbol)g2ClassNameField.get(this);
    } catch (Exception e) {
      throw new RuntimeException(e.toString());
    }
  }

  /**
   * Return a Method given a set of String class names and the Class.
   */
  private static Method _getMethodForClass(Class targetClass, String methodName, String[] paramTypeNames)
       throws ClassNotFoundException, NoSuchMethodException
  {
    int numParams = (paramTypeNames != null ? paramTypeNames.length : 0);
    Class[] paramTypes = new Class[numParams];
    ClassLoader loader = targetClass.getClassLoader();
    for (int i = 0; i<numParams; i++)
      {
	String typeName = paramTypeNames[i];
	if (typeName.equals("int"))
	  paramTypes[i] = Integer.TYPE;
	else if (typeName.equals("double"))
	  paramTypes[i] = Double.TYPE;
	else if (typeName.equals("boolean"))
	  paramTypes[i] = Boolean.TYPE;
	else if (loader == null)
	  paramTypes[i] = Class.forName(paramTypeNames[i]);
	else
	  paramTypes[i] = loader.loadClass(paramTypeNames[i]);
      }
    Method method = targetClass.getMethod(methodName, paramTypes);
    return method;
  }

  public java.lang.Object getRemoteStub()
       throws RemoteObjectAccessException
  {
    try {
      Class clazz = this.getClass();
      if (container != null) { // ensure that local method registration has happened
	if (classMethodSignaturesHash.get(clazz.getName()) == null)
	  this.registerClassMethods();
      }
      if (this.remoteProxy != null)
	return this; //already a stub
      if (this.container == null)
	throw new RemoteObjectAccessException("This object is not registered in a FIDARuntime");
      G2__BaseImpl newObj = (G2__BaseImpl)clazz.newInstance();
      newObj.remoteProxy = container.getObjectProxy();
      return newObj;
    } catch (InstantiationException e) {
      throw new RemoteObjectAccessException(e, e.toString());
    } catch (IllegalAccessException e) {
      throw new RemoteObjectAccessException(e, e.toString());
    }
  }

  public void registerClassMethods()
  {
    // Sub Classes should call super.registerClassMethods then registerClassMethodSignatures
  }

  /**
   * Register the method signatures for a Class.
   * @param methodNames , array of the method names
   * @param signatures , ObjectArray each element containing String[] containing signature for method
   */
  public void registerClassMethodSignatures(String targetClassName, 
					    String[] methodNames, 
					    java.lang.Object[] signatures) 
       throws ClassNotFoundException, NoSuchMethodException
  {
    System.out.println("G2__BaseImpl::registerClassMethodSignatures " + targetClassName);
    ClassLoader classloader = getClass().getClassLoader();
    targetClassName = targetClassName.replace('/','.');
    Class targetClass = null; 
    if (classloader != null)
      targetClass = classloader.loadClass(targetClassName);
    else
      targetClass = Class.forName(targetClassName);
    Method[] methods = new Method[methodNames.length];
    for (int i=0; i<methodNames.length; i++) {
      methods[i] = _getMethodForClass(targetClass, methodNames[i], (String[])signatures[i]);
    }
    classMethodSignaturesHash.put(targetClass.getName(), methods);
  }

  private static Hashtable classMethodSignaturesHash = new Hashtable();
  
  // Implement IndexedMethodCallHandler

  public final java.lang.Object invokeMethodByIndex(String targetClass,
						    int index, 
						    java.lang.Object[] parameters)
       throws ClassNotFoundException, 
	 NoSuchMethodException,
	 IllegalAccessException,
	 InvocationTargetException
  {
    System.out.println("G2__BaseImpl::invokeMethodByIndex(" + targetClass + "," + 
		       index + "," + parameters.length);
    Method[] methods = (Method[])classMethodSignaturesHash.get(targetClass);
    if (methods == null)
      throw new ClassNotFoundException("Could not find " + targetClass);
    Method method = methods[index];
    if (method == null)
      throw new NoSuchMethodException("No method found for index " + index + " on " + targetClass);
    return method.invoke(this, parameters);
  }

  protected final java.lang.Object invokeMyRemoteMethod(String classKey,
							int index,
							java.lang.Object[] parameters)
       throws MessageNotHandledException,
	      RemoteObjectAccessException,
	      MessageException
  {
       return remoteProxy.sendMessage(new CallIndexedMethodMessage(classKey,
								   index,
								   parameters));
  }



  protected final java.lang.Object invokeMyRemoteMethod(String methodName,
							java.lang.Object[] parameters,
							String[] paramTypes)
  {
    try {
      //remoteProxy.sendOnewayMessage(new CallReflectiveMethodMessage(methodName,
      //							     parameters,
      //							     paramTypes));
      //return null;

      return remoteProxy.sendMessage(new CallReflectiveMethodMessage(methodName,
      							     parameters,
      							     paramTypes));
    } catch (Exception e) {
      // Really dont know what to do with exceptions yet !  (Note this method called
      // by SpecialImpls)
      e.printStackTrace();
      throw new RuntimeException(e.toString());
    }
  }

  protected static G2ObjectConverter g2ObjectConverter = null;

  public static void setG2ObjectConverter(G2ObjectConverter g2ObjectConverter)
  {
    G2__BaseImpl.g2ObjectConverter = g2ObjectConverter;
  }

  public void updateLocalAttributesFromG2(Structure atts)
  {
    _updateLocalAttributesFromG2(atts);
  }

  // Overridden by generated classes
  protected void _updateLocalAttributesFromG2(Structure atts)
  {
  }

  protected java.lang.Object _convertG2AttributeForLocal(Structure atts, Symbol attName)
  {
    java.lang.Object val = atts.getAttributeValue(attName, null);
    if (val != null) {
      if (g2ObjectConverter != null)
	return g2ObjectConverter.toLocalAttribute(val);
      else
	return val;
    }
    return null;
  }

  public Structure updateG2AttributesFromLocal()
  {
    Structure atts = new Structure();
    _updateG2AttributesFromLocal(atts);
    return atts;
  }

  // Overridden by generated classes
  protected void _updateG2AttributesFromLocal(Structure atts)
  {
  }

  protected void _convertLocalAttributeForG2(Structure atts, 
					  Symbol attName, 
					  java.lang.Object val)
  {
    if (g2ObjectConverter != null)
      val = g2ObjectConverter.toG2Attribute(val);
    if (val != null)
      atts.setAttributeValue(attName, val);
  }

}









