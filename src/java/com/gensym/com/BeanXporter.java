/*
 *   Copyright (C) 1986-2017 Gensym Corporation. All Rights Reserved.
 *
 *          com.gensym.com.BeanXporter.java
 *
 *  Author: Allan Scott
 */
package com.gensym.com;

import com.gensym.core.GensymApplication;

import com.gensym.wizard.*;

import com.gensym.dlg.WarningDialog;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

import java.awt.*;
import java.awt.event.ActionListener;
import java.awt.event.ActionEvent;


import java.io.File;

import java.util.StringTokenizer;

/**
* <p> Class <code>BeanXporter</code> provides the public interface to exporting 
* ActiveX components as Java beans.  An instance of a <code>BeanXporter</code> can
* be used to export the contents of a particular ActiveX type library as java
* source, to compile the source, and to create a .jar file containing the compiled
* classes. The three ways to use BeanXporter are as follows:
* <ul>
* <li> As a command-line program, using the <code>main</code>() method;
* <li> Programmatically launching the BeanXporter wizard using the zero-argument
* <code>export</code>() method;
* <li> Programmatically exporting a given type library or the type library for a
* given ProgID using the <code>export</code> and <code>exportFromProgid</code>
* methods.
* </ul>
* 
* <h4>Using BeanXporter as a Command-line program</h4>
* To get documentation on the command-line options to BeanXporter use:<br>
* java com.gensym.com.BeanXporter -help
* 
* <h4>Launching the BeanXporter wizard</h4>
* <code>BeanXporter</code> uses the <code>com.gensym.wizard</code> package to provide
* a wizard either in a top-level frame or in a dialog. <br>
* To launch BeanXporter as a top-level frame:
* <code><pre>
* BeanXporter bx = new BeanXporter();
* bx.wizard();
* </pre></code>
* To launch BeanXporter as a dialog that was launched from another Frame:
* <code><pre>
* BeanXporter bx = new BeanXporter();
* bx.wizard(parentFrame);
* </pre> 
* </code>
* 
* <h4>Programmatic export</h4>
* It is also possible to provide arguments to the <code>export()</code> method that
* cause BeanXporter to export an ActiveXType library without providing a wizard
* interface.  For example:
* <code><pre>
* BeanXporter bx = new BeanXporter();
* bx.exportFromProgid("Shell.Explorer","com.acme.beans", "C:\temp", "C:\temp\inet.jar", false);
* </pre></code> 
*
* <h4>BeanXporterListener</h4>
* In order for an object to get notifcation that a BeanXporter instance has completed exporting (
* or failed to complete exporting) the object must implement the <code>BeanXporterListener</code> 
* interface and be added as a listener to a BeanXporter listener. For example:
* <code><pre>
* class MyListener implements BeanXporterListener 
* { 
*   public void exportSuccess(BeanXporterEvent e) 
*   {
*     String jar = (String) e.arg;
*     System.out.println("Export succeeded, jar = " + jar);
*    }
*   public void exportFailure(BeanXporterEvent e)
*   {
*     System.out.println("Export failed");
*    }
* }
*
* public void listenToExport()
* {  
*  MyListener listener = new MyListener();
*  BeanXporter bx = new BeanXporter();
*  bx.addBeanXporterListener(listener);
*  bx.export(); // launches wizard
* }
* </pre></code>
* Note - that the arg field of the <code>BeanXporterEvent</code>
* that is generated by a successful export will contain the string
* of the jarfile that was created.
*<p>
* @see BeanXporterListener
* @see BeanXporterEvent
* @see #main(java.lang.String[])
* @see #export()
* @see #export(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)
* @see #exportFromProgid(java.lang.String, java.lang.String, java.lang.String, java.lang.String, boolean)
*/

public class BeanXporter implements ActiveXTraceLevels
{
  private RegistryInfo registryInfo;
  private Frame parent;
  private ProgressPanel progress;
  private Vector filePathsForJar = null;
  private Vector areBeansForJar = null;
  private Hashtable listeners = new Hashtable();
  private Hashtable bxListeners = new Hashtable();

  public BeanXporter() 
  {
    registryInfo = new RegistryInfo(this);  
  }

  /** Run BeanXporter without any user interface to export a
  * given ActiveX library
  */
  public synchronized void export(String libraryPath,
                                  String emitPackage,
                                  String emitDir,
                                  String jarFile,
                                  boolean noexceptions)
  {
    if( ! checkLibraryPath(libraryPath))
        return;
          
    if (emitPackage == null || emitPackage.equals(""))
      emitPackage = FileBroker.getDefaultEmitPackage();
    
    if (! checkEmitPackage(emitPackage))
      return;

    if (emitDir == null || emitPackage.equals(""))
      emitDir = FileBroker.generateTemporaryFilePath();
    
    if (! checkEmitDir(emitDir))
      return;
      
    if ((jarFile == null) || (jarFile.equals(""))) {
      jarFile = FileBroker.generateTemporaryFilePath() +
        File.separator + 
        "out.jar";
    }

    if (! checkJarFile(jarFile))
      return;

    exportInternal(null,
      new String[] { libraryPath }, 
      new String[] { null },
      emitPackage, emitDir, jarFile, 
      ToolBroker.useJavac(),
      noexceptions);
  }


  /** Run BeanXporter without any user interface to export an
  * ActiveX library containing a given ProgId.  A ProgId is the
  * name used in the registry to denote a class, for example
  * "Excel.Sheet" is a Progid. 
  */
  public synchronized void exportFromProgid(String progid,
                                  String emitPackage,
                                  String emitDir,
                                  String jarFile,
                                  boolean noexceptions)
  {      
    if (emitPackage == null || emitPackage.equals(""))
      emitPackage = FileBroker.getDefaultEmitPackage();
    
    if (! checkEmitPackage(emitPackage))
      return;
    
    if (emitDir == null || emitPackage.equals(""))
      emitDir = FileBroker.generateTemporaryFilePath();
    
    if (! checkEmitDir(emitDir))
      return;
    
    if ((jarFile == null) || (jarFile.equals(""))) {
      jarFile = FileBroker.generateTemporaryFilePath() +
        File.separator + 
        "out.jar";
    }
    
    if (! checkJarFile(jarFile))
      return;
    
    exportInternal(new String[] {progid},
      null, null,
      emitPackage, emitDir, jarFile, 
      ToolBroker.useJavac(),
      noexceptions);
  } 

  /** Launch the BeanXPorter Wizard as a non-modal dialog.
  */
  public synchronized void export(Frame parent)
  {
    this.parent = parent;
    export();
  }

  /** Launch the BeanXporter Wizard as a top level Frame.
  */
  public synchronized void export() 
  {
    registryInfo.resetActiveXInfo();
    collectInfo(false);
    registryInfo.bubbleSortControlsListIntoArray();

    WizardPanel[] panels = new WizardPanel[5];
    panels[0] = new Step1Panel("Select libraries to export",
                               registryInfo.arrayOfNames);
    panels[1] = new Step2Panel("Select root package name for exported classes");
    panels[2] = new Step3Panel("Select output directory for source and .class files");
    panels[3] = new Step4Panel("Select a .jar file for exported classes");
    panels[4] = new Step5Panel("Select Options");

    progress = new ProgressPanel("Exporting...");
    addBeanXporterListener(progress);
    Wizard wiz = new Wizard(new TitlePanel(), 
                            new ImageCanvas(),
                            panels,
                            progress);

    wiz.addWizardListener(new BeanXporterWizardListener());
    (new BeanXporterWizardPeer()).addWizardPeerListener(wiz);

    if (parent == null) { 
      WizardFrame wizFrame = new WizardFrame("Gensym BeanXporter", wiz);
      parent = wizFrame;
      ((Step4Panel) panels[3]).setParent(wizFrame);
      
      wizFrame.addWindowListener(wizFrame);
      wizFrame.show();
    }
    else {
      ((Step4Panel) panels[3]).setParent(parent);
      WizardDialog wizDialog = new WizardDialog(parent,"Gensym BeanXporter", wiz, false);
      wizDialog.setVisible(true);
    }
  }

  // ************************** Registry Information ***************

  class RegistryInfo implements ActiveXTraceLevels
  {
    ActiveXToJavaInfoList listOfActiveXControls = null;
    ActiveXToJavaInfoList tailOfActiveXControls = null;
    Hashtable cachedControls = null;
    BeanXporter parent;

    ActiveXToJavaInfo[] arrayOfActiveXControls;
    String [] arrayOfNames;

    
    int countOfActiveXControls = 0;
    
    public RegistryInfo (BeanXporter beanXporter) {
      parent = beanXporter;
    }

    public boolean isUninitialized () {
      return (countOfActiveXControls == 0);
    }
        
    public int getCountOfElements () {
      return countOfActiveXControls;
    }
    
    public String getNameOfElementAtPosition (int position) {
      if (position < countOfActiveXControls) {
        return arrayOfActiveXControls[position].className;
      } else {
        return "";
      }
    }
    
    public String getClassNameAtPosition (int position) {
      if (position < countOfActiveXControls) {
        return arrayOfActiveXControls[position].className;
      } else {
        return "";
      }
    }
    
    
    public String getClassIDAtPosition (int position) {
      if (position < countOfActiveXControls) {
        return arrayOfActiveXControls[position].classID;
      } else {
        return "";
      }
    }
    
    public String getlibPathAtPosition (int position) {
      if (position < countOfActiveXControls) {
        return arrayOfActiveXControls[position].libraryPath;
      } else {
        return "";
      }
    }
   

    void bubbleSortControlsListIntoArray () {
      ActiveXToJavaInfoList outer, inner, subhead;
      int i = 0;
      String current, temp;
      
      arrayOfActiveXControls = new ActiveXToJavaInfo[countOfActiveXControls];
      arrayOfNames = new String[countOfActiveXControls];
      for (outer = listOfActiveXControls;
      outer != null;
      outer = outer.next) {
        for (subhead = outer,
          current = subhead.info.className,
          inner = subhead.next;
        inner != null;
        inner = inner.next) {
          if (compareToIgnoreCase(current,inner.info.className) > 0) {
            temp = inner.info.className;
            inner.info.className = current;
            subhead.info.className = temp;
            current = temp;
            
            temp = inner.info.classID;
            inner.info.classID = subhead.info.classID;
            subhead.info.classID = temp;
            
            temp = inner.info.libraryPath;
            inner.info.libraryPath = subhead.info.libraryPath;
            subhead.info.libraryPath = temp;
          }
        }
        arrayOfNames[i] = outer.info.className;
        arrayOfActiveXControls[i++] = outer.info;
      }
    }
    
    private int compareToIgnoreCase(String str1, String str2) {
      int l1 = str1.length();
      int l2 = str2.length();
      int min = Math.min(l1, l2);
      char a1[] = str1.toCharArray(); 
      char a2[] = str2.toCharArray();
      int k = 0;
      int l = 0;
      
      while (min-- != 0) {
        char c1 = Character.toLowerCase(a1[k++]);
        char c2 = Character.toLowerCase(a2[l++]);
        if (c1 != c2) {
          return c1 - c2;
        }
      }
      return l1 - l2;
    }
    
    
    private boolean addToCachedControls
      (String className, String classID, String libraryPath) {
      if (classID == null) {  
        if (cachedControls == null)
          cachedControls = new Hashtable();    
        if (cachedControls.containsKey(className))
          return false;
        else {
          cachedControls.put(className, libraryPath);
          return true;
        }
      }
      else return true;
    }
    
    public void addActiveXInfo
      (String className, String classID, String libraryPath) {
      
      if (listOfActiveXControls == null) {
        
      listOfActiveXControls = new ActiveXToJavaInfoList(className,
        classID, libraryPath);
      tailOfActiveXControls = listOfActiveXControls;
      countOfActiveXControls = 1;
      addToCachedControls(className, classID, libraryPath);
      } else {
        if (addToCachedControls(className, classID, libraryPath)) {
          tailOfActiveXControls.next = new ActiveXToJavaInfoList(className,
            classID, libraryPath);
          tailOfActiveXControls = tailOfActiveXControls.next;
          ++countOfActiveXControls;
        }
      }
    }	
    
    public void resetActiveXInfo () {
      cachedControls = null;
      listOfActiveXControls = null;
      tailOfActiveXControls = null;
      countOfActiveXControls = 0;
      filePathsForJar = null;
      areBeansForJar = null;
    } 
   
    class ActiveXToJavaInfo 
    {
      String className;
      String classID;
      String libraryPath;
      
      ActiveXToJavaInfo(String className, String classID, String libraryPath) {
        this.className = className;
        this.classID = classID;
        this.libraryPath = libraryPath;
      }
    } 
    
    
    class ActiveXToJavaInfoList
    { 
      ActiveXToJavaInfo info;
      ActiveXToJavaInfoList next;
      
      ActiveXToJavaInfoList(String className, String classID, String libraryPath) {
        info = new ActiveXToJavaInfo(className, classID, libraryPath);
        next = null;
      }
    }
  }

  //************************* Checking Arguments ************************

  private boolean checkLibraryPath(String libraryPath)
  {
    if (libraryPath.equals("")) {
        warning("A library path is required");
        return false;
    }

    File lib =  new File(libraryPath);

    if (! (lib.exists())) {
        warning("Library does not exist: " + libraryPath );
        return false;
    }
    return true;
  }

  private boolean checkEmitPackage(String packageName)
  {
    String lowerCase = packageName.toLowerCase();

    if (packageName.equals("")) {
        warning("Please provide a package name");
        return false;
    }

    if (! lowerCase.equals(packageName)) {
        warning("Please use lowercase package name");
        return false;
    }

    return true;
  }

  private boolean checkEmitDir(String emitPath) 
  {
    File dir = new File(emitPath);

    if (! (dir.exists() && dir.isDirectory())) {
      warning("Please specify a valid directory path");
      return false;
    }

    if (! (dir.canWrite())) {
      warning("Please specify a writable directory path");
      return false;
    }
    return true;
  }

  private boolean checkJarFile(String jarFile) 
  {
    File jar = new File(jarFile);

    if (jar.exists()) {
      if (jar.isDirectory() || (! jar.canWrite())) {
        warning("Please specify a writable file");
        return false; 
      }
      return true;
    }

    StringTokenizer tokenizer = new StringTokenizer(jarFile,File.separator);
    StringBuffer buf = new StringBuffer();
    
    while(true)
    {
      String token = tokenizer.nextToken();
      if (tokenizer.hasMoreTokens()) {
        buf.append(token);
      }
      else break;
      buf.append(File.separator);  
    }
    File jarDir = new File(buf.toString());
    
    if (! (jarDir.exists() && jarDir.canWrite())) 
    {
      warning("Please specify a file in a writable directory");
      return false;
    }

    return true;
  }


  //************************** The Actual Exporting *********************

  private void exportInternal(int[] selections,
                              String emitPackage,
                              String emitDir,
                              String jarFile,
                              boolean useJavac,
                              boolean noexceptions)
  { 
    int length = selections.length;

    String[] libIds = new String[selections.length];
    String[] clsIds = new String[selections.length];

    for (int i = 0; i < length; i++)
    {
        libIds[i] = registryInfo.getlibPathAtPosition(selections[i]);    
        clsIds[i] = registryInfo.getClassIDAtPosition(selections[i]);     
    }
    exportInternal(null, libIds, clsIds, emitPackage, emitDir, jarFile, 
                   useJavac, noexceptions);
  }

  private void exportInternal(String[] progIds,
                              String[] libIds,
                              String[] clsIds,
                              String emitPackage,
                              String emitDir,
                              String jarFile,
                              boolean useJavac,
                              boolean noexceptions)
  {
    logStatus("Package = "  + emitPackage);
    logStatus("Directory = "  + emitDir);
    logStatus("JarFile  = "  + jarFile);
    logStatus("Exceptions  = "  + (noexceptions ? false : true));

    // Until the non-javac compile covers all the files emitted 
    // by typeinfo.c.  This is particularly important in JDK1.2
    // where sun.tools.javac.Main is not in classes.zip but in a
    // separate jar - tools.jar.
    if (! useJavac)
    {
      logStatus("Could not locate javac compiler. Check CLASSPATH.");
      warning("Could not locate javac compiler. Check CLASSPATH");
      fireBeanXporterEvent(false, null);
      return;
    }
 
    String relativeEmitPath = 
      FileBroker.convertPackageNameToRelativePath(emitPackage, true);
    
    String fullEmitPath = (new File(emitDir)).toString() +
                          File.separator + 
                          relativeEmitPath;       
    
    File fullEmitDir = new File(fullEmitPath);

    int flags = 0;
    if (useJavac)
        flags |= NativeMethodBroker.USE_JAVAC;

    if(!noexceptions)
        flags |= NativeMethodBroker.EMIT_EXCEPTIONS;

    if (ToolBroker.useVersions())
        flags |= NativeMethodBroker.USE_VERSIONS;

    conversionThread 
      = new ConversionThread(progIds,
                             libIds,
                             clsIds,
                             jarFile,
                             relativeEmitPath,
                             fullEmitPath,
                             emitPackage,
                             emitDir,
                             fullEmitDir,
                             flags,
                             this);
    conversionThread.start();
  }

  private static native boolean set_current_dir(String path);
  private static native boolean reset_current_dir();

  class ConversionThread extends Thread 
  { 
    String [] progIds;
    String [] libIds;
    String [] clsIds;
    String jar, fullEmitPath, emitPackage, tempDir, relativeEmitPath;
    File fullEmitDir;
    BeanXporter parent;
    int flags;

    ConversionThread (
      String[] progIds,
      String[] libIds,
      String[] clsIds,
      String jar,
      String relativeEmitPath,
      String fullEmitPath,
      String emitPackage, 
      String tempDir,
      File fullEmitDir,
      int flags,
      BeanXporter parent)
    {
      this.progIds = progIds;
      this.libIds = libIds;
      this.clsIds = clsIds;
      this.jar = jar;
      this.relativeEmitPath = relativeEmitPath;
      this.fullEmitPath = fullEmitPath;
      this.emitPackage = emitPackage;
      this.tempDir = tempDir;
      this.fullEmitDir = fullEmitDir;
      this.flags = flags;
      this.parent = parent;
    }

    @Override
    public void run() {
      Vector successfulCompile =  new Vector();
      Vector successfulCompileAreBeans =  new Vector();

      fullEmitDir.mkdirs();

      if (! (fullEmitDir.exists() && fullEmitDir.canWrite())) {
        logStatus("Cannot write to output directory:" + fullEmitDir);
        warning("Cannot write to output directory \n" +
                fullEmitDir);
        parent.fireBeanXporterEvent(false, null);
        // last emitted jar stuff here    
        return;
      }

      logStatus("Collecting type information...");

      int length;
      if (progIds != null)  
      {
        length = progIds.length;
        boolean success;

        for (int i = 0; i < length; i++)
        {
          logStatus("Collecting type library for " + progIds[i]);
          success =
            NativeMethodBroker.beanifyFromProgid(progIds[i],
                emitPackage, fullEmitPath, flags);
          if (! success)
          {
            logStatus("Invalid ProgID: " + progIds[i]);
            parent.fireBeanXporterEvent(false, null);
          }
        }
      }
      else {
         length = libIds.length;
      
         File libFile;
         String absolute;
         for (int i = 0; i < length; i++) {
           logStatus("Collecting " + libIds[i]);
           libFile = new File(libIds[i]);
           absolute = libFile.getAbsolutePath();
           NativeMethodBroker.beanifyClass(clsIds[i], absolute,
             emitPackage, fullEmitPath,
             flags);
         }
      }
      logStatus("Finished collecting type information");
      
      NativeMethodBroker.collectEmittedFilesInfo(parent);
      
      int numberOfFiles; 
      if((filePathsForJar == null) || 
        ((numberOfFiles = filePathsForJar.size())
          == 0)) {
          logStatus("Nothing to add to jar");
          warning("Nothing to add to jar");
          fireBeanXporterEvent(false, null);
          return;
      }      

      boolean success =  false;
      // Now compile
      
      logStatus("Compiling");
      for (int i = 0; i < numberOfFiles; i++) {
        String javaFilePath = (String) filePathsForJar.elementAt(i); 
        String filePath = stripToRelativePath(javaFilePath);
        String filePathDotJava = 
          fullEmitPath + filePath + ".java";
                
        logStatus("Compiling file: " + filePathDotJava);
        success = ToolBroker.compileJavaSourceFile(filePathDotJava,tempDir);
        
        if (success) {
          logStatus("Compile successful for file: " + filePathDotJava);
          successfulCompile.addElement(relativeEmitPath + filePath + ".class");
          successfulCompileAreBeans.addElement(areBeansForJar.elementAt(i));        
        }
        else {
          logStatus("Compile failure : " + filePathDotJava);
          warning("Compile failure : " + filePathDotJava);
          fireBeanXporterEvent(false, null);
          return;  
        }
      }
        
      set_current_dir(tempDir);

      // Now create the jar
      int numberToJar = successfulCompile.size();
      String[] filesToJar = new String[numberToJar];
      boolean[] areBeans = new boolean[numberToJar];
      for(int i =0; i < numberToJar; i++)  {
        filesToJar[i] = (String) successfulCompile.elementAt(i);
        areBeans[i] = 
          ((Boolean) successfulCompileAreBeans.elementAt(i)).booleanValue(); 
      }
      
      logStatus("Creating .jar " + jar);
      if(ToolBroker.createJarFile(filesToJar, areBeans, jar)) {
        logStatus("Jarfile completed: " + jar);
      }
      else {
        progress.logStatus("Jarfile creation failed: " +  jar);
        warning("Jarfile creation failed: " +  jar);
        reset_current_dir();
        fireBeanXporterEvent(false, null);
      }
      reset_current_dir();
      fireBeanXporterEvent(true, jar);
    }
    
    private String stripToRelativePath(String javaFilePath) {
      String stripped = 
        javaFilePath.substring(1, javaFilePath.length() - 5);
    return stripped;
    }
  }  

  private ConversionThread conversionThread = null;

  private void logStatus(String message)
  { 
    if (progress == null)
      System.out.println(message);
    else progress.logStatus(message);
  }

  //*******************************  WizardListener Interface ************

  class BeanXporterWizardListener implements WizardListener
  {
    @Override
    public boolean beforeWizardStart(WizardEvent e)
    {
      pleaseWait("Please Wait - creating library list..");
      return true;
    }
    
    @Override
    public void afterWizardStart(WizardEvent e)
    {
      removePleaseWait();
    }
    
    @Override
    public boolean beforeWizardNext(WizardEvent e)
    {
      Wizard wiz = (Wizard) e.target;
      WizardPanel wizPanel = (WizardPanel) e.arg;
      return checkDataBeforeNext(wizPanel);
    }
    
    @Override
    public void afterWizardNext(WizardEvent e)
    {
    }
    
    @Override
    public boolean beforeWizardBack(WizardEvent e)
    {
      Wizard wiz = (Wizard) e.target;
      WizardPanel wizPanel = (WizardPanel) e.arg;
      
      if (wizPanel instanceof Step2Panel) 
      {
        pleaseWait("Please Wait - creating library list..");
      }
      return true;
    }
    
    @Override
    public void afterWizardBack(WizardEvent e)
    {
      removePleaseWait();
    }
    
    @Override
    public boolean beforeWizardFinish(WizardEvent e)
    {
      Wizard wiz = (Wizard) e.target;
      FinalWizardPanel finalPanel = wiz.getFinalWizardPanel();
      finalPanel.setTitle("Exporting...");
      return true;
    }

    @Override
    public void afterWizardFinish(WizardEvent e)
    {
      Wizard wiz = (Wizard) e.target;
      WizardPanel[] panels = wiz.getStepWizardPanels();
      int [] selections;
      String emitDir, emitPackage, jarFile;
      boolean includeExceptions;
      
      Step1Panel step1 = (Step1Panel) panels[0];
      Step2Panel step2 = (Step2Panel) panels[1];
      Step3Panel step3 = (Step3Panel) panels[2];
      Step4Panel step4 = (Step4Panel) panels[3];
      Step5Panel step5 = (Step5Panel) panels[4];
      
      selections = step1.getList().getSelectedIndexes();
      emitDir = step2.getText();
      emitPackage = step3.getText();
      jarFile = step4.getText();
      includeExceptions = step5.getEmitExceptions();
      
      exportInternal(selections, emitDir, emitPackage,
        jarFile, 
        ToolBroker.useJavac(), 
        (includeExceptions ? false : true));
    }
    
    @Override
    public boolean beforeWizardCancel(WizardEvent e)
    { 
      return true;
    }
    
    @Override
    public void afterWizardCancel(WizardEvent e)
    {
    }
    
    @Override
    public boolean beforeWizardRestart(WizardEvent e)
    {
      return true;
    }
    
    @Override
    public void afterWizardRestart(WizardEvent e)
    {
    }
    
    
    @Override
    public boolean beforeWizardExit(WizardEvent e)
    {
      return true;
    }
    
    @Override
    public void afterWizardExit(WizardEvent e)
    {
    }
  }
  
  


  //*******************************  WizardPeer Interface ************

  class BeanXporterWizardPeer implements WizardPeer 
  {

    @Override
    public void addWizardPeerListener(WizardPeerListener l)
    {
      synchronized (listeners) {
        if (! listeners.containsKey(l))
          listeners.put(l,l);	
      }
    }

    @Override
    public void removeWizardPeerListener(WizardPeerListener l)
    {
      synchronized (listeners) {
        if (listeners.containsKey(l))
          listeners.remove(l);  
      }  
    }
  }

  private void fireCompletedEvent() 
  {
    WizardPeerEvent peerEvent = new WizardPeerEvent(new BeanXporterWizardPeer(), 0, null);
    Enumeration e;
    WizardPeerListener l;

    e = listeners.keys();
        
    while( e.hasMoreElements()) {
      l  = (WizardPeerListener) e.nextElement();
      l.wizardCompleted(peerEvent);
    }
  }

  
  //************************  BeanXporterListener event source ************

 
  /** Add a listener to receive a <code>BeanXporterEvent</code> whenever 
  * this <code>BeanXporter</code> successfully exports an ActiveX type library
  * or fails to export and ActiveX type library
  */
  public void addBeanXporterListener(BeanXporterListener l)
  {
    synchronized (bxListeners) {
      if (! bxListeners.containsKey(l))
        bxListeners.put(l,l);	
    }
  }

  /** Remove a particular BeanXporterListener from this <code>BeanXporter</code>
  */
  public void removeBeanXporterListener(BeanXporterListener l)
  {
    synchronized (bxListeners) {
      if (bxListeners.containsKey(l))
        bxListeners.remove(l);  
    }  
  }

  private void fireBeanXporterEvent(boolean succeeded, String jarFileIfAny) 
  {
    BeanXporterEvent bxEvent = new BeanXporterEvent(this, 0, jarFileIfAny);
    Enumeration e;
    BeanXporterListener l;

    e = bxListeners.keys();
        
    while( e.hasMoreElements()) {
      l  = (BeanXporterListener) e.nextElement();
      if (succeeded) 
        l.exportSuccess(bxEvent);
      else l.exportFailure(bxEvent);
    }
    fireCompletedEvent();
  }


  //************************** User interface Components used in the Wizard ***

  class TitlePanel extends Panel  
  {
    public TitlePanel() 
    {
      Label label1 = new Label("Gensym BeanXporter Wizard");
      Font font = new Font("TimesRoman", Font.BOLD, 22);
      Color emphasis = new Color(0,128,128);

      label1.setFont(font);
      label1.setForeground(emphasis);
      
      Panel togetherPanel = new Panel();
      togetherPanel.add(label1);
      add(togetherPanel);
    }
  }

  class ImageCanvas extends Canvas {
    Image image;
    Dimension size;
    boolean imageLoaded;
    boolean imageLoadFailed;
    MediaTracker tracker;

    public ImageCanvas() {
      setBackground(new Color(255, 255, 255));
      size = getMinimumSize();

      /* Get the image, in our package. Note: Class.getResource does not
         get a reference but creates a URL from the path of the class and the
         given filename. */
      image = Toolkit.getDefaultToolkit().getImage(
                this.getClass().getResource("bx_wizard.gif"));

      /* We will use a Media tracker to wait for the image to load before
         we paint it. */
      tracker = new MediaTracker(this);
      tracker.addImage(image, 0);
    }

    @Override
    public Dimension getPreferredSize() {
      return getMinimumSize();
    }

    @Override
    public Dimension getMinimumSize() {
      return new Dimension(150, 100);
    }

    @Override
    public void paint (Graphics g) {
      if (imageLoadFailed) {
         return;
      }

      if (!imageLoaded) {
        int imageWidth = image.getWidth(this);
        int imageHeight = image.getHeight(this);

        // Wait for the image to load.
        try {
          tracker.waitForAll();
        }
        catch (InterruptedException e) {
          return;
        }

        if (tracker.isErrorAny()) {
          System.err.println("Error loading image: " + image);
          imageLoadFailed = true;
          return;
        }

        imageLoaded = true;

        if (((imageWidth > 0) && (size.width != imageWidth)) ||
            ((imageHeight > 0) && (size.height != imageHeight))) {
          size = new Dimension(imageWidth, imageHeight);
        }
      }

      g.drawImage(image, 0, 0, this);
    }
}


  
  class Step1Panel extends WizardPanel
  {
    List listControl;
    Vector listElements; 

    Step1Panel(String prompt,
               String[] entries)
    {
      super(prompt);

      int numEntries;

      numEntries = entries.length;

      listControl = new List (5, true);
      for (int i = 0; i < numEntries; i++)
      {
        listControl.add(entries[i]);
      }
            
      //ScrollPane scrollPane = new ScrollPane();
      //add(scrollPane, "Center");

      add(listControl);
      }

      public List getList() {
        return listControl;
      }
  }
  
  class SmallTextField extends TextField
  {
      public SmallTextField(String contents)
      {
        super(contents);
      }

      @Override
      public Dimension getPreferredSize() 
      {
        return new Dimension(200,20);
      }
      @Override
      public Dimension getMinimumSize() 
      {
        return new Dimension(200,20);
      }
      @Override
      public Dimension getMaximumSize() 
      {
        return new Dimension(200,20);
      }
  }

  class Step2Panel extends  WizardPanel
  {
    private TextField editPackage; 

    public Step2Panel(String prompt)
    {
      super(prompt);
      editPackage = new SmallTextField(FileBroker.getDefaultEmitPackage());
      Panel centerPanel = new Panel();
      centerPanel.add(editPackage);
      add(centerPanel, "Center");
    }

    public String getText() {
        return editPackage.getText();
    }
  }

  class Step3Panel extends WizardPanel
  {
    private TextField editEmitDir; 

    public Step3Panel(String prompt)
    {
      super(prompt);
      editEmitDir = new SmallTextField(FileBroker.generateTemporaryFilePath());
      Panel centerPanel = new Panel();
      centerPanel.add(editEmitDir);
      add(centerPanel, "Center");
    }
    
    public String getText() {
      return editEmitDir.getText();
    }
  }

  class Step4Panel extends  WizardPanel
  {
    private TextField editJarLocation; 
    private Button browseButton;
    private Frame parent;

    public Step4Panel(String prompt)
    {
      super(prompt);  
      this.parent = parent;
      editJarLocation = new SmallTextField(FileBroker.generateTemporaryFilePath() +
        File.separator + "xbeans.jar");
      Panel centerPanel = new Panel();
      Panel center2Panel = new Panel();
      Panel center3Panel = new Panel();
      browseButton = new Button("Browse");
      centerPanel.setLayout(new BorderLayout(0, 5));
      center2Panel.add(editJarLocation);
      centerPanel.add(center2Panel, "Center");
      center3Panel.add(browseButton);
      centerPanel.add(center3Panel,"East");
      add(centerPanel, "Center");
      ActionListener listener = 
        new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
           Button source = (Button)e.getSource();
           buttonPressed(source);
        }
      };
      browseButton.addActionListener(listener);
    }

    public void setParent(Frame parent) 
    {
        this.parent= parent;
    }

    public void buttonPressed(Button pressed) {
        if (pressed == browseButton) 
        {
          saveDialog(FileBroker.generateTemporaryFilePath());

        }
    }

    public void saveDialog(String directory) {	  
      FileDialog fd = new FileDialog(parent,"Specify jar file:",FileDialog.SAVE);
      fd.setDirectory(directory);
      fd.setFile(editJarLocation.getText());
      fd.show();
      String dirname = fd.getDirectory();
      String filename = fd.getFile();
      if (filename == null | dirname == null) {
        //editJarLocation.setText("");
      }
      else {
        String fullname;
        fullname = 
          (dirname.charAt(dirname.length() - 1) == File.separatorChar)
          ? (dirname + filename) 
          : (dirname + File.separator + filename);
        editJarLocation.setText(fullname);
      } 
    }	

    public String getText() {
      return editJarLocation.getText();
    }
  }

  class Step5Panel extends  WizardPanel
  {
    private Checkbox emitExceptions;

    public Step5Panel(String prompt)
    {
       super(prompt);
       Panel centerPanel = new Panel();
       emitExceptions = new Checkbox("Emit methods that throw exceptions", false);
       centerPanel.add(emitExceptions);
       add(centerPanel, "Center");
       add(new Label(
         "Note: for BeanBox compatability do not select this option", Label.CENTER),
         "South");
    }

    public boolean getEmitExceptions() 
    {
        return emitExceptions.getState();
    }     
  }

  class ProgressPanel extends FinalWizardPanel
    implements BeanXporterListener
  {
    TextArea progressText;

    public ProgressPanel(String prompt)
    {
      super(prompt);
      progressText = new TextArea();
      progressText.setEditable(false);
      add(progressText, "Center");
    }

    public void logStatus(String message)
    {
      progressText.append(message +"\n");
    }

    @Override
    public void exportSuccess(BeanXporterEvent e)
    { 
      setTitle("Completed");
    }

    /** Notification that a BeanXporter export has failed
    */
    @Override
    public void exportFailure(BeanXporterEvent e)
    {
      setTitle("Failed");
    }
  }  

  private Class warningDialogClass;
  
  {
    warningDialogClass = WarningDialog.class;
  }

  private void warning(String message) {
    if (parent == null) 
      System.out.println(message +"\n");
    else {
      WarningDialog wd = 
        new WarningDialog(parent,
        "Gensym BeanXporter Warning",
        true,
        message,
        null);
        wd.setVisible(true);
    }
  }

  private WarningDialog pleaseWait;

  private void pleaseWait(String message) 
  {
    if (pleaseWait != null)
      return;
    if (parent == null) 
      System.out.println(message +"\n");
    else {
      pleaseWait = 
        new WarningDialog(parent,
        "Gensym BeanXporter",
        false,
        message,
        null);
        pleaseWait.setVisible(true);      
    }
  }

  private void removePleaseWait() 
  {
    if (pleaseWait != null)
    {
      pleaseWait.setVisible(false);
      pleaseWait = null;
    }
  }

  private boolean checkDataBeforeNext(WizardPanel panel)
  {
    if (panel instanceof Step1Panel) {
      Step1Panel step1 = (Step1Panel) panel;
      List list = step1.getList();
      int[] selected = list.getSelectedIndexes();
      if ((selected == null) || (selected.length == 0))
      {  
        warning("Please select a library to translate");
        return false;
      }
      else return true;
    }
    if (panel instanceof Step2Panel) {
      Step2Panel step2 = (Step2Panel) panel;
      String emitPackage = step2.getText();
      return checkEmitPackage(emitPackage);
    }
    if (panel instanceof Step3Panel) {
      Step3Panel step3 = (Step3Panel) panel;
      String emitDir = step3.getText();
      return checkEmitDir(emitDir);
    }
    if (panel instanceof Step4Panel) {
      Step4Panel step4 = (Step4Panel) panel;
      String jarFile = step4.getText();
      return checkJarFile(jarFile);
    }
    if (panel instanceof Step5Panel) {
      Step5Panel step5 = (Step5Panel) panel;        
    }    

    if (panel instanceof ProgressPanel) {
      ProgressPanel progress = (ProgressPanel) panel;        
    }      
    return true;
  }



  //*************************** Interface to C library ***********

  /** @undocumented */
  public void addActiveXInfoToList
  (String className, String classID, String libraryPath) {
    registryInfo.addActiveXInfo(className, classID, libraryPath);
  }						

  /** @undocumented */
  public void addFileToFilesList (String filePath, boolean isBean) {  
    if (filePathsForJar == null) {
      filePathsForJar = new Vector();
      areBeansForJar = new Vector();
    }
    filePathsForJar.addElement(filePath);
    areBeansForJar.addElement(new Boolean(isBean));
  }

  private void collectInfo(boolean detailed) {
    NativeMethodBroker.collectInfoAboutControls(this, detailed);
  }


  //*****************  Command Line Interface ***********************

  class BeanXporterApplication extends GensymApplication 
                               implements BeanXporterListener
  {
    BeanXporterApplication(String[] commandLine)
    {
      super(commandLine);
      if (commandLine.length == 0) {
        printUsage();
        System.exit(-1);
        return;
      }
      String axTraceLevel =  commandLineArguments.getOptionValue("-axTraceLevel");
      
      if ((axTraceLevel != null))
      {
        short axT = Short.parseShort(axTraceLevel);
        NativeMethodBroker.setTraceLevel(axT);
      }
      
      boolean wizard = commandLineArguments.getSwitchValue("-wizard");

      if (wizard)
      {
        export();
        return;
      }
      boolean help = commandLineArguments.getSwitchValue("-help");

      if (help)
      {
        printUsage();
        System.exit(0);
      }

      boolean version = commandLineArguments.getSwitchValue("-version");

      if (version)
      {
        printVersion();
        System.exit(0);
      }

      boolean noexceptions = commandLineArguments.getSwitchValue("-noexceptions");
      String libraryPath = commandLineArguments.getOptionValue("-library");
      String progid = commandLineArguments.getOptionValue("-progid");
      String jarFile = commandLineArguments.getOptionValue("-jar");
      String emitDir = commandLineArguments.getOptionValue("-o");
      String emitPackage = commandLineArguments.getOptionValue("-package");      

      addBeanXporterListener(this);

      if ((progid != null) && (libraryPath != null))
      {
           printUsage();
           System.exit(0);
      }
      
      if (libraryPath != null)
        export(libraryPath, emitPackage, emitDir, jarFile, noexceptions);
      else if (progid != null)
        exportFromProgid(progid, emitPackage, emitDir, jarFile, noexceptions);
      else {
        printUsage();
        System.exit(0);
      }   
    }    

    @Override
    public void exportSuccess(BeanXporterEvent e) 
    {
        System.exit(0);
    }

    @Override
    public void exportFailure(BeanXporterEvent e)
    {
        System.exit(-1);
    }
   
    private void printUsage()
    {
      System.out.println("usage:");
      System.out.println("-wizard |");
      System.out.println("-library <libraryPath> [-options] |");
      System.out.println("-progid <ProgID> [-options]\n");
      System.out.println("where:");
      System.out.println("  -wizard                  launch BeanXporter as a Wizard"); 
      System.out.println("  -library <library path>  export a given type library");
      System.out.println("  -progid <ProgID>         export type library for a given ProgID\n");
      System.out.println("options:");
      System.out.println("  -package                 package to export classes into");
      System.out.println("                           default = com.gensym.emitpackage property");
      System.out.println("  -o <output directory>    output directory"); 
      System.out.println("                           default = com.gensym.emitdir property");
      System.out.println("  -jar <jarfile path>      jar file");
      System.out.println("                           default = out.jar in the output directory");
      System.out.println("  -noexceptions            exported methods cannot throw exceptions");
      System.out.println("                           default = can throw exceptions\n");     
      System.out.println("Default properties specified in .com.gensym.properties");
    }

    private void printVersion()
    {
      
      System.out.println("Gensym BeanXporter 1.0 Rev 2, Build 11");
    }
  }

  private BeanXporterApplication app; 
  
  private BeanXporter(String[] commandLine) 
  {
    this();
    app = new BeanXporterApplication(commandLine);
  }

  /** Launch BeanXporter using command-line arguments.
  */
  public static void main (String[] args) 
  { 
    BeanXporter bx = new BeanXporter(args);
  }
}
