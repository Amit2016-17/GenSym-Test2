package com.gensym.beanbuilder;

import java.io.*;
import java.nio.charset.Charset;


/**
 * This class is an interface to a "runtime" interface to
 * sun's ActiveX Bean packager.
 * As the packager may not be available on target systems,
 * this class will allow runtime usage, if available.
 *
 *@author M.D.Gribble
 */
public class RunActiveXBeanPackager {

  private static final String packagerClassName = "sun.beans.ole.Packager";
  private String fullBeanClassName = "";
  private String beanClassName = "";
  private String beanPackageName = "";
  private String jarFileName = "";
  private String activeXDir = "";
  private String regFileName = "";

  public RunActiveXBeanPackager(String fullBeanClassName,
				String jarFileName,
				String activeXDir ) {

    this.fullBeanClassName = fullBeanClassName;
    if (fullBeanClassName.lastIndexOf(".") > -1) {
      this.beanClassName = fullBeanClassName.substring(fullBeanClassName.lastIndexOf(".")+1);
      this.beanPackageName = fullBeanClassName.substring(0, fullBeanClassName.lastIndexOf("."));
    } else
      this.beanClassName = fullBeanClassName;
    this.jarFileName = jarFileName;
    this.activeXDir = activeXDir;
    this.regFileName = activeXDir+File.separatorChar+beanClassName+".reg";
  }


  public static boolean isActiveXBeanPackagerAvailable() {

    try {

      Class packagerClass = Class.forName(packagerClassName);
      return (packagerClass != null);

    } catch (ClassNotFoundException e) {
      return false;
    }
  }

  /**
  The reg files generated have defined CLIDS and contain absolute paths
  The packagger will use th CLID from a previous registration but will
  overwrite the reg file, thus replacing any path changes manully made
  The plan to get round this will be ( not yet implemeneted)
  .As typeLIB is tied to GUID
  .Pass in .reg file, if exists, it is registered
  .Rename .reg file
  .Run Packager, will use GUID from preregistered reg file above
  .Copy old .reg file to new one

  Note: Paths found in reg file's are:
  1. path for where beans.ocx lives
  2. path for where packaged jar file lives
  3. path for where icons for ActiveX control are found
  **/

  //java sun.beans.ole.Packager -o $(ACTIVEX_DIR) -n $(BEAN_PACKAGE).$(BEAN_NAME) -jar $(JARFILE)

  public boolean runPackager(String CLSID,
			     boolean unRegFirst) {

    try {

      System.out.println(fullBeanClassName + " " + jarFileName + " " + activeXDir + " " + CLSID + " ");

      Class packagerClass = Class.forName(packagerClassName);

      if (packagerClass != null) {

	String args =  " -o " + activeXDir +
	               " -n " + fullBeanClassName +
	               " -jar " + jarFileName;

	String processStr = "java " + packagerClassName +  " " + args;
	//System.out.println(processStr);

      // Cant do this using reflection as the packager class is not public
	//Process packager = Runtime.getRuntime().exec (processStr);
	System.out.println(exec("java " + packagerClassName, args));

	//packager.waitFor();

	// Check for Error !!!!

	// Need to change the CLSID, to the one specified
	if (!CLSID.equals(""))
	   replaceCLSIDInRegFile(CLSID);

	return true;
      }

    } catch (Exception e) {
      e.printStackTrace();
      System.out.println(e.toString());
      return false;
    }

    return true;
  }

  private static int process_timeout = 120000; // 2 minutes

  /**
   * Run the the process_name with the parameters and wait for the task to
   * complete, returning the text generated by the outboard process
   *
   */
  public static String exec (String process_name, String parameters)
  {
    Process compilerProcess = null;

    //System.out.println("Running " + process_name + " " + parameters);
    try {
      System.out.println ("Executing:\n>>>");
      System.out.println (process_name + " " + parameters);
      System.out.println (">>>");
      StringBuffer compilerOutput = new StringBuffer("");
      long start_time = System.currentTimeMillis();
      compilerProcess = Runtime.getRuntime().exec (process_name + " " + parameters);
      try { 
    	  Thread.sleep(1000); 
      } catch (Exception E) {}

      InputStream istream = compilerProcess.getInputStream();

      // Process.waitFor() does not work on NT ! with JDK1.1

      int buffer_size = 1;
      byte[] opt = new byte[buffer_size];
      int read_size = istream.read(opt);

      while (read_size == buffer_size) {
	compilerOutput.append((char)opt[0]);
	read_size = istream.read(opt);
	// Check we have not been operating too long
	if (System.currentTimeMillis() - start_time > process_timeout )
	  {
	    compilerProcess.destroy();  // ensure that the compiler process is dead
	    break;
	  }
      }
      return compilerOutput.toString();
    }
    catch (Exception E)

      { return (E.toString()); }
  }


  /**
   * Attempt to find the CLSID entry in the reg file.
   * Looking for the form...
   * [HKEY_CLASSES_ROOT\ATestClassBean.Bean\CLSID]
   * @= "{EF7D8660-7B98-11D1-8DB4-00609703E680}"
   *
   */
  public String getCLSIDFromRegFile() {

    String line;
    //System.out.println(regFileName);
    FileInputStream inStream = null;
    Reader fileIn = null;
    BufferedReader in = null;
    try {
      inStream = new FileInputStream(regFileName);	
      fileIn = new InputStreamReader(inStream, Charset.defaultCharset());
      in = new BufferedReader(fileIn);

      while ((line = in.readLine()) != null) {
	line = line.toLowerCase();
	//System.out.println(line);
	if (line.lastIndexOf("\\clsid") > -1)
	  if ((line = in.readLine()) != null) {
	    if ((line.indexOf("\"{") > -1) && (line.lastIndexOf("}\"") > -1)) {
	      return line.substring(line.indexOf("{"), line.lastIndexOf("}")+1);
	    }
	  }
      }

    } catch (IOException e) {
      System.out.println(e.toString());
      return "";
    } finally {
      closeSilently(in);
 	  closeSilently(fileIn);
 	  closeSilently(inStream);
    }

    return "";
  }

  /**
   * Replace a CLSID in a reg file with a give one
   */
  public boolean replaceCLSIDInRegFile(String newCLSID) {

    String CLSID = getCLSIDFromRegFile();
    if (CLSID.equals("")) {
    	return false; // no CLSID to replace
    }

    System.out.println(CLSID + " " + newCLSID);

    if (CLSID.equals(newCLSID)) {
    	return true; // nothing to do
    }

    String line;
    //System.out.println(regFileName);
    FileInputStream inStream = null;
    FileOutputStream outStream = null;
    Reader fileIn = null;
    Writer fileOut = null;
    BufferedReader in = null;
    PrintWriter out = null;
    try {
      Charset charset = Charset.defaultCharset();	
      
      inStream = new FileInputStream(regFileName);	
      outStream = new FileOutputStream(regFileName+"new");
      
      fileIn = new InputStreamReader(inStream, charset);
      fileOut = new OutputStreamWriter(outStream, charset);
      in = new BufferedReader(fileIn);
      out = new PrintWriter(fileOut);

      while ((line = in.readLine()) != null) {
	int pos = line.indexOf(CLSID);
	while (pos > -1) {
	  line = line.substring(0, pos) + newCLSID + line.substring(pos+CLSID.length());
	  pos = line.indexOf(CLSID);
	  System.out.println("Replaced in line " + line);
	}
	out.println(line);
      }

    } catch (IOException e) {
      System.out.println(e.toString());
      return false;
    } finally {
   	  closeSilently(in);
   	  closeSilently(out);
 	  closeSilently(fileIn);
 	  closeSilently(fileOut);
 	  closeSilently(inStream);
	  closeSilently(outStream);
	      
	  /* rename */
	  File oldFile = new File(regFileName);
	  oldFile.renameTo(new File(regFileName+"old"));
	  File newFile = new File(regFileName+"new");
	  newFile.renameTo(new File(regFileName));
    }

    return false;
  }

  private void closeSilently(Closeable obj){
	  try {
	      if (obj != null) 
	    	  obj.close();
      } catch (IOException e) {
    	  System.err.println(e.toString());
      } 
  }

}


