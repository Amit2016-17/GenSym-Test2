/*
 *   Copyright (C) 1986-2017 Gensym Corporation. All Rights Reserved.
 *
 * 	 TextView.java
 *
 */
package com.gensym.editor.text;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Event;
import java.awt.Font;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.InputEvent;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.util.Hashtable;
import java.util.Locale;
import java.util.Stack;
import java.util.Vector;

import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.JMenuItem;
import javax.swing.JPopupMenu;
import javax.swing.JTextArea;
import javax.swing.KeyStroke;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import javax.swing.text.Caret;
import javax.swing.text.DefaultEditorKit;
import javax.swing.text.Keymap;
import javax.swing.text.Utilities;

import com.gensym.classes.Item;
import com.gensym.message.MessageKey;
import com.gensym.message.Resource;
import com.gensym.message.Trace;



/** 
 * An TextView is an example of a character source that is designed to
 * feed the appropriate high-level editing events to the G2 Parser.
 * It is based on a TextArea. The interaction with the parser listening
 * to those events is optimized to make the linkage more efficient: 
 * When characters are being typed they are packaged into events and
 * sent only once the user has paused for a (adjustable) amount of
 * time as determined by the parameters to a 'heartbeat' thread that
 * looks for pauses in the typing. Operations over entire regions are
 * sent as soon as they occur.
 *
 * @author David McDonald
 * @version 1.3
 * @undocumented -- final Text Editor API is still under review
 */

public class TextView extends JTextArea
implements G2EditorWithUndo, TextSearchTarget, ActionListener
{

  private final boolean debug = false;  // describes what's sent to G2
  private final boolean debugKeyStrokes = false;
  private final boolean debugMouseClicks = false;
  private final boolean debugNewlineCounting = false;
  private final boolean debugPrompts = false;
  private final boolean debugUndo = false;
  private final boolean debugDiffs = false;  // calculation to define the event
  private final boolean debugDiffsWalk = false; // the char by char checks
  private final boolean debugUpdateSource = false;


  private static Resource i18n =
     Resource.getBundle("com.gensym.editor.text.TextEditorLabels");


  private static MessageKey traceKey =
     Trace.registerMessageKey("com.gensym.editor.text", TextView.class);
  private static Resource i18nTrace = 
     Trace.getBundle("com.gensym.editor.text.TraceMessages", Locale.getDefault());

  private static final int DEF_TRACE_LEVEL = 5;

  void tTrace (String message) {
    Trace.send(DEF_TRACE_LEVEL, traceKey, i18nTrace, message, this);
  }
  void tTrace1 (String message, Object arg1) {
    Trace.send(DEF_TRACE_LEVEL, traceKey, i18nTrace, message, this, arg1);
  }
  void tTrace2 (String message, Object arg1, Object arg2) {
    Trace.send(DEF_TRACE_LEVEL, traceKey, i18nTrace, message, this, arg1, arg2);
  }



  private static volatile Timer timer;
  Timer getTimer() { return timer; }
  void setTimer(Timer t) { timer = t; }


  private Session session;
  void setSession(Session s) { session = s; }
  Session getSession() { return session; }



  @Override
  public Dimension getMinimumSize() {
    return new Dimension(50, 30);
  }

  /* N.b. the final size of the text area is determined in G2TextEditor
   * by the layout of the split pane. The size preferences of the
   * three prompting areas, taken collectively, are larger than the
   * lines-by-colums setting done here, so that, plus the percentage
   * of the split (presently .7 in favor of the text area) implicitly
   * determines the size.
   */


  //---------  Constructors and initializations ------------

  public TextView() {}

  /** Initializes the listeners that track the keystroke and mouse
   * events generated by this TextArea
   * @undocumented -- final Text Editor API is still under review
   */ 
  public TextView(Session session) {
    super(6, 35);  // lines by columns
    this.session = session;
    getKeyListener();
    getMouseListener();
    getTextListener();
    addKeyListener(keyListener);
    addMouseListener(mouseListener);
    getDocument().addDocumentListener(textListener);
    if (!keymapBindingsAdded)
      addKeymapBindings();
    if (g2CodeFont == null)
      setFont(getG2CodeFont());
    setupSharedActions();

    setWrapStyleWord( true ); // break on word boundaries
    setLineWrap( true );  // wraps lines by default

    synchronized (TextView.class) {
      if (timer == null || !timer.isAlive())
        timer = new Timer();

    initializationsForStartup();
    }
  }

  CustomMouseListener mouseListener = null;
  CustomMouseListener getMouseListener() {
    if (mouseListener == null)
      mouseListener = new CustomMouseListener();
    return mouseListener;
  }

  KeyListener keyListener = null;
  KeyListener getKeyListener() {
    if (keyListener == null)
      keyListener = new InterpretKeystrokes();
    return keyListener;
  }

  TextListener textListener = null;
  TextListener getTextListener() {
    if (textListener == null)
      textListener = new TextListener();
    return textListener;
  }

  Font g2CodeFont = null;
  Font getG2CodeFont() {
    if (g2CodeFont == null) {
      g2CodeFont = new java.awt.Font("sansserif", java.awt.Font.PLAIN, 12);
      // new java.awt.Font("Bitstream Cyberbit", java.awt.Font.PLAIN, 12)
    }
    return g2CodeFont;
  }


  void removeBackPointers() {
    synchronized (TextView.class) {
      timer.setEditor(null);
      timer = null;
    }
    /* The timer will still be held onto by the thread facility unless
     * we rewrite it to look for a 'go away' flag inside its run loop
     * and send a notify to it from here when we raise that flag. */
    session = null;
    Keymap k = getKeymap();
    k.removeBindings();
    removeKeymap("G2 bindings");
    removeMouseListener(mouseListener);
    removeKeyListener(keyListener);
    transferFocus();
  }

  //This isn't as permanent as removeBackPointers, but some things do need 
  //deinitialization for a future reused editor.
  void shutdown() {
    resetCursor();
    clearUndoRedoStacks();
  }

  private void initializationsForStartup() {
    clearUndoRedoStacks();
    initializationsForClearTheText();
    initializeLineSeparatorModel();
    //    initializeCaretPositionStatus();
    someUndoHasCachedOnTheRedoStack = false;
  }
  
  private void initializationsForClearTheText() {
    reinitializeState();
    textSnapshot = "";
    indexPosition = 0;
    cursorPosition = 0;
    pendingTextChange = false;
    lastTextSnapshot = "";
    lastIndexPosition = 0;
    lastCursorPosition = 0;
    priorCursorPos = 0;
  }

  private void reinitializeState() {
    resetParsingErrorIndex();
    mouseMoved = false;
    regionSelected = false;
    inputWasFromUndo = -1;
    startChangedRegion = 0;
    endChangedRegion = 0;
    regionWithDifferences = "";
    regionAdded = "";
    regionRemoved = "";
  }




  //------------- flag for the Timer Thread --------

  private volatile boolean pendingTextChange;
  void setPendingTextChange(boolean b) { pendingTextChange = b; }
  boolean getPendingTextChange() { return pendingTextChange; }






  //--------- state for (short-term) cursor changes ------

  /* This is a record of where the cursor just was that's used
   * to tell us whether a mouse click has moved the cursor.
   *   This gets set at the end of the processing of any
   * event that changes the position of the cursor: keystrokes,
   * mouse clicks or drags, insertion of prompts. 
   */
  private int priorCursorPos = 0;







  //-------------- Invalidating out-of-date prompts --------

  /* When a person is typing faster than the Timer's delay
   * there is no possibility of keeping the prompting in
   * sync with them since the prompts reflect the information
   * we got back from the G2-side parser after the last
   * ParserInputEvent and by definition we are beyond that
   * while we are typing. 
   *   So to ensure that people aren't doing auto-completion
   * against invalid prompts, we arrange to clear them
   * whenever we reset the timer. 
   */
  private void clearPrompts() {
    session.clearAllPrompts();
  }

  /* This flag keeps us from redundantly clearing already-cleared
   * prompts. */
  private boolean promptsAreValid = true;


  void checkThatPromptsAreClear() {
    if ( promptsAreValid ) {
      //clearPrompts();
      promptsAreValid = false;
    }
  }




  //---------- Coordinating text-change flags ---------
  
  /* Every time the text changes through mouse movement, typing,
   * pasting, etc. we need to do a common set of things that
   * are bundled together in this routine for convienient management.
   * Note that if the text is changed because the user pressed the
   * undo or redo buttons we only call the final step of updateContext.n
   */
  void updateContext() {
    if (debugUpdateSource)
      System.out.println("++++ updateContext() ++++++");
    updateTimer();
    clearRedoStackIfNecessary();
    theTextHasChangedAndPromptsAreInvalid();
  }

  /* This entry point was motivated by undo, which doesn't want to
   * call updateContext because that will reset the redo stack.
   * It's called from doNextStackedParserInputEvent. */
  void theTextHasChangedAndPromptsAreInvalid() {
    makeTextDirty();
    checkThatPromptsAreClear();
  }

  /* For mouse movement, which doesn't introduce changes to the
   * text, only to the what the parser sees, and consequently
   * should not mark the text as dirty. */
  void updateContextCleanly() {
    checkThatPromptsAreClear();
    updateTimer();
  }


  void updateTimer() {
    timer.resetTimeout( this );
    pendingTextChange = true;
  }

  void makeTextDirty () {
    session.setDirtyBit();
    session.activateApplyService();
  }      





  //----------- Mouse management -----------

  /* This is a trivial implementation of the listener. All the
   * real processing happens in methods outside the class.
   *
   * The event sequence for a 'click' is 
   *     (1) press, (2) release, (3) click
   *
   * A selection-drag is a press followed eventually by a
   * release with no click event.
   *
   * Determining which button was used is done by looking at
   * the mask that's set in the event's modifiers. A two button
   * Wintel mouse has button1 for its left button and
   * button3 (!) for it's right button. (Swing 1.1.1)
   *
   * Only clicks on the left button clicks the position of the cursor
   * or (with double or triple clicks) create selections.
   *
   * Enter and exit refer to areas on the screen that handle
   * the mouse. For example if you right-click to get the MS
   * editing menu, that is an exit (after the press, release,
   * click) when the menu comes up, and an enter when the
   * menu is dismissed.
   */

  class CustomMouseListener implements java.awt.event.MouseListener {

    @Override
    public void mouseClicked(java.awt.event.MouseEvent me) {
      if (debugMouseClicks)
	System.out.println("Mouse clicked at " + me.getPoint() );
      updateMouseEventHistory(me);
      mouseClickedLogic(me);
    }

    @Override
    public void mousePressed(java.awt.event.MouseEvent me) {
      if (debugMouseClicks)
	System.out.println("Mouse pressed at " + me.getPoint() );
      updateMouseEventHistory(me);
      mousePressedLogic(me);
    }

    @Override
    public void mouseReleased(java.awt.event.MouseEvent me) {
      if (debugMouseClicks)
	System.out.println("Mouse released at " + me.getPoint() );
      updateMouseEventHistory(me);
      mouseReleasedLogic(me);
    }

    @Override
    public void mouseEntered(java.awt.event.MouseEvent me) {
      //      if (debugMouseClicks)
      //	System.out.println("Mouse entered at " + me.getPoint() );
      updateMouseEventHistory(me);
    }
 
    @Override
    public void mouseExited(java.awt.event.MouseEvent me) {
      //      if (debugMouseClicks)
      //	System.out.println("Mouse exited at " + me.getPoint() );
      updateMouseEventHistory(me);
    }

  } /* end of MouseListener inner class */
		


  //------------- Mouse logic ----------------	 

  void updateMouseEventHistory(MouseEvent me) {
    /* reserved for possible expansion. Originally imagined as the
     * site for a state machine for patterns of mouse gestures.
     * such as if they start a selection drag and then move outside
     * the TextArea when the release or they move outside it
     * momentarily and then re-enter.
     *   Isn't needed so far, but this is a nice place for general
     * trace statements. 5/3/99 ddm
     */
  }

  boolean mouseLeftClicked(int modifiers, MouseEvent me) {
    if (modifiers == InputEvent.BUTTON1_MASK) {
      if (debugMouseClicks)
	System.out.println("Left button (button1_mask) clicked");
      return true;
    }
    else 
      return false;
  }

  boolean mouseMiddleClicked(int modifiers, MouseEvent me) {
    if (modifiers == InputEvent.BUTTON2_MASK) {
      if (debugMouseClicks)
	System.out.println("Middle button (button2_mask) clicked");
      return true;
    }
    else 
      return false;
  }

  boolean mouseRightClicked(int modifiers, MouseEvent me) {
    if (modifiers == InputEvent.BUTTON3_MASK) {
      if (debugMouseClicks)
	System.out.println("Right button (button3_mask) clicked");
      return true;
    }
    else 
      return false;
  }




  //--- press & release

  boolean mousePressPending;
  void clearPendingMousePress() { mousePressPending = false; }
  Point mousePressedAt;
  boolean mouseMoved;

  // press
  void mousePressedLogic(MouseEvent me) {
    if (me.isPopupTrigger())
      popupRightClickMenu(me);
    else {
      mousePressPending = true;
      mousePressedAt = me.getPoint();
    }
  }

  // release
  void mouseReleasedLogic(MouseEvent me) {
    if (me.isPopupTrigger())
      popupRightClickMenu(me);
    else {
      Point presentPosition = me.getPoint();
      if ( mousePressPending &&
	   presentPosition.equals(mousePressedAt) ) {
	mouseMoved = false;
	/* This will be followed by a mouse clicked event */
      }
      else {  /* It's a selection, there won't be a following click event. */
	mouseMoved = true;
	lookForSelectedRegion("released at different position from press");
      }
      clearPendingMousePress();
    }
  }


  //--- click

  void mouseClickedLogic(MouseEvent me) {
    int modifiers = me.getModifiers();
    if (mouseLeftClicked(modifiers, me))
      mouseLeftClickedLogic(me);
    else if (mouseMiddleClicked(modifiers, me))
      mouseMiddleClickedLogic(me);
    else if (mouseRightClicked(modifiers, me))
      mouseRightClickedLogic(me);
    else {
      if (debugMouseClicks)
	System.out.println("Cannot determine button of mouse click from " + me);
      mouseLeftClickedLogic(me);
    }
  }


  /* This logic assumes that left click does selection and repositions
   * the cursor. */
  void mouseLeftClickedLogic(MouseEvent me) {
    if ( me.getClickCount() > 1 )
	lookForSelectedRegion("double click");

    else {
      int start = getSelectionStart();
      int end = getSelectionEnd();

      if ( start == end ) {
	if ( start == priorCursorPos ) {
	  if (debugMouseClicks)
	    System.out.println("Mouse logic:  click didn't change cursor position");
	} 
	else {
	  if (debugUpdateSource)
	    System.out.println("+++ from managePossibleChangeInCursorPosition +++");
	  updateContextCleanly(); 
	  priorCursorPos = getCaretPosition();
	  if (debugMouseClicks)
	    System.out.println("Mouse logic:  cursor position is now " + start);
	}
      }
      else {  /* selectionStart and End are different */
	if ( regionSelected )
	  undoSelectedRegion();
	else 
	  if (debugMouseClicks)
	    System.out.println("\n\nDDM: getSelectionStart (" + start + ")" +
			       "and getSelectionEnd (" + end + ")" +
			       "\n are not equal but there is no selected region.\n\n");
	if (debugUpdateSource)
	  System.out.println("+++ from  #2 managePossibleChangeInCursorPosition +++");
	updateContextCleanly();
      }
    }
  }

  void mouseMiddleClickedLogic(MouseEvent me) {
    // Do the X11 trick of inserting selected text ?
  }

  void mouseRightClickedLogic(MouseEvent me) {
    // I had thought to put popupRightClickMenu() here, but it turns
    // out that we can use the MouseEvent.isPopupTrigger() built-in
    // abstraction provided the test goes on the press or release
    // event (rather than the click event as here), so saving this
    // as a stub in case we want to do our own thing in this situation
    // some day.
  }




  //--------------------- Selected-Region maintainance -------

  private String regionAboutToBeDeleted;

  boolean regionSelected = false;
  int regionStart;
  int regionEnd;
  
  private void setSelectedRegion(int start, int end) {
    regionSelected = true;
    regionStart = start;
    regionEnd = end;
    cutMenuItem.setEnabled( true );
    copyMenuItem.setEnabled( true );

    /* When you do a selection, there is an ambiguity as to where the
     * cursor is for purposes of prompting. Is it at your release point,
     * which could be to either side depending on the direction of
     * your swipe, or is it at the left end because that's where any
     * replacement text will be inserted if you type over the
     * selection. It's probably the later, but for present purposes
     * we're declaring it vague and just arranging that you can't
     * get into trouble if your selection is in a different place
     * than your previous insertion point by making the prompts
     * go away. This must be revisited when there is a proper model
     * of selection as an editing gesture. */
    if (debugUpdateSource)
      System.out.println("+++ from inside setSelectedRegion +++");
    clearPrompts();
  }

  private void undoSelectedRegion() {
    regionSelected = false;
    cutMenuItem.setEnabled( false );
    copyMenuItem.setEnabled( false );
  }

  /* Called from the mouse press&release logic or from the click logic if
   * a double click was heard.  */
  private void lookForSelectedRegion(String whyWeAreHere) {
    int start = getSelectionStart();
    int end = getSelectionEnd();
    if ( start != end ) {
      if (debugMouseClicks)
	System.out.println("MouseClick logic: region selected from " + start + 
			   " to " + end );
      setSelectedRegion(start, end);
      updateContext();
      if (debugUpdateSource)
	System.out.println("+++ from inside lookForSelectedRegion +++");
    } else {
      /* We can get here if the getPoint() at which the mouse was released
       * is only slightly different from where it was pressed and isn't
       * enough to translate into a difference in cursor position. 
       * Note: if our logic thinks the region is selected, and it's not, 
       * clue it in. */
      if (regionSelected)
	undoSelectedRegion();	
      if (debugMouseClicks)
	System.out.println("MouseClick logic:  probable jiggle in mouse position " +
			   "on release at" + start);
    }
  }

  /* In a TextArea (always? NT specific?), when you hit the deletekey
   * that action in and of itself removes the selected text from the view.
   * Here we're just letting the parser know what's happened and updating
   * our internal state.
   */
  private void deleteSelectedRegion(String deletedText) { 
    undoSelectedRegion();
    pendingTextChange = true;
  }

  /* Just a placeholder */
  private void deleteSelectedRegionAndSetupForTypeOver(String deletedText) {
    deleteSelectedRegion(deletedText);
  }

  /* At least in the case of prompt insertion when a region has been selected,
   * there are times when we can't expect that native code to have done our
   * region deletion for us. This does the deletion and sends it over in one
   * go without waiting for the timer. 
   */
  private void sendEventThatDeletesSelectedRegion() {
    // 1st remove the region from the text view itself.
    selfDeleteRegion(regionStart, regionEnd);
    // let the standard machinery package up the editing event.
    sendTextChangesToParser();
    // clean up local state
    undoSelectedRegion();
  }
  
  private void sendEventThatDeletesToBegining(int endingPos) {
    selfDeleteRegion(0, endingPos);
    sendTextChangesToParser();
  }



  //---- A stash of the actions available to us for this component ------

  /* This code is blatantly copied with little variation from
   * http://java.sun.com/docs/books/tutorial/ ... /example-swing/ 
   * TextComponentDemo.class"
   */
  Hashtable actionsTable = new Hashtable();
  private boolean actionsTableCreated = false;

  private void createActionsTable() {
    if (!actionsTableCreated) {
      Action[] actionsArray = getActions();
      for (int i = 0; i < actionsArray.length; i++) {
	Action a = actionsArray[i];
	actionsTable.put( a.getValue(Action.NAME), a );
      }
    }
    actionsTableCreated = true;
  }

  private Action getActionByName(String name) {
    return (Action)actionsTable.get(name);
  }


  /* The trick with an action is that you can permute it to be (have/
   * get) a JMenuItem or a JButton (to which you can give all the
   * usual state and filigree) but only after you add it to the
   * appropriate kind of container.
   *   Here I'm recording all of the actions that are going to be
   * used by more than one container, along with their type-specific
   * analogs, where the analogs (e.g. cutMenuItem) are created when
   * the components (e.g. the popupMenu) are populated.
   */

  Action cutAction;
  Action copyAction;
  Action pasteAction;
  Action selectAllAction;

  JMenuItem cutMenuItem;
  JMenuItem copyMenuItem;
  JMenuItem pasteMenuItem;
  JMenuItem selectAllMenuItem;



  /* Called from the initialization section. */
  private void setupSharedActions() {
    createActionsTable();

    cutAction = getActionByName(DefaultEditorKit.cutAction);
    copyAction = getActionByName(DefaultEditorKit.copyAction);
    pasteAction = getActionByName(DefaultEditorKit.pasteAction);
    selectAllAction = getActionByName(DefaultEditorKit.selectAllAction);

    assembleRightClickPopupMenu();
  }




  //----- The 'right click' menu
  //----- MenuItems for the actions

  JPopupMenu popup = null;

  void popupRightClickMenu(MouseEvent e) {
    lookForSelectedRegion("popupRightClickMenu");
    if ( popup == null ) 
      popup = assembleRightClickPopupMenu();
    popup.show(e.getComponent(), e.getX(), e.getY());
  }


  protected JPopupMenu assembleRightClickPopupMenu() {
    popup = new JPopupMenu();  // can also take a title

    cutMenuItem = popup.add(cutAction);
    cutMenuItem.setText(i18n.getString("cut"));
    cutMenuItem.setMnemonic(KeyEvent.VK_T);  // i18n ????
    cutMenuItem.setAccelerator
      (KeyStroke.getKeyStroke(KeyEvent.VK_X, Event.CTRL_MASK));
    cutMenuItem.addActionListener( this  );
    cutMenuItem.setEnabled(regionSelected);

    copyMenuItem = popup.add(copyAction);
    copyMenuItem.setText(i18n.getString("copy"));
    copyMenuItem.setMnemonic(KeyEvent.VK_C);
    copyMenuItem.setAccelerator
      (KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.CTRL_MASK));
    copyMenuItem.addActionListener( this  );
    copyMenuItem.setEnabled(regionSelected);

    pasteMenuItem = popup.add(pasteAction);
    pasteMenuItem.setText(i18n.getString("paste"));
    pasteMenuItem.setMnemonic(KeyEvent.VK_P);
    pasteMenuItem.setAccelerator
      (KeyStroke.getKeyStroke(KeyEvent.VK_V, Event.CTRL_MASK));
    pasteMenuItem.addActionListener( this  );
    //pasteMenuItem.setEnabled( --have to look at the clipboard-- );

    // it would be nice to make cut/copy explicit events, but
    // that requires (?) subclassing I don't feel like fitting into
    // a tight deadline.  ddm 5/6/99

    popup.addSeparator();

    selectAllMenuItem = popup.add(selectAllAction);
    selectAllMenuItem.setText(i18n.getString("selectAll"));
    selectAllMenuItem.setMnemonic(KeyEvent.VK_A);
    selectAllMenuItem.setAccelerator
      (KeyStroke.getKeyStroke(KeyEvent.VK_A, Event.CTRL_MASK));
    selectAllMenuItem.addActionListener( this  );
    selectAllMenuItem.setEnabled( true );

    return popup;
  }


  //---- ActionListener method  (for the actions in the popup)

  @Override
  public void actionPerformed(ActionEvent e) {
    /* If we wanted, we could do much of the handling from here where
     * we know definitively what they've done, and then just consume
     * the event. */
    JMenuItem source = (JMenuItem)e.getSource();
    if (source.equals(cutMenuItem) || source.equals(pasteMenuItem)) {
      updateContext();
    } else if (source.equals(copyMenuItem)) {
      // no-op unless we want to track this as a gesture
    } else if (source.equals(selectAllMenuItem)) {
      setSelectedRegion(0, getText().length());
    }
  }






  //---- G2-specific KeyBindings -------------------

  private boolean keymapBindingsAdded = false;

  protected void addKeymapBindings() {
    if (!keymapBindingsAdded) {
      Keymap keymap = addKeymap("G2 bindings", getKeymap());
    
      // Alt-i
      Action action = (session.getUnicodeInserter()).getAction();      
      KeyStroke key = KeyStroke.getKeyStroke( KeyEvent.VK_I, Event.ALT_MASK );
      keymap.addActionForKeyStroke(key, action);

      // control-space
      action = new SelectFirstPrompt();
      key = KeyStroke.getKeyStroke( KeyEvent.VK_SPACE, Event.CTRL_MASK );
      keymap.addActionForKeyStroke(key, action);
      
      // control-shift-space
      int cntrlShift = Event.CTRL_MASK | Event.SHIFT_MASK;
      action = new SelectLastPrompt();
      key = KeyStroke.getKeyStroke( KeyEvent.VK_SPACE, cntrlShift);
      keymap.addActionForKeyStroke(key, action);
      
      // control-DEL
      action = new DeleteNextWord();
      key = KeyStroke.getKeyStroke( KeyEvent.VK_DELETE, Event.CTRL_MASK );
      keymap.addActionForKeyStroke(key, action);
      
      // control-Backspace
      action = new DeletePriorWord();
      key = KeyStroke.getKeyStroke( KeyEvent.VK_BACK_SPACE, Event.CTRL_MASK );
      keymap.addActionForKeyStroke(key, action);
      
      setKeymap(keymap);
      keymapBindingsAdded = true;
    }
  }


  //---- prompt selection

  void controlSpaceAccelerator() {
    if ( promptsAreValid && session.categoryPromptsExist() ) {
      String prompt = (session.getPromptView()).getFirstItem();
      PromptManager.insertPrompt(prompt, (PromptsTarget)this);
    }
  }

  void controlShiftSpaceAccelerator() {
    if (  promptsAreValid && session.categoryPromptsExist() ) {
      String prompt = (session.getPromptView()).getLastItem();
      PromptManager.insertPrompt(prompt, (PromptsTarget)this);
    }
  }

  public class SelectFirstPrompt extends AbstractAction {
    public SelectFirstPrompt() {
      super("Select First Prompt");  // i18n ??
    }
    @Override
    public void actionPerformed(ActionEvent e) {
      if (debugKeyStrokes)
	System.out.println("Executing SelectFirstPrompt");
      controlSpaceAccelerator();
    }
  }

  public class SelectLastPrompt extends AbstractAction {
    public SelectLastPrompt() {
      super("Select Last Prompt");
    }
    @Override
    public void actionPerformed(ActionEvent e) {
      if (debugKeyStrokes)
	System.out.println("Executing SelectLastrompt");
      controlShiftSpaceAccelerator();
    }
  }

  class DeleteNextWord extends AbstractAction {
    public DeleteNextWord() {
      super("Delete Next Word");
    }
    @Override
    public void actionPerformed(ActionEvent e) {
      if (debugKeyStrokes)
	System.out.println("calling DeleteNextWord's actionPerformed: " + e);
      int here = (TextView.this).getCaretPosition();
      try {
	int eow = Utilities.getWordEnd(TextView.this, here);
	selfDeleteRegion(here, eow);
	sendTextChangesToParser(); // or should we wait on a fast typist ?
      } catch (BadLocationException ex) {
	com.gensym.message.Trace.exception (ex, "Bad location when attempting " +
					    "to delete word");
      }
    }
  }


  class DeletePriorWord extends AbstractAction {
    public DeletePriorWord() {
      super("Delete Prior Word");
    }
    @Override
    public void actionPerformed(ActionEvent e) {
      if (debugKeyStrokes)
	System.out.println("calling DeletePriorWord's actionPerformed: " + e);
      try {
	int here = (TextView.this).getCaretPosition();
	int sow = Utilities.getWordStart(TextView.this, here);
	selfDeleteRegion(sow, here);
	sendTextChangesToParser();
      } catch (BadLocationException ex) {
	com.gensym.message.Trace.exception (ex, "Bad location when attempting " +
					    "to delete word");
      }
    }
  }





  //------------------ key events ----------------

  private boolean thereWereAdditions = false;
  private boolean thereWereDeletions = false;

  private void resetTypingFlags() {
    thereWereAdditions = false;
    thereWereDeletions = false;
  }

  private boolean nothingWasTyped() {
    if ((thereWereAdditions == false) &&
	(thereWereDeletions == false))
      return true;
    else
      return false;
  }




  /* This is a flag that is useful as part of detecting pastes
   * by interpreting TextChangedEvents.  It lets us restrict out
   * attention to text changes that aren't key strokes.  */
  boolean pendingKeyPress = false;


  class InterpretKeystrokes implements KeyListener {

    // Experimenting with Vikram's gensym.editor.TextEditor.java which has
    // a trace on every event shows that the order of events is
    // 1. keyPressed, 2. keyTyped, 3. keyReleased. 
    
    // Using keyPressed would have the advantage of letting the dispatch
    // be done over virtual keys, which provide constants for delete,
    // backspace, etc.  However it needs additional filtering to
    // eliminate the situation where all that happened was depressing
    // one of the various shift keys.
    
    // Using keyTyped does that filtering implicitly, since it only
    // fires when a Unicode has been produced. (Which would be invaluable
    // for taking the output of FEP's since we (presumably) wouldn't get
    // an event until the whole character was formed. But then, as I've
    // yet to see one for Java, who knows what protocol they might actually use.)
    // On the other hand, the dispatch has to either use character constants
    // (which I haven't figured out how to do for backspace or del given
    // that this code is being written with emacs) or off of Unicodes
    // qua integers. 

    /* N.b. If you hit the enter key, then the char that getKeyChar returns
     * is different for press and release than it is for type.
     * For press/release is is a \r.  For typed is is \n.  (Which isn't
     * all that unreasonable since it's a \n that would go into any
     * string created from typein.)  Depending on the value of the
     * line-separator property, what actually goes into the TextArea
     * will be either one (\n) or two (\r\n) characters.  
     */
        
    /* The progress of the cursor is as follows.  For keyPressed and
     * keyTyped, the cursor is unchanged -- it is the position just to
     * the left of the in-the-process-of-being- entered character. If
     * you invoke getCaretPosition() inside those methods that's what
     * you'll get. The cursor has advanced once you're in keyReleased,
     * now it is the position on the other side of the character. */


    /** @undocumented -- final Text Editor API is still under review */
    @Override
    public void keyPressed(KeyEvent k) {

      /* This is for the benefit of the TextChanged listener to let it
       * distinguish keystrokes from pastes. */
      pendingKeyPress = true;

      updateTimer();
      if (debugUpdateSource)
	System.out.println("++ an updateTimer from keyPressed() +++");
      /* In other situations we would do a full updateContext, of which
       * this is one part, but that includes clearing the prompts, which
       * we do not want to do on a key press because we could be typing
       * an accelerator key pattern that is going to select from those
       * prompts. */

      switch ( k.getKeyCode() ) {
	/* Strictly speaking these aren't additions/deletions to the
	 * text, but from the point of view of the intended receiver
	 * (G2's editor-less parser interface) these have that effect
	 * so I'm using the same flags as for text changes. */
      case KeyEvent.VK_LEFT:
      case KeyEvent.VK_UP:
      case KeyEvent.VK_HOME:
	thereWereDeletions = true;
	break;
      case KeyEvent.VK_RIGHT:
      case KeyEvent.VK_DOWN:
      case KeyEvent.VK_END:
	thereWereAdditions = true;
	break;
      case KeyEvent.VK_DELETE:
	handleDeletionKeys();
	break;
	  default:
      }	  

      if (debugKeyStrokes)
	keystrokeDebuggingTrace((int)k.getKeyChar(), " pressed ", k);
    }


    /** Decodes the KeyChar as a unicode code point and uses that to distinguish
     * between deletes and inserts, passing those along to the appropriate buffers
     * whence they will be sent to the parser according to the dictates of the
     * buffering protocol. 
     * @undocumented -- final Text Editor API is still under review
     */
    @Override
    public void keyTyped(KeyEvent k) {

      char key = k.getKeyChar();
      int unicode = (int)key;   // This appears to do the right thing, though there is
                                // nothing in the spec that says it has to.

      switch ( unicode ) {

      case 8:
	/* 8 is backspace. The other candiate would be 127 (rubout/Del/Delete),
	 * but JTextArea doesn't generate a typed event for it (jdk 1.1.x, 1.2.0)
	 * so we have to get it in the pressed event. */
	handleDeletionKeys();
	break;

      case 32:  // space
	/* n.b. the control-space and control-shift-space prompt selection
	 * accelerators are implemented by KeyStroke actions */
	thereWereAdditions = true;
	break;

      default:
	thereWereAdditions = true;
	if (regionSelected) {
	  thereWereDeletions = true;
	  deleteSelectedRegionAndSetupForTypeOver( regionAboutToBeDeleted );
	}
      }

      if (debugKeyStrokes)
	keystrokeDebuggingTrace(unicode, " typed ", k);

      updateContext();
      if (debugUpdateSource)
	System.out.println("+++ from inside keyTyped ++++");
    }



    /* Just manages some state. */
    @Override
    public void keyReleased(KeyEvent k) {

      pendingKeyPress = false;

      priorCursorPos = getCaretPosition();  // used for mouse calculations

      if (debugKeyStrokes)
	keystrokeDebuggingTrace( (int)k.getKeyChar(), " released ", k);
    }


    private void handleDeletionKeys () {
      thereWereDeletions = true;
      if ( regionSelected )
	/* The timer-initiated processing will react to the cut, but
	 * we need to make this call to take care of some bookeeping */
	deleteSelectedRegion( regionAboutToBeDeleted );
    }






    private void keystrokeDebuggingTrace(int unicode, String type, KeyEvent k) {
      switch ( unicode ) {
      case 8:
	System.out.println("Keys:" + type + "backspace at " + getCaretPosition() );
	break;
      case 9:
	System.out.println("Keys:" + type + "tab at " + getCaretPosition() );
	break;
      case 10:   // carriage return: u\000A  \r
      case 13:   // newline: u\000D  \n
	System.out.println("Keys:" + type + "enter at " + getCaretPosition() );
	break;
      default:
	if (" pressed ".equals(type) || " released ".equals(type)) {
	  switch ( k.getKeyCode() ) {
	  case KeyEvent.VK_LEFT:
	    System.out.println("Keys:" + type + "left arrow at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_RIGHT:
	    System.out.println("Keys:" + type + "right arrow at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_UP:
	    System.out.println("Keys:" + type + "up arrow at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_DOWN:
	    System.out.println("Keys:" + type + "down arrow at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_END:
	    System.out.println("Keys:" + type + "end at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_HOME:
	    System.out.println("Keys:" + type + "home at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_PAGE_UP:
	    System.out.println("Keys:" + type + "page up at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_PAGE_DOWN:
	    System.out.println("Keys:" + type + "page down at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_INSERT:
	    System.out.println("Keys:" + type + "insert at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_DELETE:
	    System.out.println("Keys:" + type + "delete at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_BACK_SPACE:
	    System.out.println("Keys:" + type + "backspace at " + getCaretPosition() );
	    break;
	  case KeyEvent.VK_CONTROL:
	    System.out.println("Keys:" + type + "control");
	    break;
	  case KeyEvent.VK_SHIFT:
	    System.out.println("Keys:" + type + "shift");
	    break;
	  default:
	    // etc.
	  }
	}
	else
	  System.out.println("Keys:" + type + "\"" + k.getKeyChar() + "\" at " +
			     getCaretPosition() + "  unicode = " + unicode);
      }
      if ( k.isControlDown() )
	System.out.println(type + ":   the control key is down");
      if ( k.isShiftDown() )
	System.out.println(type + ":   the shift key is down");
    }


  }  // end of InterpretKeystrokes class





  //-------- Tracking TextEvents for cut&paste ---------------

  /* The purpose of specially noticing TextChangedEvents (and not just
   * the keystrokes, since those will include TextChangedEvents) is
   * for externally initated cuts (vs. those initiated by backspace)
   * and for pastes. If there's a keystroke underway then the processing
   * here would be redundant. 
   *
   * A complicating factor is that TextChangedEvents are also triggered
   * by the actions of undo/redo methods. If nothing is done about that,
   * this method will, in effect, issue the same event yet again. 
   *   I originally tried a filter that compared the redundant event
   * against the real one, but slight differences in where the cursor
   * would be positioned tended to make an exact match difficult to
   * achieve. Finally I convinced myself that a flag set during the
   * undo/redo processing would always be seen here next, and that
   * we could thereby keep the redundant event from ever being
   * assembled. The flag is inputWasFromUndo. It is set in the
   * workhorse method doNextStackedParserInputEvent.
   */

  int inputWasFromUndo;

  class TextListener implements DocumentListener {

    @Override
    public void insertUpdate(DocumentEvent e) {}
    @Override
    public void removeUpdate(DocumentEvent e) {}

    @Override
    public void changedUpdate(DocumentEvent e) {
      if ( !pendingKeyPress ) {

	if ( inputWasFromUndo != -1  &&
	     inputWasFromUndo != ParserInputEvent.CURSOR_CHANGE ) {
	  inputWasFromUndo = -1;
	  return;
	}

	updateContext(); 
	if (debugUpdateSource)
	  System.out.println("+++ from inside TextListener ++++");
	priorCursorPos = getCaretPosition();
      }
    }

  }





















  //-------- character constants

  /* This is used to determine whether a space should be added
   * in front of the prompt when introducing prompts (e.g. when the
   * text if "foo ()" and the prompt is "begin").  It obviously
   * isn't general enough to cope with what could be used in a
   * general unicode text-source (and G2 does have that wide a model
   * of what constitutes delimiting whitespace), but it gets the
   * job done in the ordinary case.
   */
  //private static final char asciiSpace = '\u0020';
  private static final char asciiSpace = ' ';

  /* It's up to the method that gets the keystroke events to decide
   * what's a deletion keystroke for the purposes of the keyboard
   * source that's being used. For later processing though we 
   * canonicalize the choice of character to just Del.
   */
  private static final char theDeleteCharacter = '\u0008';


  private static final char carriage_return =  '\n';


  private static final char theCanonicalCharacter = 'q';






  //-------------- Commands coming in from other objects --------

  /* */
  @Override
  public void setText(String textToSetItTo, int cursorpos) {
    if (debug)
      System.out.println("\n\n\n\n\n\n>>>>>>>>>>> (re)setting the text <<<<<<<<\n");

    String originalText = getText();
    int eventType = ParserInputEvent.NO_CHANGE; // Java is not Lisp
    if ( originalText.equals("") )
      eventType = ParserInputEvent.ADDED_REGION;
    else
      eventType = ParserInputEvent.DELETED_REGION; // for interpretation as 'clear'

    assembleAndIssueParserInputEvent
      (eventType,
       cursorpos, // new cursor index
       0,         // old cursor index
       0,         // region start
       textToSetItTo.length(), // region end
       "",             // difference: n.a. -- for replacing unequal regions
       textToSetItTo,  // additions
       originalText,   // deletions
       textToSetItTo,  // the whole text
       false);   // really issue the event

    /* Reset the snapshot state information. */

    initializationsForClearTheText();
    setText(textToSetItTo);
    setCaretPosition(cursorpos);
    requestFocus();
  }


  /* This is called from Session to do the conclude. The call out
   * to parse is here because we need to (a) check that G2's model
   * of the current text is accurate -- for which we check the
   * dirty bit information that the Timer uses and do an update
   * if needed. And (b) we may need to move the cursor to the end
   * if it's not already there so that the conclude is working with
   * an uptodate analysis of the whole string and not just some
   * part of it up to the point where the user has their cursor.
   * The change in the cursor position has to be transparent to
   * the user, so it's matched with a move back to the original
   * place. If we didn't do that we would open ourselves up to
   * some really subtle bugs; see HQ-2150261.
   */
  @Override
  public boolean attemptToConcludeText(Item item, ParserInputEventListener parser, 
				       Boolean editingForRuntimeChange) {
    if (debug)
      System.out.println("\n\n>>> Initiating a conclude");

    if ( pendingTextChange )
      sendTextChangesToParser();

    String text = getText();
    int cursorPos = adjustedCursorPosition( getCaretPosition() );
    boolean cursorIsNotAtEndOfText = ( cursorPos != text.length() );

    /* Move the cursor on the G2 side so that we are sure that the
     * entire text has been analyzed before we attempt to conclude
     * a new value for what's being edited.  Note that this is a bogus
     * choice of event,(CURSOR_CHANGE would be more natural), but the 
     * Lisp source of G2 is frozen just now, and this choice gets around 
     * a problem where a cursor change to where G2 thinks is currently 
     * the end will be interpreted as a retreat, which would have the 
     * wrong effect. */
    if ( cursorIsNotAtEndOfText )
      assembleAndIssueParserInputEvent
	(ParserInputEvent.ADDED_CHARACTER, text.length(), cursorPos,
	 0, 0, "", "", "", text, false);

    boolean ok_P = 
      parser.attemptToConcludeParsingContext(item, editingForRuntimeChange);

    /* Unless there was a problem, move G2's view of the cursor back 
     * to be what the user thinks it is. Doing this when there's a problem
     * will throw away the problem status information since we would
     * get new status information back from this call.*/
    if ( ok_P && cursorIsNotAtEndOfText )
      assembleAndIssueParserInputEvent
      	(ParserInputEvent.CURSOR_CHANGE, cursorPos, text.length(),
	 0, 0, "", "", "", text, false);

    if (debug)
      System.out.println("Conclude finished<<<\n\n");

    requestFocus();
    return ok_P;
  }







  //-------- compensating for CR/LF problem ---------

  /* When this is run on an NT box, pressing the 'return' key causes
   * two characters to be introduced into the TextArea widget: 
   * a carriage return (x000D, \r) followed by a linefeed (x000A, \n) and
   * these are counted in the 'characters from the begining of the
   * text' calculation done by getCaretPosition().
   *   Unfortunately, this is out of sync with the count that is
   * kept by getText(), which follows Java's convention and represents
   * a line-separation as a single character (linefeed). 
   *   Unless steps are taken the two indicies get out of sync immediately
   * and the parsing context quickly gets confused and makes the wrong
   * analysis. [ but see addendum just below with the next flag ]
   */

  private boolean linebreakIsTwoCharacters;

  private void initializeLineSeparatorModel() {
    String localLineSeparator = System.getProperty("line.separator");
    switch ( localLineSeparator.length() ) {
    case 1 :
      linebreakIsTwoCharacters = false;
      break;
    case 2 :
      linebreakIsTwoCharacters = true;
      break;
    default :
      // should be impossible to get here given the Java spec, and if we
      // did, the indicies would be out of sync, so in this case we'll
      // leave the variable unintialized and let it blow up as an 
      // implicit warning that something would go haywire. The backtrace
      // would tell us all we needed to know. 
    }
  }


  /* Starting in jdk1.1.6, Sun changed to rationalizing the value returned
   * by getCaretPosition so that it returns the value that the index would
   * have if it were checked against a string. In effect, they've removed
   * the platform-specificity of the issue.  We got the original problem
   * that motivated our somewhat elaborate checking for one vs. two line
   * separator characters back in 1.1.2 or so, and it was definitely still
   * there in 1.1.4.  Some simple checking suggests that this is partially
   * rationalized in 1.1.5, in that they get the cases where the cursor
   * is inside the current line correct (rationalized to one character
   * line-separators) but mess up (don't rationalize) the case where the
   * cursor is right at the beginning of the line -- which proves they're
   * only mortal since getting that case right requires a lot of debugging
   * here - see numberOfLineSeparatorsFromTheBeginning.
   *   As of now (9/14/98) we correct correctly for 1.1.4 and earlier,
   * but do not have an implementation for a fix to the apparent half-fix
   * evident in 1.1.5.  Fortunately, it looks like no customers will work
   * with anything earlier than 1.1.6, but this code is here just in case.
   */

  /* Then (11/98) they came out with 1.1.7a, which was a case not anticipated
   * by the unfortunate parser below (retained just in case). But we can now
   * declare by fiat that t2 is not to be run with any version of the jdk
   * below 1.1.6, in which case all of that calculation is moot.  */
  private boolean getCaretPositionIsStringBased = true;

  private void initializeCaretPositionStatus() {
    getCaretPositionIsStringBased = true;
      //isTheVersionOfJDKGreaterThan115();
    if ( debugNewlineCounting )
      System.out.println("Initialized getCaretPositionIsStringBased to " +
			 getCaretPositionIsStringBased);
  }

  private boolean isTheVersionOfJDKGreaterThan115() {
    String version = System.getProperty("java.version");

    if ( version.equals("") )
      return false;   // This is paranoid, but if it's possible, is false the right answer?

    if ( version.length() == 1 ) {          // guards the first substring operation
      if ( Integer.parseInt(version) <= 1 ) // if there no period
	return false; // 1
      else 
	return true;  // 2
    }

    int indexOfFirstPeriod = version.indexOf('.');
    if ( indexOfFirstPeriod == -1 ) // "2b1"
      indexOfFirstPeriod = version.length(); // saves copying code

    String major = version.substring(0, indexOfFirstPeriod);
    if ( Integer.parseInt(major) == 0 ) // beta
      return false;

    if ( Integer.parseInt(major) == 1 ) {
      int indexOfSecondPeriod = version.indexOf('.', indexOfFirstPeriod + 1);
      if ( indexOfSecondPeriod == -1 )  // e.g. "1.2"
	indexOfSecondPeriod = version.length();

      String minor = version.substring(indexOfFirstPeriod + 1, indexOfSecondPeriod);
      if ( ( Integer.parseInt(minor) <= 1 ) &&
	   ( indexOfSecondPeriod != version.length() ) // "1.1"
	   ) {
	String last = version.substring(indexOfSecondPeriod + 1);
	if ( last.indexOf('.') != -1 ) // 1.1.5.1 -- would blow up parseInt
	  return false;  // same policy as verion == ""
	if ( Integer.parseInt(last) <= 5 )
	  return false;
	else
	  return true;
      }
      else
	return true;
    }
    else
      return true;
  }







  //-------- Methods for implementing the PromptsTarget interface ------

  @Override
  public String getLeftPromptContext (int length) {
    int here = getCaretPosition();
    if ( here <= length )
      return getText().substring(0, here);
    else {
      return getText().substring(here - length, here);
    }
  }

  @Override
  public String getRightPromptContext (int length) {
    String text = getText();
    int here = getCaretPosition();
    int textLength = text.length();
    int lengthRemaining = textLength - here;
    if ( lengthRemaining <= length )
      return text.substring(here);
    else 
      return text.substring(here, here + length);
  }


       
  @Override
  public void insertPromptStringAtCursor(String p) {
    int here = getCaretPosition();
    insert(p, here);
    if (debugPrompts)
      System.out.println("Prompt insertion: introduced \"" + p + 
			 "\" at " + here);
    setupAfterPromptInsertion();
  }

  @Override
  public void moveCursor(int delta) {
    setCaretPosition( getCaretPosition() + delta );
    if (debugPrompts)
      System.out.println("Prompt insertion: move the cursor " + delta +
			 " to " + getCaretPosition());
    setupAfterPromptInsertion();
  }

  private void setupAfterPromptInsertion() {
    //    updateTimer();
    //    makeTextDirty();
    //    clearRedoStackIfNecessary();
    updateContext();
    requestFocus();   
    clearPrompts();
  }














  //-------- Methods for reflecting the point of an error in the text -----

  private int parsingErrorIndex = -1;

  private boolean thereIsAParsingError() { return(parsingErrorIndex != -1); }

  private void resetParsingErrorIndex() { parsingErrorIndex = -1; }

  private void setParsingErrorIndex(int stringCursorPosition) {
    parsingErrorIndex = stringCursorPosition;
  }


  /* This is provided in lieu of the '...' facility for indicating
   * where the parser believes the error to be when the status of
   * the parse goes bad.
   */
 @Override
 public void positionCursorAtError() {
    if ( thereIsAParsingError() ) {
      if ( parsingErrorIndex != getCaretPosition() ) {
	try {
	  setCaretPosition( parsingErrorIndex );
	  cursorNotMovedByUser = true;
	} catch (java.lang.IllegalArgumentException e) {
	  System.out.println("Received invalid cursor position: "+e);
	}
      }
      requestFocus();
    }
  }

  /* If we don't take steps, the cursor movement to shift (if needed)
   * from where the user left the cursor to where the error is will
   * lead to the construction of a parser event. If we don't block it
   * we get into a situation where when the user goes to undo their
   * change they'd actually be undoing the cursor movement, which since
   * it wasn't what caused the problem will result in the error being
   * seen and the cursor moved back -- to the use it would look like
   * their undo request was ignored.
   *   This flag and test against it handle the problem. The method
   * is called as a last check before perceived differences are
   * intepreted as parser input events and blocks them if the flag
   * is up. The imaginative name on the flag is intended to remind us
   * that there might be other situations where this could be used. 
   */
  private boolean cursorNotMovedByUser = false;

  boolean justMovedTheCursorToParsingErrorSite() { 
    boolean value = cursorNotMovedByUser;
    if ( value ) {
    	cursorNotMovedByUser = false;  // reset
    }
    return value;
  }


  /** This method implements the ParsingStatusUpdated Listener.
   * @undocumented -- final Text Editor API is still under review
   */
  @Override
  public void changeParsingStatus(ParsingStatusUpdatedEvent e) {
    if ( e.statusIsOkQ() ) {
      resetParsingErrorIndex();
      resetCursor();
      //clearParsingErrorSpan();
    }
    else {
      setParsingErrorIndex( e.getErrorIndex() );
      flashRedCursorAtErrorPosition();
      //findAndHighlightParsingErrorSpan();
    }
  }

  
  /* Cursor-hacking approach to highlighting the point of the error */
  private Color originalCursorColor = getCaretColor();
  private Caret theCaret = getCaret();
  private int originalBlinkRate = theCaret.getBlinkRate();


  private void resetCursor() {
    setCaretColor(originalCursorColor);
    theCaret.setBlinkRate(originalBlinkRate);
  }

  private void flashRedCursorAtErrorPosition() {
    setCaretColor(Color.red);
    theCaret.setBlinkRate(100);
    positionCursorAtError();
  }
  /* The blink rate is the delay in milliseconds between blinks.
   * The default is 500. */




  /* This set of methods will put a red selection region over the
   * span of the last ParserInputEvent that was sent, i.e. the one
   * that resulted in an error. As an approach to what to do to
   * draw the users attention to the site of the error itt has problems
   * since, just being a selected region, it goes away the moment
   * you move the mouse. Also, since we're using the 'fast typist'
   * protocol when talking to the parser (on the server), the region
   * is very likely to be larger that it needs to be and maybe
   * somewhat irrelevant. */
  private Color defaultSelectionColor = getSelectionColor();
  private Range parsingErrorSpan;

  private void findAndHighlightParsingErrorSpan() {
    ParserInputEvent e = mostRecentParserInputEvent();
    parsingErrorSpan = e.endPoints();
    highlightParsingErrorSpan();
  }
    
  private void highlightParsingErrorSpan() {
    if ( !Range.undefined(parsingErrorSpan) ) {
      setSelectionStart(parsingErrorSpan.getStart());
      setSelectionEnd(parsingErrorSpan.getEnd());
      setSelectionColor(Color.red);
    }
  }

  private void clearParsingErrorSpan() {
    parsingErrorSpan = null;
    setSelectionColor(defaultSelectionColor);
  }












  //--------------  undo/redo operations ---------------

  Stack undoStack = new Stack();
  Stack redoStack = new Stack();

  /* I maintain two stacks because the steps you take to execute the
   * ParserInputEvents the stacks contain is the same in both cases.
   * It's the logical equivalent of having one 'stack' plus a pointer
   * into it. This single stack would hold all of the events that had
   * ever occurred, and undo would mean moving the pointer down the
   * stack with the events above the pointer available for redo.
   * The two stacks are just a different perspective that felt easier
   * to implement and maintain. 
   */

  private void clearUndoRedoStacks() {
    undoStack.removeAllElements();
    redoStack.removeAllElements();
    session.deactivateUndoService();
    session.deactivateRedoService();
  }


  /* The method clearRedoStackIfNecessary() is called from updateContext
   * whenever there is any new input from the user (type-in, deletions,
   * mouse movement). This is because the only purpose of a redo operation
   * is to let the user back out of a corresponding undo.  E.g. the user
   * enters three new statements into a procedure. They're not sure about
   * what they really want so they undo them. They change their mind again,
   * they decide that they really do want those new statements, so they
   * use redo to get them back. Now, imagine that after doing some of
   * these back and forth changes, they get back to a situation where
   * they only have two of those original three, and the third was just
   * undone and sits on the redo stack. Now instead of a redo or more
   * undos they go an type in some different third statement. This makes
   * the pending redo invalid because the place where it would go doesn't
   * 'exist' anymore -- the new statement is there instead, and executing
   * the top of that redo stack would put the text into a state that had
   * never exited before (i.e. one where both the original and new third 
   * statements are present), that that is not redo's purpose.
   */
  boolean someUndoHasCachedOnTheRedoStack;

  void clearRedoStackIfNecessary() {
    if (someUndoHasCachedOnTheRedoStack) {
      redoStack.removeAllElements();
      session.deactivateRedoService();
      someUndoHasCachedOnTheRedoStack = false;
    }
  }


  void recordInputEvent(ParserInputEvent e) {
    if (debugUndo)
      System.out.println("Recording input event: " + e);
    undoStack.push(e);
    session.activateUndoService();
  }
  
  void recordUndoEvent(ParserInputEvent e) {
    if (debugUndo)
      System.out.println("Recording undo event: " + e);
    redoStack.push(e);
    session.activateRedoService();
    someUndoHasCachedOnTheRedoStack = true;
  }

  private ParserInputEvent mostRecentParserInputEvent () {
    /* If the stack is empty we get a null, so it is on the caller's
     * head to be sure that there is guarenteed to be an event in
     * the stack. */
    return (ParserInputEvent)undoStack.peek();
  }

  @Override
  public void undo() {
    if ( ! undoStack.empty() ) {
      if (debugUndo || debug)
	System.out.println("\n\n>> Undoing  " +
			   (ParserInputEvent)undoStack.peek() );
      ParserInputEvent e = doNextStackedParserInputEvent(undoStack);
      recordUndoEvent(e);
      if ( undoStack.empty() )
	session.deactivateUndoService();
    }
    requestFocus();
  }
      
  @Override
  public void redo() {
    if ( ! redoStack.empty() ) {
      if (debugUndo || debug)
	System.out.println("\n\n>> Redoing  " +
			   (ParserInputEvent)redoStack.peek() );
      ParserInputEvent e = doNextStackedParserInputEvent(redoStack);
      recordInputEvent(e);
      if ( redoStack.empty() )
	session.deactivateRedoService();
    }
    requestFocus();
  }


  /* This is the final common path for all undo/redo actions. The earlier
   * methods are the type-specific bookeeping.
   */
  ParserInputEvent doNextStackedParserInputEvent(Stack s) {
    ParserInputEvent e = (ParserInputEvent)s.pop();
    if (debugUndo)
      System.out.println("Doing cached event:\n " + ParserInputEvent.description(e));
    ParserInputEvent i = ParserInputEvent.invertEvent(e);
    if (debugUndo)
      System.out.println("  whose inverted equivalent is:\n " +
			 ParserInputEvent.description(i));

    copyEventToTextView(i);
    theTextHasChangedAndPromptsAreInvalid();
    //checkThatPromptsAreClear();
    takeNewSnapshotOfTheText();
    i.setText( getText() );  // update the event to show the effects of the copy
    issueParserInputEvent(i, i.getID());
    inputWasFromUndo = i.getID();  // see TextListener
    return i;
  }


  void copyEventToTextView(ParserInputEvent e) {
    switch ( e.getID() ) {
    case ParserInputEvent.ADDED_CHARACTER:
      selfAddCharacter(e.getCharacter(), e.getCharacterPosition(), e.getText());
      break;
    case ParserInputEvent.DELETED_CHARACTER:
      selfDeleteCharacter(e.getCharacterPosition());
      break;
    case ParserInputEvent.ADDED_REGION:
      selfAddRegion(e.getRegionText(), e.getRegionStart(), e.getRegionEnd(),  e.getText());
      break;
    case ParserInputEvent.DELETED_REGION:
      selfDeleteRegion(e.getRegionStart(), e.getRegionEnd());
      break;
    case ParserInputEvent.REPLACED_REGION:
      selfReplaceRegion(e.getNewRegion(), e.getRegionStart(), e.getRegionEnd());
      break;
    case ParserInputEvent.REPLACED_UNEQUAL_REGIONS:
      selfReplaceUnEqualRegions(e.getNewRegion(), 
				e.getOldStartPosition(), e.getOldEndPosition(),
				e.getNewStartPosition() );
      selfChangeTheCursorPosition( e.getCursor(), e.getText() );
      break;
    case ParserInputEvent.CURSOR_CHANGE:
      selfChangeTheCursorPosition( e.getCursor(), e.getText() );
      break;
    case ParserInputEvent.NO_CHANGE:
      break;
    default:
    }
  }

  void selfAddCharacter(String c, int p, String text) {
    /* The position, p, represents where the cursor will be after the
     * character is inserted, so we have to work backwards from that
     * to determine the place where it must be inserted. */
    //insert(c, convertStringPositionToCursorPosition(p, text) - 1);
    insert(c, p - 1);
  }

  void selfDeleteCharacter(int p) {
    replaceRange("", p, p + 1);
  }
    

  void selfAddRegion(String region, int start, int end, String text) {
    insert(region, start);
    selfChangeTheCursorPosition(end, text);
  }

  void selfDeleteRegion(int start, int end) {
    replaceRange("", start, end);
  }

  void selfReplaceRegion(String region, int start, int end) {
    replaceRange(region, start, end);
  }

  void selfReplaceUnEqualRegions(String replacement, 
				 int oldStart, int oldEnd, int newStart) {
    replaceRange("", oldStart, oldEnd);
    insert(replacement, newStart);
  }

  void selfChangeTheCursorPosition(int p, String text) {
    setCaretPosition( convertStringPositionToCursorPosition(p, text) );
  }









  //---------------- implementing ParserInputSource --------


  private Vector listeners = new Vector();

  /** Adds a listener to the list of ParseInputEvent listeners. 
   * @undocumented -- final Text Editor API is still under review
   */
  @Override
  public void addParserInputEventListener (ParserInputEventListener l) {
    listeners.addElement(l);
  }

  /** Removes a listener from the list of ParseInputEvent listeners.
   * @undocumented -- final Text Editor API is still under review
   */
  @Override
  public void removeParserInputEventListener (ParserInputEventListener l) {
    listeners.removeElement(l);
  }






  //----------- Constructing events for the parser ------------


  /* This version takes explicit arguments (many of which are likely to
   * be null). It is used in the few places that need to send events
   * to the parser that aren't governed by the Timer.
   */
  void assembleAndIssueParserInputEvent(int eventType, 
					int newCursorIndex, int oldCursorIndex,
					int regionStart, int regionEnd,
					String differences, String additions,
					String deletions,
					String text, boolean update ) {

    /* On the assumption that no one is ever going to deliberately assemble
     * a replacement of unequal lengths, those arguments are zero'd out here. */
    ParserInputEvent 
      e = assembleParserInputEvent(eventType, newCursorIndex, oldCursorIndex,
				   regionStart, regionEnd,
				   0, 0, 0, 0,
				   differences, additions, deletions,
				   text, update);
    if ( update )
      recordInputEvent(e);
    issueParserInputEvent(e, eventType);
  }


  /* This version takes its arguments implicitly from instance variables
   * that are managed by the event description facilities and reset with
   * each Timer-governed event.
   */
  void assembleAndIssueNextParserInputEvent(int eventType) {
    ParserInputEvent e
      = assembleParserInputEvent(eventType, indexPosition, lastIndexPosition,
				 startChangedRegion, endChangedRegion,
				 startOldRegion, endOldRegion, 
				 startNewRegion, endNewRegion,
				 regionWithDifferences, regionAdded, regionRemoved,
				 textSnapshot, true);
    recordInputEvent(e);
    issueParserInputEvent(e, eventType);
  }


  /* Common final path for creating a event to be sent to G2. */
  ParserInputEvent assembleParserInputEvent(int eventType, 
					    int newCursorIndex, int oldCursorIndex,
					    int regionStart, int regionEnd,
					    int startOldRegion, int endOldRegion,
					    int startNewRegion, int endNewRegion,
					    String differences, 
					    String additions, String deletions,
					    String text, boolean update ) {
    if (debugDiffs)
      System.out.println
	("Assembling a user-initiated " + ParserInputEvent.nameEvent(eventType) + 
	 " event." +
	 "\n   cursor is now at " + newCursorIndex + " moved from " + oldCursorIndex +
	 "\n   region starts at " + regionStart + " and ends at " + regionEnd +
	 "\n   differences = \"" + differences + "\"" +
	 "\n   additions = \"" + additions + "\"" +
	 "\n      additions start at " + startNewRegion + " and end at " + endNewRegion +
	 "\n   deletions = \"" + deletions + "\"" +
	 "\n      deletions start at " + startOldRegion + " and end at " + endOldRegion );

    ParserInputEvent e = new ParserInputEvent( (Object)this );   
    /* a NO_CHANGE event to apease the compiler */

    switch (eventType) {
    case ParserInputEvent.CURSOR_CHANGE:
      e = new ParserInputEvent( (Object)this,           // source
				newCursorIndex,      // new cursor position
				oldCursorIndex,
				update,           // update the prompts and state ?
				text );         // the entire text in the view
      break;
    case ParserInputEvent.ADDED_CHARACTER:
      e = new ParserInputEvent
	( (Object)this, additions,
	  regionEnd,  // just to the right of the character if this is a simple case
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.DELETED_CHARACTER:
      e = new ParserInputEvent
	( (Object)this, deletions,
	  regionStart,
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.ADDED_REGION:
      e = new ParserInputEvent
	( (Object)this, additions,
	  regionStart, regionEnd, 
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.DELETED_REGION:
      e = new ParserInputEvent
	( (Object)this, deletions,
	  regionStart, regionEnd, 
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.REPLACED_REGION:
      e = new ParserInputEvent
	( (Object)this, deletions, additions,
	  regionStart, regionEnd, 
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.REPLACED_UNEQUAL_REGIONS:
      e = new ParserInputEvent
        ( (Object)this, regionRemoved, regionAdded,
	  startOldRegion, endOldRegion,
	  startNewRegion, endNewRegion,
	  newCursorIndex, oldCursorIndex,
	  update, eventType, text );
      break;
    case ParserInputEvent.NO_CHANGE:
      break;
    default:
     }
    return e;
  }

  void issueParserInputEvent(ParserInputEvent e, int eventType) {
    if (debug)
      System.out.println(">>> " + e);
    Vector list = (Vector)listeners.clone();
    for (int i = 0; i < list.size(); i++ ) {
      ParserInputEventListener listener = (ParserInputEventListener)list.elementAt(i);
      switch (eventType) {
      case ParserInputEvent.CURSOR_CHANGE:
	listener.cursorPositionChanged(e);
	break;
      case ParserInputEvent.ADDED_CHARACTER:
	listener.characterAdded(e);
	break;
      case ParserInputEvent.DELETED_CHARACTER:
	listener.characterDeleted(e);
	break;
      case ParserInputEvent.ADDED_REGION:
	listener.regionAdded(e);
	break;
      case ParserInputEvent.DELETED_REGION:
	listener.regionDeleted(e);
	break;
      case ParserInputEvent.REPLACED_REGION:
	listener.regionReplaced(e);
	break;
      case ParserInputEvent.REPLACED_UNEQUAL_REGIONS:
	listener.replacedUnEqualRegions(e);
	break;
      case ParserInputEvent.NO_CHANGE:
	break;
	  default:
      }
    }
  }






  //------------ entry point when the Timer expires ------


  /* There has been some change since the last time we sent an event
   * off to the interface to the parser. We need to take a snapshot
   * of the current situation (the contents of this TextArea and the
   * position of the cursor), compare it to the last snapshot and
   * determine what the difference is in the terms that the standalone
   * parser on the G2 side understands (i.e. advances or retreats
   * w.r.t. it's model of what it is parsing), and package that up
   * as an event and send it off. 
   */
  @Override
  public void sendTextChangesToParser() {
    String text;
    synchronized ( this ) {
      setPendingTextChange(false);
      takeNewSnapshotOfTheText();
      promptsAreValid = true;
    }
    int eventType = classifyTextChangeEvent();

    boolean debugCheck = debug || debugKeyStrokes || debugMouseClicks || debugNewlineCounting;
    debugCheck = debugCheck || debugPrompts || debugUndo || debugDiffs;
    
    if (debugCheck)
      System.out.println("\n\n>>> Timer expired: " + 
			 ParserInputEvent.nameEvent(eventType) + " event");

    if ( eventType != ParserInputEvent.NO_CHANGE ) { // protection for the unexpected
      tTrace1("Sending a {0} ParserInputEvent to G2", 
	      ParserInputEvent.nameEvent(eventType));

      if ( !justMovedTheCursorToParsingErrorSite() )
	assembleAndIssueNextParserInputEvent(eventType);
    }

    resetTypingFlags();

  }




  //----------- simple subroutines of sendTextChangesToParser() ---------


  /* To support a record of what changed in this event, we'll need to
   * be able to compare the current text with the previous text.
   * Hence these records of the previous text and previous cursor indexes.
   * The 'index' position is relative to the string and will always
   * use a single \n as its line-separator. The 'cursor' position
   * is derived from getCaretPosition() and can be a \r\n combination 
   * depending on the value of the line-separator property. */
  private String lastTextSnapshot;
  private int lastIndexPosition;
  private int lastCursorPosition;

  private String textSnapshot;
  private int indexPosition;
  private int cursorPosition;


  /* Record the text and the (raw) cursor positions. */
  private String takeNewSnapshotOfTheText() {
    lastTextSnapshot = textSnapshot;
    textSnapshot = getText();
    lastCursorPosition = cursorPosition;
    cursorPosition = getCaretPosition();
    if (debugDiffs)
      System.out.println("Previous cursorpos = " + lastCursorPosition +
			 "  position now = " + cursorPosition);
    rationalizeNewCursorPosition(cursorPosition);
    return textSnapshot;
  }


  /* Convert the TextArea-based index of the cursor to the equivalent
   * string-based index by compensating for the extra characters
   * in the representation of the line-separator. */
  private int rationalizeNewCursorPosition(int newCursorPosition) {
    if (debugDiffs)
      System.out.println("Rationalizing: cursorPosition is " + newCursorPosition);
    lastIndexPosition = indexPosition;
    indexPosition = adjustedCursorPosition(newCursorPosition);
    if (debugDiffs)
      System.out.println("   adjusted to " + indexPosition +
			 "\nPrevious Indexpos = " + lastIndexPosition +
			 "  position now = " + indexPosition);
    return indexPosition;
  }
  


  //-------------------------------------------------------
  //---------- Classify the parserInputEvent --------------
  //-------------------------------------------------------

  /* If the content of the text hasn't changed, then we have two
   * possibilities depending on whether or not the position of the
   * cursor has changed. If it has, then the event must have been
   * cursor motion, otherwise, given the locations where the
   * pendingTextChange flag is raised, the only possibility is that a
   * non-printing character was typed, in which case we should
   * not interpret the change as an event for which we update the
   * parser. 
   */
  private int classifyTextChangeEvent() {
    initializeClassificationVariables();
    
    if ( lastTextSnapshot.length() == textSnapshot.length() ) {
      if (debugDiffs) {
    	  System.out.println("Same length");
      }
      if ( lastTextSnapshot.equals(textSnapshot) ) {
	if (debugDiffs) {
		System.out.println("Identical text");
	}
	boolean cursorPositionChanged = (cursorPosition != lastCursorPosition);
	if (debugDiffs)
	  System.out.println("Cursor position changed = " + cursorPositionChanged +
			     "\nRegion selected = " + regionSelected);
	if ( !cursorPositionChanged || regionSelected ) {
	  return ParserInputEvent.NO_CHANGE;
	}
	else
	  return ParserInputEvent.CURSOR_CHANGE;
      }
      else {
	if (debugDiffs)
	  System.out.println(" last = \"" + lastTextSnapshot + "\"" +
			     "\n  now = \"" + textSnapshot + "\"");
	scanTextSnapshotsForDifferences_sameLength(lastTextSnapshot, textSnapshot);
	return ParserInputEvent.REPLACED_REGION;
      }
    }
    else {
      int delta = textSnapshot.length() - lastTextSnapshot.length();
      // positive means there was an advance
      if ( delta > 0 ) {
	scanTextSnapshotsForDifferences_nowLonger(lastTextSnapshot, textSnapshot);
	if ( delta == 1
	     && !( regionAdded.length() > 1)  // likely redundant
	     && ( "".equals(regionRemoved) ) ) {
	  return ParserInputEvent.ADDED_CHARACTER;
	}
	else {
	  if ( !"".equals(regionRemoved) )
	    return ParserInputEvent.REPLACED_UNEQUAL_REGIONS;
	  else
	    return ParserInputEvent.ADDED_REGION;
	}
      }
      else { // a retreat
	scanTextSnapshotsForDifferences_nowShorter(lastTextSnapshot, textSnapshot);
	if ( delta == -1
	     && !( regionRemoved.length() > 1)
	     && ( "".equals(regionAdded) ) ) {
	  return ParserInputEvent.DELETED_CHARACTER;
	}
	else {
	  if ( !"".equals(regionAdded) )
	    return ParserInputEvent.REPLACED_UNEQUAL_REGIONS;
	  else
	    return ParserInputEvent.DELETED_REGION;
	}
      }
    }
  }

  /* These are for holding the information that classifyTextChangeEvent
   * establishes so that it can be packaged into the input event. */
  int startChangedRegion, endChangedRegion;
  int startOldRegion, endOldRegion, startNewRegion, endNewRegion;
  String regionWithDifferences, regionAdded, regionRemoved;

  private void initializeClassificationVariables() {
		startChangedRegion = -1;
		endChangedRegion = -1;
		startOldRegion = -1;
		endOldRegion = -1;
		startNewRegion = -1;
		endNewRegion = -1;
		regionWithDifferences = "";
		regionAdded = "";
		regionRemoved = "";
	  }


  void scanTextSnapshotsForDifferences_nowLonger(String before, String now) {
    if (debugDiffs)
      System.out.println("Calling differences: longer");
    scanTextsForDifferences(now, before, true, false);
  }

  void scanTextSnapshotsForDifferences_nowShorter(String before, String now) {
    if (debugDiffs)
      System.out.println("Calling differences: shorter");
    scanTextsForDifferences(before, now, false, false);
  }

  void scanTextSnapshotsForDifferences_sameLength(String before, String now) {
    if (debugDiffs)
      System.out.println("Calling differences: same");
    scanTextsForDifferences(now, before, false, true);
  }



  /* This algorithm operates over two snapshots of the text, one taken now
   * and one taken at the last time a parserInputEvent was issued. They are
   * analyzed in terms of their respective lengths (one is shorter, one longer)
   * plus a flag to say whether the change between snapshots has made the 
   * text longer or shorter. If they are the same length that is signalled
   * by another flag - replacement. (Though there are other cases where the
   * change involves the replacement of some of the text.)
   *   The algorighm consists of walking in from the ends of the two strings
   * looking for the first place one either end where the characters in the
   * two are different. We know there is a diffence somewhere because that
   * was checked for in the caller, classifyTextChangeEvent. 
   *   After we have determined the points where the two differ, we use the
   * flags to determine how to populate the instance variables that will
   * record the substrings involved: regionAdded and regionRemoved.
   * Further discriminations to put a name to the event (characterAdded,
   * regionReplaced, etc.) happen after this method returns.
   */
  void scanTextsForDifferences(String longer, String shorter, 
			       boolean gotBigger, boolean replacement ) {
    
    int shorterLength = shorter.length();
    int longerLength = longer.length();

    /* Look for an easy special case. We've added/deleted the entire text. */
    if ( shorterLength==0 ) {
      if ( gotBigger )
	regionAdded = longer;
      else
	regionRemoved = longer;
      startChangedRegion = 0;
      endChangedRegion = longer.length();
    }
    else {
      /* Step 1. Walk up the string from the beginning. Stop at the first place
       * where the characters in the two strings differ. */
      if (debugDiffsWalk)
	System.out.println(" longer(" + longer.length() + ") = \"" + longer + "\"" +
			   "\n shorter(" + shorter.length() + ") = \"" + shorter + "\"" +
			   "\n cursor is at " + indexPosition);
      for (int i = 0; i<shorter.length(); i++) {
	if (debugDiffsWalk)
	  System.out.println("At position " + i + " shorter = \"" + shorter.charAt(i) +
			     "\", longer = \"" + longer.charAt(i) + "\"");
	if ( longer.charAt(i) != shorter.charAt(i) ) {
	  startChangedRegion = i;
	  if (debugDiffsWalk)
	    System.out.println("Reached a difference walking up: " +
			       "\n  startChangedRegion = " + startChangedRegion);
	  break;
	}

	/* We assume that the cursor is positioned at one end or the other of
	 * the region where the texts differ. The reasoning is that large
	 * shifts in position will be done with the mouse and that the time
	 * to get to the mouse will exceed the timer limit (currently half a
	 * second), triggering an input event. Of course we will be completely
	 * wrong if they use the arrow keys to make their shift since pressing
	 * a key resets the timer. However, the effect of such a mistake will
	 * only be to make the region larger than it otherwise would be, and
	 * errors that don't lose information are ok. */
	if ( i == indexPosition ) {
	  startChangedRegion = i;
	  if (debugDiffs)
	    System.out.println("Reached the cursor walking up:" + 
			       "\n  startChangedRegion = " + startChangedRegion);
	  break;
	}
      }

      //------- Look for another boundary case --------

      if ( startChangedRegion == -1 ) {
	/* It didn't get reset inside that for-loop, which means that
	 * the strings were identical for the entire length of the shorter
	 * string and this event happened at the end of the string. */
	String delta = longer.substring(shorterLength, longerLength);
	if ( gotBigger )
	  regionAdded = delta;
	else
	  regionRemoved = delta;
	startChangedRegion = shorter.length();
	endChangedRegion = longer.length();
	if (debugDiffsWalk)
	  System.out.println("Went the whole length of the shorter string");
	return;
      }
      


      //------ Now walk down from the ends of the two strings.

      int l = longerLength - 1;
      int s = shorterLength - 1;
      // subtract 1 because charAt looks from the left

      if ( l == 0 )
	endChangedRegion = l;

      else {
	for (; s != -1;  --l, --s ) {
	  if (debugDiffsWalk)
	    System.out.println("shorter at " + s + " is \"" + shorter.charAt(s) + "\"" +
			       " longer at " + l + " is \"" + longer.charAt(l) + "\"");
			      
	  if ( longer.charAt(l) != shorter.charAt(s) ) {
	    endChangedRegion = l + 1;  // include the cell in the range
	    if (debugDiffsWalk)
	      System.out.println("Reached a difference walking down: " +
				 "\n   l = " + l + "  s = " + s +
				 "\n   endChangedRegion = " + endChangedRegion);
	    break;
	  }


	  /* Don't move leftwards of the start position.  This can happen on
	   * additions/deletions in the interior of the text. E.g. with
	   *   "f ()\nbegin\n\t\n end"  vs.
	   *   "f ()\nbegin\n\tcall  \n end"
	   * The start is at 13 (just before the tab). The longer text is length
	   * 23 and the shorter is 17. Walking back without this test will get
	   * you to 11 in the shorter text before they differ.  We want this to
	   * be seen as the addition/deletion that it is, so we have to include
	   * this test. */
	  if ( s == startChangedRegion ) {
	    endChangedRegion = l;
	    if (debugDiffsWalk)
	      System.out.println("Reached the start of the difference walking down:" +
				 "\n   l = " + l + "  s = " + s +
				 "\n   endChangedRegion = " + endChangedRegion);
	    break;
	  }

	}
      }

      //------ Save the results out to instance variables ---------
      //       (in lieu of multiple-value returns)
      
      /* For replacements we populate both the Added and Removed region 
       * variables. For simple add/deletes we populate just one or the
       * other depending on the value of gotBigger. */

      if ( replacement ) {
	/* If the change is the replacement of a some number of characters
	 * with an equal number of different characters, we determine what
	 * goes where according to the timing of the snapshots: a substring
	 * was removed from the previous snapshot and one was added to the
	 * current snapshot. Which is which is not encoded in the signature
	 * of this method, so instead we rely on the implicit facts established
	 * in our caller, scanTextSnapshotsForDifferences_sameLength. There
	 * the older snapshot is bound to shorter and the current one to
	 * longer. Of course if they ever got out of sync...  */
	if (debugDiffs)
	  System.out.println("The replacement flag is up.");

	regionAdded = longer.substring(startChangedRegion, endChangedRegion);
	regionRemoved = shorter.substring(startChangedRegion, endChangedRegion);
      }

      else {
	/* We can also have replacements if the two snapshots are of different
	 * sizes. This is easy to achieve when the person is writing over a
	 * selected region, e.g. they replace one number of characters with 
	 * a different number of characters. 
	 *   For the simple case, the algorithm used here to detect this is
	 * to take the value of the index into the shorter string set by the 
	 * walk down from the end and compare it to the value of the start index 
	 * that was set by the walk up from the beginning. If those two are identical
	 * then the edit was an insertion/deletion, otherwise it involved
	 * a replacement.
	 *   That test for a replacement is not valid if the user
	 * typed both some additions and some deletions in the same event.
	 * We use flags that are set in the InterpretKeystrokes inner class to 
	 * determine this.
	 */
	if (debugDiffs)
	  System.out.println("Checking for replacement in different length texts." +
			     "\n  startChangedRegion = " + startChangedRegion +
			     "\n  end index of shorter string = " + s +
			     "\n  thereWereAdditions = " + thereWereAdditions +
			     "\n  thereWereDeletions = " + thereWereDeletions );

	//--- is it a simple addition or deletion?
	if ( ( startChangedRegion == s )
	     && ( nothingWasTyped() // i.e. a cut or paste
		  || !( thereWereAdditions && thereWereDeletions )) ) {

	  if ( gotBigger ) {
	    regionAdded = longer.substring(startChangedRegion, endChangedRegion);
	    regionRemoved = "";
	  }
	  else {
	    regionRemoved = longer.substring(startChangedRegion, endChangedRegion);
	    regionAdded = "";
	  }
	}

	//--- no, it's a replacement
	else {
	  /* For ease of maintaince I'm renaming the variables that point to
	   * the snapshots. The interpretation, again, depends on the order
	   * of the arguments in the caller. The parameters to this method
	   * are longer, shorter. The callers use now, before. If the current 
	   * snapshot got bigger, then now is bound to longer. If it got 
	   * shorter, then now is bound to shorter.
	   */
	  String now, before;
	  int endNow, endBefore;  // remappings of s and l
	  if ( gotBigger ) {
	    now = longer; 
	    before = shorter;
	    endNow = l; 
	    endBefore = s; 
	  }
	  else {
	    now = shorter; 
	    before = longer;
	    endNow = s; 
	    endBefore = l; 
	  }

	  regionRemoved = before.substring(startChangedRegion, endBefore + 1);
	  regionAdded = now.substring(startChangedRegion, endNow + 1);

	  startOldRegion = startChangedRegion;
	  startNewRegion = startChangedRegion;
	  endOldRegion = endBefore + 1;
	  endNewRegion = endNow + 1;
	}

      } // end of populating from different length snapshots

    } // end of the 'walk in from the two ends' algorithm

    if (debugDiffs)
      System.out.println("End of difference calculation:" +
			 "\n  regionAdded = \"" + regionAdded + "\"" +
			 "\n  regionRemoved = \"" + regionRemoved + "\"" +
			 "\n  start = " + startChangedRegion +
			 "\n    end = " + endChangedRegion);

  } // end of scanTextsForDifferences





  //----------------- Variations on counting line separators ---------

  /* Utility used in several places to shift from TextArea-relative to
   * string-relative index values for the 'cursor'.  Given a cursor position
   * it returns the corresponding position in string-relative terms, taking
   * into account the possibility that the text area that the cursor reflects
   * can contain CRs in its line separators that have to be substracted out
   * in order to get the index for the corresponding string.
   */
  private int adjustedCursorPosition(int rawCursorPosition) {
    if (linebreakIsTwoCharacters) {
      if ( getCaretPositionIsStringBased )
	return rawCursorPosition;
      else {
	int adjustment = numberOfLineSeparatorsFromTheBeginning(rawCursorPosition);
	int adjustedPosition = cursorPosition - adjustment;
	return adjustedPosition;
      }
    }
    else
      return rawCursorPosition;
  }


  /* This is the opposite calculation. The code that calls this has been
   * working with a string, now it needs to convert its index into a
   * cursor-relative index. This time it adds to its index the number
   * of needed CRs in order to get an index that will be correctly located
   * once it appears on the screen.  
   * @args stringPosition  is the index to be corrected
   * @args caretPosition  is the index from which the number of
   *  interveening line separators will be counted 
   */
  private int adjustedStringPosition(int stringPosition, int referencePosition) {
    if (linebreakIsTwoCharacters) {
      if ( getCaretPositionIsStringBased )
	return stringPosition;
      else {
	int adjustment = numberOfLineSeparatorsFromTheBeginning(referencePosition);
	return stringPosition + adjustment;
      }
    }
    else
      return stringPosition;
  }
      


  private int convertStringPositionToCursorPosition(int stringPosition, String s) {
    if (linebreakIsTwoCharacters) {
      if ( getCaretPositionIsStringBased )
	return stringPosition;
      else {
	int adjustment = numberOfReturnCharactersInSubString(s, stringPosition);
	return stringPosition + adjustment;
      }
    }
    else
      return stringPosition;
  }
      



    /* This is needed to implement TextSource */
  @Override
  public int getReferencePosition() {
    return adjustedCursorPosition( getCaretPosition() );
  }
  


  /* The calculating part of adjustedCursorPosition, though it is also used
   * independently by routines that then make their own adjustment.
   * Review whether the users of this routine can made to use adjustedCursorPosition.
   * Note that this routine is careful about adjusting the effective cursor
   * position as it moves through the text, so it cannot casually be replaced
   * by either of the two counters that follow.
   */
  private int numberOfLineSeparatorsFromTheBeginning(final int cursorPosition) {
	int cursorIndex = cursorPosition;
    if (debugNewlineCounting)
      System.out.println("NL: counting NLs -- cursorPosition is " + cursorIndex);
    int count = 0;
    int priorNewline = 0;
    int nextNewline = textSnapshot.indexOf('\n', 0);
    if (debugNewlineCounting)
      System.out.println("NL: initial nextNewline is at " + nextNewline);
    while ( nextNewline != -1 ) {
      if ( cursorIndex < nextNewline )
	break;
      if ( cursorIndex == nextNewline ) {
	if (debugNewlineCounting)
	  System.out.println("NL: that is = the cursor, so stoping here");
	break;
      }
      count++;
      cursorIndex--;
      if (debugNewlineCounting)
	System.out.println("NL: incrementing count to " + count +
			   "\n    decrementing cursor position to " + cursorIndex);
      priorNewline = nextNewline + 1;  /* indexOf() does a >= */
      nextNewline = textSnapshot.indexOf('\n', priorNewline);
      if (debugNewlineCounting)
	System.out.println("NL: the nextNewline is at " + nextNewline);
    }
    return count;
  }



  private int numberOfReturnCharactersInSubString(String text, int stringPosition) {
    int count = 0;
    int priorNewline;
    int nextNewline = text.indexOf('\n', 0);
    while ( nextNewline != -1 ) {
      if ( nextNewline < stringPosition )
	++count;
      else
	break;
      priorNewline = nextNewline + 1;
      nextNewline = text.indexOf('\n', priorNewline);
    }
    return count;
  }

  /* Merge these after reviewing call sites. */

  int numberOfLineSeparatorsInString(String s) {
    int count = 0;
    int length = s.length();
    int priorNewline;
    int nextNewline = s.indexOf('\n', 0);
    while ( nextNewline != -1 ) {
      ++count;
      priorNewline = nextNewline + 1;
      nextNewline = s.indexOf('\n', priorNewline);
    }
    return count;
  }




  /* Syntactic sugar to implement the methods of TextSearchTarget */

  @Override
  public void showRegion(int mark, int dot) {
    setCaretPosition(dot);
    moveCaretPosition(mark); // leaves behind a caret 'mark' at the old positin
  }

  @Override
  public void replaceRegion(String replacementText, int startPosition, int endPosition) {
    replaceRange(replacementText, startPosition, endPosition);
  }



}  // final parenthesis
