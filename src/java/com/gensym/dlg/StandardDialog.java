/*
 *   Copyright (C) 1986-2017 Gensym Corporation. All Rights Reserved.
 *
 * 	 StandardDialog.java
 *
 */
package com.gensym.dlg;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Insets;
import java.awt.Point;
import java.awt.event.*;
import com.gensym.message.*;
import com.gensym.core.UiApplication;
import java.util.*;
import javax.swing.*;

/**
 * An abstract Class that encapsulates a typical Dialog
 * with a component in the center that users interact with
 * and command buttons at the bottom to indicate the
 * completion of the task. It also allows for a
 * StandardDialogClient listener that is notified of the
 * command events that are generated on the dialog.
 *
 * @author vkp
 * @version 1.1 4/28/98
 *
 */
public abstract class StandardDialog extends JDialog implements CommandConstants {

  private StandardDialogClient dlgClient;
  private CommandPanel cmdPanel;
  private Component dlgComponent;
  private int reasonForCallback;
  private static volatile Frame theFrame;
  private transient Vector validators;

  /**
   * Constant for left button alignment
   */
  public static final int LEFT   = FlowLayout.LEFT;

  /**
   * Constant for right button alignment
   */
  public static final int CENTER = FlowLayout.CENTER;

  /**
   * Constant for center button alignment
   */
  public static final int RIGHT  = FlowLayout.RIGHT;

  private static Resource i18n = Resource.getBundle("com.gensym.resources.Messages");

  /**
   * Constructor accessible to subclasses that allows the creation
   * of a StandardDialog. The component passed in is placed in the
   * center of the dialog. Buttons are generated for each of the
   * requrested command codes and displayed at the bottom of
   * the dialog. The dialog is displayed in the center of the parent
   * Frame, if possible.
   * @param parent the parent Frame. May be null.
   * @param title the String to be displayed in the title bar
   * @param isModal whether this dialog is managed modally or not
   * @param btnLabels the Strings that represent the button labels
   * @param cmdCodes the codes generated by the buttons. The number of codes
   *    must match the number of button labels passed in.
   * @param x the Component that is placed in the central display area
   * @param client a StandardDialogClient that will be notified of all
   *    command events generated from this dialog. You can pass in
   *    null if no notification is required, which is typically the
   *    case for a simple modal dialog.
   * @see #setVisible
   * @see #getButtonAlignment
   */
  protected StandardDialog (Frame parent,
			    String title,
			    boolean isModal,
			    String[] btnLabels,
			    int[] cmdCodes,
			    Component x,
			    StandardDialogClient client) {
    super (parent == null ? getFrame() : parent,
	   title,
	   isModal);
    dlgClient = client;
    dlgComponent = x;
    getContentPane().setLayout (new BorderLayout ());
    ActionListener cmdBtnListener = new ActionListener () {
      @Override
      public void actionPerformed(ActionEvent e) {
	CommandButton cmdSource = (CommandButton)e.getSource ();
	dispatchCallback (cmdSource.getCommandCode ());
      }
    };
    if (x != null)
      getContentPane().add (x, BorderLayout.CENTER);
    if (btnLabels != null) {
      cmdPanel = new CommandPanel (btnLabels, cmdCodes, cmdBtnListener, getButtonAlignment (), forceButtonsToEqualSize());
      getContentPane().add (cmdPanel, BorderLayout.SOUTH);
    }
    addWindowListener (new StandardDialogListener ());
    pack();
  }

  /**
   * @undocumented
   */
  protected JPanel getCommandPanel() {
    return cmdPanel;
  }
  
  /**
   * @undocumented
   * Does anybody need access to this?-vkp, 4/28/98 
   * yduj: 11/15/00, yes, if your client is an inner class, then if you are
   * using the JDK 1.3 compiler, then you cannot pass it as an argument to the
   * super of your constructor, but must set it after all of the supers have
   * returned
   */
  protected void setClient (StandardDialogClient client) {
    dlgClient = client;
  }

  /**
   * The label for an OK button
   */
  public static final String OK_LABEL      = i18n.getString ("okButtonLabel");

  /**
   * The label for an OK button
   */
  public static final String CLOSE_LABEL      = i18n.getString ("closeButtonLabel");

  /**
   * The label for a CANCEL button
   */
  public static final String CANCEL_LABEL  = i18n.getString ("cancelButtonLabel");


  /**
   * The label for an APPLY button
   */
  public static final String APPLY_LABEL   = i18n.getString ("applyButtonLabel");


  /**
   * The label for an YES button
   */
  public static final String YES_LABEL     = i18n.getString ("yesButtonLabel");


  /**
   * The label for an NO button
   */
  public static final String NO_LABEL      = i18n.getString ("noButtonLabel");


  /**
   * The label for an DISMISS button
   */
  public static final String DISMISS_LABEL = i18n.getString ("dismissButtonLabel");


  /**
   * The label for an HELP button
   */
  public static final String HELP_LABEL    = i18n.getString ("helpButtonLabel");

  /*
  private static final String[] OKNames = new String[] {okBtnLabel},
                                OKCancelNames = new String[] {okBtnLabel, cancelBtnLabel},
                                OKCancelApplyNames = new String[] {okBtnLabel, cancelBtnLabel, applyBtnLabel};

  private static final int[] OKCodes = new int[] {OK},
			     OKCancelCodes = new int[] {OK, CANCEL},
                             OKCancelApplyCodes = new int[] {OK, CANCEL, APPLY};

  private static String[] getBtnNames (int numButtons) {
    if (numButtons == 1)
      return OKNames;
    else if (numButtons == 2)
      return OKCancelNames;
    else if (numButtons == 3)
      return OKCancelApplyNames;
    else
      throw new IllegalArgumentException (numButtons + " is not a standard button configuration.");
  }

  private static int[] getBtnCodes (int numButtons) {
    if (numButtons == 1)
      return OKCodes;
    else if (numButtons == 2)
      return OKCancelCodes;
    else if (numButtons == 3)
      return OKCancelApplyCodes;
    else
      throw new IllegalArgumentException (numButtons + " is not a standard button configuration.");
  }
  */

  private static String[] getBtnNames (int numButtons) {return null;}
  private static int[] getBtnCodes (int numButtons) {return null;}

  /**
   * Determines the alignment of the command buttons at the
   * bottom of the StandardDialog
   * @return a code indicating the preferred position of the buttons
   * @see #LEFT
   * @see #CENTER
   * @see #RIGHT
   */
  protected int getButtonAlignment () {
    return RIGHT;
  }

  /**
   * @deprecated As of version 1.1, replaced by <code>getJButton()</code>.
   */
  protected java.awt.Button getButton (int code) {
    throw new Error("Do not use com.gensym.dlg.Standard.getButton()"+
		    " use com.gensym.dlg.StandardDialog.getJButton() instead.");
  }

  /**
   * Retrieves a command Button by code
   * @code one of the codes passed to the constructor
   * @return the Button that generates that code
   */
  protected JButton getJButton (int code) {
    return cmdPanel.getButton (code);
  }    
  /**
   * Set the button for the user's acceptance of the dialog.
   * This button will be highligted to indicate its special
   * behavior. In order for this to work, the standard key
   * interpreter must be added as a KeyListener to every
   * <code>Component</code> within the <code>StandardDialog</code>
   * that can receive focus.
   * @see #getStandardKeyInterpreter
   * @see #setCancelButton
   */
  protected void setDefaultButton (int code) {
    cmdPanel.setDefaultButton (code);
  }

  /**
   * Set the button for the user's cancellation of the dialog.
   * In order for this to work, the standard key
   * interpreter must be added as a KeyListener to every
   * <code>Component</code> within the <code>StandardDialog</code>
   * that can receive focus.
   * @see #getStandardKeyInterpreter
   * @see #setDefaultButton
   */
  protected void setCancelButton (int code) {
    cmdPanel.setCancelButton (code);
  }

  /**
   * Retrieves the component placed in the center of
   * the dialog
   * @return the component passed to the constructor
   */
  protected Component getDialogComponent () {
    return dlgComponent;
  }

  /**
   * Sets the component placed in the center of the dialog.
   */
  protected void setDialogComponent (Component x) {
    dlgComponent = x;
  }

  /**
   * Overrides the setVisible method so as to center the dialog
   * in the parent Frame. If there is no parent Frame, it attempts
   * to center the dialog on the users screen.
   * @param showQ true if the dialog is being displayed, false
   *    if it is being hidden
   */
  @Override
  public void setVisible (boolean showQ) {  // Fixes bug under Win95
    if (showQ) {
      Dimension frameSize = getParent().getSize();
      Point     frameLoc  = getParent().getLocation();
      Dimension mySize    = getSize();
      
      int x = Math.max(0, frameLoc.x + (frameSize.width/2) -(mySize.width/2));
      int y = Math.max(0,frameLoc.y + (frameSize.height/2)-(mySize.height/2));
     
      setBounds (x, y, mySize.width, mySize.height);
      focusDefaultComponent();
    }
    super.setVisible (showQ);
  }

  protected void focusDefaultComponent()
  {
    if (cmdPanel != null)
      cmdPanel.getFocus();
  }

  /**
   * Returns a KeyListener that will propagate the events
   * the appropriate <code>Button</code>. Subclasses
   * should hook it up to every <code>Component</code>
   * within the containment heirarchy that can
   * receive keyboard focus.
   * @see #setDefaultButton
   * @see #setCancelButton
   */
  public KeyListener getStandardKeyInterpreter () {
    return cmdPanel.standardKeyInterpreter;
  }

  /**
   * Dispatches a callback for the command code specified.
   * Subclasses can use this to generate events on
   * appropriate user gestures.
   * @param code the callback notification code
   */
  protected void dispatchCallback (int code) {
    reasonForCallback = code;
    if (!isValid(code)){ 
    	return;
    }
    
    if (dlgClient != null){
      dlgClient.dialogDismissed (this, code);
    }
    
    boolean isYesNo = code == YES || code == NO;
    boolean isOkCancel = code == OK || code == CANCEL;
    
    if (isYesNo || isOkCancel || code == DISMISS || code == CLOSE){
      dispose ();
    }
  }

  /**
   * Indicates whether this dialog was cancelled by the user.
   * In the notification callback, StandardDialogClients can
   * use the return value of this method to determine if they
   * need to take any action at all.
   * @return true if the user cancelled the dialog, false otherwise
   */
  public boolean wasCancelled () {
    return (reasonForCallback == CANCEL);
  }

  /* Experiment
  public void invalidate () {
    super.invalidate ();
    //pack ();
  }*/

  class StandardDialogListener extends java.awt.event.WindowAdapter {

    @Override
    public void windowClosed(WindowEvent e) {
      // workaround to Swing bug:
      // 4189244: Swing Popup menu is not being refreshed (cleared) under a Dialog
      getOwner().repaint();
    }

    @Override
    public void windowClosing (WindowEvent e) {
      dispatchCallback (CANCEL);
    }
  }

  /**
   * @deprecated
   * @undocumented
   */
  public static void registerFrame (Frame f) {
  }

  private static java.awt.Dimension screenDisplaySize = java.awt.Toolkit.getDefaultToolkit().getScreenSize ();

  private static Frame getFrame () {
    Frame appFrame = UiApplication.getCurrentFrame ();
    if (appFrame != null)
      return appFrame;
    if (theFrame == null) {
      synchronized (StandardDialog.class) {
        if (theFrame == null) {
          theFrame = new MyFrame ("Centering Frame");
          theFrame.setBounds (screenDisplaySize.width/2, screenDisplaySize.height/2, 0, 0);
          theFrame.setVisible (true);
          try {
              Thread.sleep (100);
          } catch (InterruptedException ie) {} // Stupid bug! Frame remains visible otherwise
          theFrame.setVisible (false);
        }
      }
    }
    
    //System.out.println ("Made dummy Frame : " + theFrame);
    return theFrame;
  }

  public synchronized void removeDialogValidator(StandardDialogValidator validator)
  {
    if(validators != null && validators.contains(validator))
    {
      Vector v = (Vector) validators.clone();
      v.removeElement(validator);
      validators = v;
    }
  }

  public synchronized void addDialogValidator(StandardDialogValidator validator)
  {
    Vector v = validators == null ? new Vector(2) : (Vector) validators.clone();
    if(!v.contains(validator))
    {
      v.addElement(validator);
      validators = v;
    }
  }

  protected synchronized boolean isValid(int cmdCode)
  {
    boolean isValid = true;
    if(validators != null)
    {
      Vector v = validators;
      int count = v.size();
      for (int i = 0; (i < count) && (isValid); i++)
      {
        isValid = ((StandardDialogValidator)v.elementAt(i)).isDialogValid(this, cmdCode);
      }
    }
    return isValid;
  }

  protected boolean forceButtonsToEqualSize()
  {
    return false;
  }


}

class MyFrame extends Frame {

  MyFrame (String title) {
    super (title);
  }

  public void setVisible0 (boolean visibleState) {
    super.setVisible (visibleState);
    System.out.println ("Visible State = " + visibleState);
    Thread.dumpStack ();
    try { 
        Thread.sleep (2000); 
    } catch (Exception e) {}
  }
}

class CommandPanel extends JPanel {

  //private static final Insets stdCmdPanelInsets = new Insets (2, 0, 0, 0);
  private static final Insets stdCmdPanelInsets = new Insets (2, 5, 5, 5);
  private JButton[] btns;
  private int[] btnCodes;
  private static final boolean isWindows;
  private JButton desiredDefault;
  private JButton defaultBtn;
  private JButton cancelBtn;
  KeyListener standardKeyInterpreter = new KeyAdapter () {
    @Override
    public void keyPressed (KeyEvent kEvt) {
      int keyCode = kEvt.getKeyCode ();
      // not sure about which key codes to use here. These were empirically chosen
      if (keyCode == KeyEvent.VK_ENTER && defaultBtn != null)
	((CommandButton)defaultBtn).fire ();
      else if (keyCode == KeyEvent.VK_ESCAPE && cancelBtn != null)
	((CommandButton)cancelBtn).fire ();
    }
  };

  static {
    String osName = System.getProperty ("os.name");
    isWindows = !(osName == null || !osName.equals ("Windows NT"));
  }

  CommandPanel (String[] cmdNames, int[] cmdCodes, ActionListener listnr, int alignment, boolean forceEqualSize) {
    setLayout (new FlowLayout (alignment));
    int numButtons = cmdNames.length;
    btns = new JButton [numButtons];
    btnCodes = cmdCodes;
    Dimension maxSize = new Dimension(0,0);
    for (int i=0; i<numButtons; i++) {
      CommandButton cb = new CommandButton (this, cmdNames[i], cmdCodes[i]);
      cb.addActionListener (listnr);
      cb.addKeyListener (standardKeyInterpreter);
      btns[i] = cb;
      if (cb.getPreferredSize().width > maxSize.width)
        maxSize.width = cb.getPreferredSize().width;
      if (cb.getPreferredSize().height > maxSize.height)
        maxSize.height = cb.getPreferredSize().height;
      add (cb);
    }
    if (forceEqualSize)
    for (int i=0; i<numButtons; i++) {
      btns[i].setPreferredSize(maxSize);
    }
  }

  JButton getButton (int code) {
    for (int i=0; i<btnCodes.length; i++)
      if (code == btnCodes[i])
	return btns[i];
    return null;
  }

  void getFocus () {
    if (btns.length > 0)
      btns[0].requestFocus ();
  }
  
  @Override
  public void paint (Graphics g) {
    super.paint(g);
    if (!isWindows) {
      Dimension d = getSize ();
      g.setColor (Color.gray);
      g.drawLine (0, 0, d.width, 0);
      g.setColor (Color.black);
      g.drawLine (0, 1, d.width, 1);
    }
  }
  
  @Override
  public Insets getInsets () {
    return stdCmdPanelInsets;
  }

  void setDefaultButton (int code) {
    if (defaultBtn != null && defaultBtn instanceof CommandButton)
      ((CommandButton)defaultBtn).setDefaultButton(false);
    desiredDefault = getButton (code);
    defaultBtn = desiredDefault;
    if (defaultBtn instanceof CommandButton)
      ((CommandButton)defaultBtn).setDefaultButton(true);
  }

  void setCancelButton (int code) {
    cancelBtn = getButton (code);
  }
}

class CommandButton extends JButton {

  private int code;
  private boolean isDefaultButton = false;

  CommandButton (CommandPanel panel, String label, int code) {
    super (label);
    this.code = code;
  }

  int getCommandCode () {
    return code;
  }

  void enable (int code) {
  }

  void disable (int code) {
  }

  void fire () {
    if (isEnabled ())
      fireActionPerformed (new ActionEvent (this, ActionEvent.ACTION_PERFORMED, getActionCommand ()));
    else
      java.awt.Toolkit.getDefaultToolkit().beep();
  }

  void setDefaultButton(boolean isDefaultButton){
    this.isDefaultButton = isDefaultButton;
  }

  @Override
  public boolean isDefaultButton(){
    return isDefaultButton;
  }
}



