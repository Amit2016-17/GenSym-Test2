/*
 *   Copyright (C) 1986-2017 Gensym Corporation. All Rights Reserved.
 *
 * 	 SelectionDialog.java
 *
 */
package com.gensym.dlg;

import java.awt.BorderLayout;
import java.awt.Frame;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;

import javax.swing.DefaultListModel;
import javax.swing.JButton;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.ListCellRenderer;


/**
 * A Class that implements a simple selection dialog.
 * It presents the user with a list from which
 * to make a selection. Callers can control many
 * attributes of this list, such as whether or not
 * it allows multiple selection, and its initial
 * selection.
 *
 * @author vkp
 * @version 1.1 4/28/98 Added Javadoc and cleaned up code
 */
public class SelectionDialog extends StandardDialog implements CommandConstants {

  private JButton okButton;
  private SelectionPanel osp; 
  private boolean requireSelection;
  private boolean wasCancelled = false;
  private StandardDialogClient dlgClient;

  /**
   * Constant to indicate that there be no initial
   * element selected in the dialog.
   */
  public static final int NO_SELECTION = -1;

  /**
   * The preferred constructor for SelectionDialog. In addition to
   * standard arguments like parent Frame, title, modality, and
   * the notification client, callers can specify the initial
   * contents of the list that is created, and some attributes
   * of the presentation. It generates an OK and Cancel button
   * for the user to commit or cancel their selection.
   * @param parent the parent Frame of the Dialog
   * @param title the text to present in the title bar
   * @param isModal whether the Dialog is modal or not
   * @param prompt the text that is displayed in the dialog
   *    to prompt the user to make the selection
   * @param allowMultipleSelection true if multiple selection
   *    is allowed, false otherwise
   * @param initialSelection the index for the initially selected
   *    item in the list. Use NO_SELECTION to indicate that
   *    there be no initial selection
   * @param requireSelection if true, then then any OK button
   *    on the dialog is not enabled unless there is a current
   *    selection in the list.
   * @param client a StandardDialogClient that is notified of
   *    command events generated on the Dialog.
   */
  public SelectionDialog (Frame parent, String title, boolean isModal,
			  String prompt,
			  String[] initialValues,
			  boolean allowMultipleSelection, int initialSelection,
			  boolean requireSelection, StandardDialogClient client) {
    this(parent, title, isModal, prompt, initialValues, null, allowMultipleSelection, initialSelection, 
	 requireSelection, client);
  }

  public SelectionDialog (Frame parent, String title, boolean isModal,
			  String prompt,
			  Object[] initialValues,
			  ListCellRenderer cellRenderer,
			  boolean allowMultipleSelection, int initialSelection,
			  boolean requireSelection, StandardDialogClient client) {
    this (parent,
	  title,
	  isModal,
	  prompt,
	  initialValues,
	  cellRenderer,
	  allowMultipleSelection,
	  initialSelection,
	  requireSelection,
	  new String[] {OK_LABEL, CANCEL_LABEL},
	  new int[] {OK, CANCEL},
	  client);
    setDefaultButton (OK);
    setCancelButton (CANCEL);
  }


  /**
   * The full featured constructor for SelectionDialog. In addition to
   * standard arguments like parent Frame, title, modality, and
   * the notification client, callers can specify the initial
   * contents of the list that is created, and some attributes
   * of the presentation. The number, type, and labels of the
   * buttons generated for the Dialog are also controlled
   * by the arguments to this constructor.
   * @param parent the parent Frame of the Dialog
   * @param title the text to present in the title bar
   * @param isModal whether the Dialog is modal or not
   * @param prompt the text that is displayed in the dialog
   *    to prompt the user to make the selection
   * @param initialValues the initial values to display in the selection
   * @param allowMultipleSelection true if multiple selection
   *    is allowed, false otherwise
   * @param initialSelection the index for the initially selected
   *    item in the list. Use NO_SELECTION to indicate that
   *    there be no initial selection
   * @param requireSelection if true, then then any OK button
   *    on the dialog is not enabled unless there is a current
   *    selection in the list.
   * @param buttonLabels a String array of the labels for the
   *    buttons on the Dialog
   * @param cmdCodes an array of integers representing the
   *    codes that will be generated by the command buttons
   * @param client a StandardDialogClient that is notified of
   *    command events generated on the Dialog.
   */
  protected SelectionDialog (Frame parent, String title, boolean isModal,
			     String prompt,
			     String[] initialValues,
			     boolean allowMultipleSelection, int initialSelection,
			     boolean requireSelection, 
			     String[] buttonLabels, int[] cmdCodes,
			     StandardDialogClient client) {
    this(parent, title, isModal, prompt, initialValues, null, allowMultipleSelection, initialSelection,
	 requireSelection, buttonLabels, cmdCodes, client);
  }

  protected SelectionDialog (Frame parent, String title, boolean isModal,
			     String prompt,
			     Object[] initialValues,
			     ListCellRenderer cellRenderer,
			     boolean allowMultipleSelection, int initialSelection,
			     boolean requireSelection, 
			     String[] buttonLabels, int[] cmdCodes,
			     StandardDialogClient client) {
    super (parent,
	   title,
	   isModal,
	   buttonLabels,
	   cmdCodes,
	   new SelectionPanel (prompt, initialValues, cellRenderer,
			       allowMultipleSelection, initialSelection),
	   client);
    
    okButton = getJButton (OK);
    osp = (SelectionPanel) getDialogComponent ();
    osp.setKeyInterpreter (getStandardKeyInterpreter ());
    osp.addSelectionListener (new SelectionListener () {
      @Override
      public void itemSelected (SelectionEvent se) {
	if (okButton != null){
	  boolean hasSelection = se.hasSelection;
	  boolean okAvailable = okButton.isEnabled ();
	  if ((hasSelection && !okAvailable) ||
	      (!hasSelection && okAvailable))
	    okButton.setEnabled (!okAvailable);
	}
      }
      @Override
      public void itemChosen (SelectionEvent se) {
	if (!osp.allowMultipleSelection)
	  dispatchCallback (OK);
      }
    });
    if (initialSelection < 0 && requireSelection)
      okButton.setEnabled (false);
    this.requireSelection = requireSelection;
    dlgClient = client;
    pack ();
  }

  @Override
  public void setDefaultButton  (int code) {
    super.setDefaultButton (code);
  }

  @Override
  public void setCancelButton (int code) {
    super.setCancelButton (code);
  }

  /**
   * @undocumented
   */
  public static void main (String[] args) {
    
    Frame f = new MyTestFrame ();
    int TEST_COUNT = 48;
    //f.setSize (500, 500);
    //f.show ();
    /*
    String[] entries = {"Choice0", "Choice1", "Choice2", "Choice3", "Choice4",
			"Choice5", "Choice6", "Choice7", "Choice8", "Choice9",
			"Choice10", "Choice11", "Choice12", "Choice13", "Choice14"};
			*/
    String[] entries = new String [TEST_COUNT];
    for (int i=0; i<TEST_COUNT; i++)
      entries[i] = "Choice " + i;
    long t0 = System.currentTimeMillis ();
    SelectionDialog o = new SelectionDialog (f, "Choose One", false, "Choose from the list", entries, true,  -1, true, (StandardDialogClient)f);
    long t1 = System.currentTimeMillis ();
    System.out.println ("Took " + (t1 - t0) + "ms");
    t0 = System.currentTimeMillis ();
    o = new SelectionDialog (f, "Choose One", true, "Choose from the list", entries, true,  -1, true, (StandardDialogClient)f);
    t1 = System.currentTimeMillis ();
    System.out.println ("Took " + (t1 - t0) + "ms");
    o.setVisible (true);
  }

  /**
   * Retrieves the result of a single selection dialog
   * @return the index of the selected item in the list, if
   *    one exists, -1 otherwise
   */
  public int getResult () {
    return osp.getSelectedIndex ();
  }

  /**
   * Retrieves the results of a multiple selection dialog
   * @return an integer array of length >= 0 containing
   *    the indices of the selected items in the list
   */
  public int[] getResults () {
    return osp.getSelectedIndexes ();
  }

  /**
   * Retrieves the results of a multiple selection dialog
   * @return an object array of length >= 0 containing
   *    the selected items in the list
   */
  public Object[] getSelectedItems(){
    return osp.getSelectedItems();
  }

  /**
   * Retrieves the result of a single selection dialog
   * @return the selected item in the list, if
   *    one exists, null otherwise
   */
  public Object getSelectedItem(){
    return osp.getSelectedItem();
  }

  public JList getList() {
    return osp.jlistControl;
  }

  @Override
  protected void finalize () {
    //dispose (); //This causes all sorts of problems in 1.1.6
  }

}

class MyTestFrame extends Frame implements StandardDialogClient {

  public void dialogDismissed (StandardDialog d) {
    SelectionDialog osd = (SelectionDialog)d;
    //System.out.println ("Dialog was dismissed!");
    int x = osd.getResult ();
    //System.out.println (" #" + x + " was selected.");
    int y[] = osd.getResults ();
    //System.out.print (" >> Multiple #");
    for (x=0; x<y.length; x++) {
      //System.out.print (y[x] + ", ");
    }
    //System.out.println (" were selected.");
    System.exit (0);
  }

  @Override
  public void dialogDismissed (StandardDialog d, int code) {
    SelectionDialog osd = (SelectionDialog)d;
    //System.out.println ("Dialog was dismissed! with code = " + code);
    int x = osd.getResult ();
    //System.out.println (" #" + x + " was selected.");
    int y[] = osd.getResults ();
    //System.out.print (" >> Multiple #");
    for (x=0; x<y.length; x++) {
      //System.out.print (y[x] + ", ");
    }
    //System.out.println (" were selected.");
    System.exit (0);
  }
}

interface SelectionListener {
  void itemSelected (SelectionEvent e);
  void itemChosen (SelectionEvent e);
}

class SelectionEvent extends java.awt.AWTEvent {
  static final int SELECTED = 0;
  static final int CHOSEN   = 1;
  boolean hasSelection;
  SelectionEvent (Object src, int id, boolean hasSelection) {
    super (src, id);
    this.hasSelection = hasSelection;
  }
}

class KeySelector implements java.awt.event.KeyListener {

  String[] entries;
  JList jlist;
  private int invalidationLag = 250; // ms
  private long lastKeyTimeStamp;
  private char lastKeyChar;
  private int currentIndex = -1;
  private int pendingCharCount = 0;
  private int numentries;
  private static final String FAILURE = "\uFFFF";
  private String currentlyMatchedString = "";
  private int lastKeyCode;

  KeySelector (JList listComponent, String[] entries) {
    jlist = listComponent;
    this.entries = entries;
    numentries = entries.length;
  }

  private int getIndex () {
    return jlist.getSelectedIndex ();
  }

  private void setIndex (int index) {
      jlist.setSelectedIndex (index);
      jlist.ensureIndexIsVisible (index);
  }

  @Override
  public void keyTyped (java.awt.event.KeyEvent e) {
    //System.out.println ("Typed : " + e);
    currentIndex = getIndex ();
    long keyTimeStamp = e.getWhen ();
    boolean continueSelection = (keyTimeStamp - lastKeyTimeStamp) < invalidationLag;
    lastKeyTimeStamp = keyTimeStamp;
    char keyChar = e.getKeyChar ();
    if (lastKeyCode != java.awt.event.KeyEvent.VK_ENTER &&
	lastKeyCode != java.awt.event.KeyEvent.VK_SPACE)
      handleSelectionKey (keyChar, continueSelection);
    lastKeyChar = keyChar;
  }

  @Override
  public void keyPressed (java.awt.event.KeyEvent e) {
    lastKeyCode = e.getKeyCode ();
  }

  @Override
  public void keyReleased(java.awt.event.KeyEvent e) {}

  private void handleSelectionKey (char keyChar, boolean continueSelection) {
    //System.out.println ("Key -> " + keyChar + "(" + continueSelection + ")");
    int index;
    if ((keyChar == lastKeyChar) || !continueSelection) {
      index = findNextIndex (keyChar);
      if ((keyChar == lastKeyChar) && continueSelection)
	pendingCharCount++;
      else
	pendingCharCount = 1;
    } else {
      //System.out.println ("    cms = <" + currentlyMatchedString + "> pending = " + pendingCharCount);
      if (FAILURE.equals(currentlyMatchedString))
	return;
      if (currentlyMatchedString.length () == 0)
	currentlyMatchedString = flushPendingChars ();
      String newMatch = currentlyMatchedString + keyChar;
      index = findNextIndex (newMatch);
    }
    if (index >= 0)
      setIndex (index);
    else {
      if (keyChar != ' ' && keyChar != '\n')
	java.awt.Toolkit.getDefaultToolkit ().beep ();
    }

  }

  private String flushPendingChars () {
    //System.out.println ("  Pending Chars = " + pendingCharCount);
    char[] characters = new char[pendingCharCount];
    for (;--pendingCharCount >= 0;) {
      //System.out.println ("Filling in #" + pendingCharCount);
      characters [pendingCharCount] = lastKeyChar;
    }
    String genString = new String (characters);
    return genString;
  }

  private int findNextIndex (char keyChar) {
    currentlyMatchedString = "";
    int matchIndex = -1;
    int searchIndex = currentIndex;
    for (int i=numentries; i-->0;) {
      searchIndex++;
      if (searchIndex == numentries)
	searchIndex = 0;
      if (entries[searchIndex].charAt (0) == keyChar) {
	matchIndex = searchIndex;
	break;
      }
    }
    //System.out.println ("    findByChar (" + keyChar + ") = " + matchIndex);
    return matchIndex;
  }

  private int findNextIndex (String matchString) {
    int matchIndex = -1;
    int searchIndex = currentIndex;
    currentlyMatchedString = FAILURE;
    int numChars = matchString.length ();
    //System.out.println ("    fbs from #" + searchIndex + " = " + entries[searchIndex]);
    for (int i=numentries; i-->0;) {
      if (entries[searchIndex].substring (0, numChars).equals (matchString)) {
	matchIndex = searchIndex;
	break;
      }
      searchIndex++;
      if (searchIndex == numentries)
	searchIndex = 0;
    }
    currentlyMatchedString = matchString;
    //System.out.println ("    findByString (" + matchString + ") = " + matchIndex + "(" + entries [matchIndex] + ")");
    return matchIndex;
  } 
}

class SelectionPanel extends JPanel {

  private static final int THRESHOLD = 10000;

  protected javax.swing.JList jlistControl; // changed by bbush, may 08, 2000 - made it protected
  SelectionListener listener;
  boolean allowMultipleSelection;

  SelectionPanel (String prompt, Object[] entries, ListCellRenderer cellRenderer,
		  boolean allowMultipleSelection, int initialSelection) {
    this.allowMultipleSelection = allowMultipleSelection;
    int numEntries = entries.length;
    
//    jlistControl = new javax.swing.JList (entries); // this has been changed
    DefaultListModel model = new DefaultListModel();
    for(int looper = 0; looper < entries.length; looper++) {
      model.addElement(entries[looper]);
    }
    jlistControl = new javax.swing.JList (model);
    if (cellRenderer != null)
      jlistControl.setCellRenderer(cellRenderer);
    jlistControl.setVisibleRowCount (7); // Preferred Size
    jlistControl.setSelectionMode (allowMultipleSelection ?
				   javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION :
				   javax.swing.ListSelectionModel.SINGLE_SELECTION);
    javax.swing.JScrollPane scrollPane = new javax.swing.JScrollPane (jlistControl);
	
    if ((initialSelection >= 0) && (initialSelection < numEntries))
      jlistControl.setSelectedIndex (initialSelection);
    jlistControl.addListSelectionListener (new JListSelectionListener ());
    jlistControl.addMouseListener (new JListMouseListener ());
    if (entries instanceof String[])//can we do better?
      jlistControl.addKeyListener (new KeySelector (jlistControl, (String[])entries));

    scrollPane.setSize (120, 150); 
    setLayout (new BorderLayout (0, 5));
    if (prompt != null)
      add (new JLabel (prompt, JLabel.LEFT), BorderLayout.NORTH);
    add (scrollPane, BorderLayout.CENTER);
  }

  void setKeyInterpreter (java.awt.event.KeyListener adapter) {
    jlistControl.addKeyListener (adapter);
  }

  @Override
  public Insets getInsets () {
    return new Insets (15, 20, 15, 20);
  }

  int getSelectedIndex () {
    return jlistControl.getSelectedIndex ();
  }
  
  int[] getSelectedIndexes () {
    return jlistControl.getSelectedIndices ();
  }

  Object[] getSelectedItems(){
    Object[] values = jlistControl.getSelectedValues();
    return values == null ? new Object[0] : values;
  }

  Object getSelectedItem(){
    return jlistControl.getSelectedValue();
  }

  void addSelectionListener (SelectionListener l) {
    if (listener != null)
      throw new IllegalStateException ("Too many listeners");
    listener = l;
  }

  void removeSelectionListener (SelectionListener l) {
    if (listener != null && listener.equals(l))
      listener = null;
  }

  void fireSelectionEvent (int id, boolean hasSelection) {
    SelectionEvent se = new SelectionEvent (this, id, hasSelection);
    switch (id)
      {
      case SelectionEvent.SELECTED:
	listener.itemSelected (se);
	break;
      case SelectionEvent.CHOSEN:
	listener.itemChosen (se);
	break;
      default:
      }
  }
  
  class ListActionListener implements ActionListener {
    @Override
    public void actionPerformed (ActionEvent e) {
      fireSelectionEvent (SelectionEvent.CHOSEN, false);
    }
  }

  class JListSelectionListener implements javax.swing.event.ListSelectionListener { 
    @Override
    public void valueChanged (javax.swing.event.ListSelectionEvent e) {
      if (e.getValueIsAdjusting ())
	return;
      boolean hasSelection = !jlistControl.isSelectionEmpty();
      fireSelectionEvent (SelectionEvent.SELECTED, hasSelection);
    }
  }

  class JListMouseListener extends MouseAdapter {
    @Override
    public void mouseClicked (MouseEvent e) {
      if (e.getClickCount() == 2) {
	fireSelectionEvent (SelectionEvent.CHOSEN, false);
      }
    }
  }

}
