<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" "http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><!--This file was converted to xhtml by LibreOffice - see http://cgit.freedesktop.org/libreoffice/core/tree/filter/source/xslt for the code.--><head profile="http://dublincore.org/documents/dcmi-terms/"><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8"/><title xml:lang="en-US">kc_create_new_int_1_cell_heater_obj (Init-Obj : item-or-value, W : class g2-window)</title><meta name="DCTERMS.title" content="kc_create_new_int_1_cell_heater_obj (Init-Obj : item-or-value, W : class g2-window)" xml:lang="en-US"/><meta name="DCTERMS.language" content="en-US" scheme="DCTERMS.RFC4646"/><meta name="DCTERMS.source" content="http://xml.openoffice.org/odf2xhtml"/><meta name="DCTERMS.creator" content="Richard Anderson"/><meta name="DCTERMS.issued" content="2003-07-23T00:07:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.contributor" content="Richard Anderson"/><meta name="DCTERMS.modified" content="2003-07-24T00:03:00" scheme="DCTERMS.W3CDTF"/><meta name="DCTERMS.provenance" content="" xml:lang="en-US"/><meta name="DCTERMS.subject" content="," xml:lang="en-US"/><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/" hreflang="en"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/" hreflang="en"/><link rel="schema.DCTYPE" href="http://purl.org/dc/dcmitype/" hreflang="en"/><link rel="schema.DCAM" href="http://purl.org/dc/dcam/" hreflang="en"/><style type="text/css">
	@page {  }
	table { border-collapse:collapse; border-spacing:0; empty-cells:show }
	td, th { vertical-align:top; font-size:12pt;}
	h1, h2, h3, h4, h5, h6 { clear:both }
	ol, ul { margin:0; padding:0;}
	li { list-style: none; margin:0; padding:0;}
	<!-- "li span.odfLiEnd" - IE 7 issue-->
	li span. { clear: both; line-height:0; width:0; height:0; margin:0; padding:0; }
	span.footnodeNumber { padding-right:1em; }
	span.annotation_style_by_filter { font-size:95%; font-family:Arial; background-color:#fff000;  margin:0; border:0; padding:0;  }
	* { margin:0;}
	.P1 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; font-style:italic; }
	.P2 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; color:#ff0000; }
	.P3 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; }
	.P4 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; margin-left:0.5in; margin-right:0in; text-indent:0in; font-style:italic; }
	.P5 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; margin-left:1.25in; margin-right:0in; text-indent:-0.25in; font-style:italic; }
	.P6 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; margin-left:0.75in; margin-right:0in; text-indent:-0.25in; font-style:italic; }
	.P7 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; margin-left:1in; margin-right:0in; text-indent:-0.25in; font-style:italic; }
	.P8 { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; margin-left:0.25in; margin-right:0in; text-indent:-0.25in; font-style:italic; }
	.P9 { font-size:14pt; font-family:Times New Roman; writing-mode:lr-tb; text-align:center ! important; font-style:italic; font-weight:bold; }
	.Standard { font-size:12pt; font-family:Times New Roman; writing-mode:lr-tb; }
	.T1 { font-style:italic; }
	.T2 { font-family:Times; }
	.T3 { color:#ff0000; }
	<!-- ODF styles with no properties representable as CSS -->
	 { }
	</style></head><body dir="ltr" style="max-width:8.5in;margin-top:1in; margin-bottom:1in; margin-left:1.25in; margin-right:1.25in; writing-mode:lr-tb; "><p class="P9">Intelligent Object Palette Creation Methodology</p><p class="P1"> </p><p class="Standard"><span class="T1">All of the existing Intelligent Objects rely on the object being requested by a menu attached to an object or a WS.  The existing object creation methodology also use procedures that could be replace by methods for much cleaner and tighter code.  The following example is the procedure to create a 1 cell heater object:</span></p><p class="Standard"> </p><p class="Standard"> </p><p class="Standard">kc_create_new_int_1_cell_heater_obj (Init-Obj : item-or-value, W : class g2-window)</p><p class="Standard"> </p><p class="Standard">    {this procedure is started by the user menu choice on any kb-workspace.  It creates and names a new intelligent heater object.}</p><p class="Standard"> </p><p class="Standard">KIH : class kc_int_heater;</p><p class="Standard">WS : class kb-workspace;</p><p class="Standard">new-name, ws-name : symbol;</p><p class="Standard">button-text, query-text : text;</p><p class="Standard">dialog-obj : item-or-value;</p><p class="Standard">pass-status : symbol;</p><p class="Standard">num-passes : integer;</p><p class="Standard">proc-error : class error;</p><p class="Standard"> </p><p class="Standard">begin</p><p class="Standard"> </p><p class="Standard">if Init-Obj is a kb-workspace then</p><p class="Standard">    WS = Init-Obj</p><p class="Standard">else</p><p class="Standard">  WS = the workspace of Init-Obj;</p><p class="Standard"> </p><p class="Standard">button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Enter the name of the new heater object.",the symbol QUERY, the symbol MEDIUM,W,the symbol UIL-QUESTION-ICON);</p><p class="Standard">if button-text = "YES" then</p><p class="Standard">  begin</p><p class="Standard">    if length-of-text (query-text) &gt; 0 then</p><p class="Standard">      begin</p><p class="Standard">        new-name = symbol (query-text);</p><p class="Standard">        if the object named by new-name does not exist then</p><p class="Standard">          begin</p><p class="Standard">            pass-status, num-passes = call kc_get_number_of_heater_passes (the symbol 1-cell, W);</p><p class="Standard">            if pass-status = the symbol PROCEED then</p><p class="Standard">              begin</p><p class="Standard">                create a kc_int_1_cell_heater KIH;</p><p class="Standard">                transfer KIH to WS at (5000, -5000);</p><p class="Standard">                move KIH to (0, 0);</p><p class="Standard">                change the size of WS to minimum;</p><p class="Standard">                conclude that the names of KIH = new-name;</p><p class="Standard">                call kc_fill_IO_attributes (KIH,W);</p><p class="Standard">                make KIH permanent;</p><p class="Standard">                call kc_create_new_heater_pass_objs (KIH, num-passes);</p><p class="Standard">              end;</p><p class="Standard">          end {object does not exist}</p><p class="Standard">        else</p><p class="Standard">          begin</p><p class="Standard">            button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Unable to create a new Intelligent Heater Object because an object named [new-name] already exists.  Please try again and enter a different name.",the symbol MESSAGE, the symbol MEDIUM,W,the symbol UIL-WARNING-ICON);</p><p class="Standard">          end; {object exists}</p><p class="Standard">      end</p><p class="Standard">    else</p><p class="Standard">      button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Intelligent Heater Object creation cancelled because a valid heater name was not entered.",the symbol MESSAGE, the symbol MEDIUM,W,the symbol UIL-WARNING-ICON); {user entered nothing}</p><p class="Standard">  end {user response was OK}</p><p class="Standard">else</p><p class="Standard">  button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Intelligent Heater Object creation cancelled.",the symbol MESSAGE, the symbol MEDIUM,W,the symbol UIL-INFORMATION-ICON); {user response was CANCEL}</p><p class="Standard"> </p><p class="Standard">end</p><p class="Standard"> </p><p class="Standard">on error (proc-error)</p><p class="Standard">  call kc_proc_on_error_deletion (KIH);</p><p class="Standard">  call kc_proc_on_error_handler (proc-error, this procedure);</p><p class="Standard">end</p><p class="Standard"> </p><p class="Standard"> </p><p class="P3"><span class="T1">I propose to replace the old procedures with a method that is kicked off by the creation of an object from a palette (Q:Is there a way to tell an object created off a palette as opposed to cloned?).  The new method would perform the following functionality:</span></p><p class="P1"> </p><p class="P4">Call an object naming method.</p><p class="P5">Naming query should be recursive until a valid symbol name is entered or the user cancels</p><p class="P4">Call an object configuration validation method</p><p class="P5">Should default to a base method for objects with no additional configuration needed.</p><p class="P6">If configuration validation is OK then:</p><p class="P7">Name the object.</p><p class="P7">Fill the object default attributes.</p><p class="P7">Create any sub-objects and fill the sub-object default attributes.</p><p class="P6">Otherwise:</p><p class="P7">Delete the cloned object.</p><p class="P8"> </p><p class="P8">I have updated the 1 cell heater creation procedure as an example:</p><p class="Standard"> </p><p class="Standard"> </p><p class="Standard">kc_validate_and_fill_new_obj (Init-Obj : item-or-value, W : class g2-window)</p><p class="Standard"> </p><p class="P2">kc_validate_and_fill_new_obj would become a method rather than a procedure.</p><p class="Standard"> </p><p class="Standard">KIH : class kc_int_heater;</p><p class="Standard">WS : class kb-workspace;</p><p class="Standard">new-name, ws-name : symbol;</p><p class="Standard">button-text, query-text : text;</p><p class="Standard">dialog-obj : item-or-value;</p><p class="Standard">pass-status : symbol;</p><p class="Standard">num-passes : integer;</p><p class="Standard">proc-error : class error;</p><p class="Standard"> </p><p class="Standard">begin</p><p class="Standard"> </p><p class="Standard">WS = the workspace of Init-Obj;</p><p class="Standard"> </p><p class="P2">The following section should be made into a generic object naming method.</p><p class="Standard"> </p><p class="Standard">button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Enter the name of the new heater object.",the symbol QUERY, the symbol MEDIUM,W,the symbol UIL-QUESTION-ICON);</p><p class="Standard">if button-text = "YES" then</p><p class="Standard">  begin</p><p class="Standard">    if length-of-text (query-text) &gt; 0 then</p><p class="Standard">      begin</p><p class="Standard">        new-name = symbol (query-text);</p><p class="Standard"> </p><p class="P2">We should use a recursive technique until a unique name is reached or the user cancels.</p><p class="Standard"> </p><p class="P2">End Section</p><p class="Standard"> </p><p class="Standard">        if <span class="T2">the object named by new-name does not exist</span> <span class="T3">the user did not cancel </span>then</p><p class="Standard">          begin</p><p class="Standard"> </p><p class="P2">The following section should be put into a object specific validation and creation method.</p><p class="Standard"> </p><p class="Standard">            pass-status, num-passes = call kc_get_number_of_heater_passes (the symbol 1-cell, W);</p><p class="Standard">            if pass-status = the symbol PROCEED then</p><p class="Standard">              begin</p><p class="Standard">                conclude that the names of KIH = new-name;</p><p class="Standard">                call kc_fill_IO_attributes (KIH,W);</p><p class="Standard">                make KIH permanent;</p><p class="Standard">                call kc_create_new_heater_pass_objs (KIH, num-passes);</p><p class="Standard"> </p><p class="P2">End Section</p><p class="Standard"> </p><p class="Standard">              end;</p><p class="Standard">          end </p><p class="Standard">  end {user response was OK}</p><p class="Standard">else</p><p class="Standard">  button-text, query-text, dialog-obj = call uil-post-generic-dialog ("Intelligent Heater Object creation cancelled.",the symbol MESSAGE, the symbol MEDIUM,W,the symbol UIL-INFORMATION-ICON); {user response was CANCEL}</p><p class="Standard"> </p><p class="Standard">end</p><p class="Standard"> </p><p class="Standard">on error (proc-error)</p><p class="Standard">  call kc_proc_on_error_deletion (KIH);</p><p class="Standard">  call kc_proc_on_error_handler (proc-error, this procedure);</p><p class="Standard">end</p><p class="Standard"> </p></body></html>