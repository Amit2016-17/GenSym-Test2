
(in-package #-(or SBCL MCL clozure Genera) "USER"
	    #+(or SBCL MCL clozure Genera) "CL-USER")

(proclaim '(optimize (speed 3) (safety 1) #+lucid (compilation-speed 0)))

;files in this directory are generated by /home/rh/util/scripts/update-library-information
;"macros.lisp" in this directory is generated "by hand"
(defparameter *library-information-default-pathname*
  "/bt/ab/trans/libfiles/x.lisp")

(defun library-information-file (name)
  (make-pathname :defaults *library-information-default-pathname*
		 :name (string-downcase name)))

(defparameter *global-text-files*
  '(crt0
    (g2 g2 libfnt libcprim gsiannex)
    (tw tw libfnt libcprim gsiannex)
    (gsi skeleton gsi_main libgsi)
    librtl
    (gsi libnet)
    (g2 libx11)
    (tw libx11)
    libc libm libsocket libintl libdl libnsl libgcc))

(defun system-name-for-executable-file (file)
  (let ((name (pathname-name file)))
    (cond ((string= "g2" name) 'g2)
	  ((string= "ntw" name) 'ntw)
	  ((string= "tw" name) 'tw)
	  (t 'gsi))))

(defun library-information-files-for-system (system)
  (mapcar #'library-information-file
	  (loop for name in *global-text-files*
		when (or (atom name) (eq system (car name)))
		  append (if (atom name)
			     (list name)
			     (cdr name)))))

(defun library-information-files-for-executable-file (file)
  (library-information-files-for-system
    (system-name-for-executable-file file)))



(defvar *file-table* (make-hash-table :test 'equal))

(defvar *library+file-table* (make-hash-table :test 'equal))

(defun make-library+file (library file)
  (let ((key (cons library file)))
    (or (gethash key *library+file-table*)
	(setf (gethash key *library+file-table*)
	      (format nil "~A:~A" library file)))))

(defparameter *show-duplicate-file-info-p* nil)

(defun read-file-info (name)  
  (dolist (entry (with-open-file (in name :if-does-not-exist nil)
		   (when in (read in))))
    (let ((name (first entry))
	  (path (if (cddr entry)
		    (make-library+file (third entry) (second entry))
		    (second entry))))
      (let ((old (gethash name *file-table*)))
	(if old
	    (when *show-duplicate-file-info-p*
	      (format t "~&Duplicate name ~A defined by ~A and ~A~%" name old path))
	    (setf (gethash name *file-table*) path))))))

(defun update-file-table-for-executable-file (file)
  (clrhash *file-table*)
  (dolist (info-file (library-information-files-for-executable-file file))
    (read-file-info info-file)))

(defun update-file-table-for-system (system)
  (clrhash *file-table*)
  (dolist (info-file (library-information-files-for-system
		       (intern (string-upcase system) "USER")))
    (read-file-info info-file)))

(defvar *full-file-name* nil)
(defvar *source-file-name* nil)

(defvar *function-size-table*
  (make-hash-table :test 'equal))

(defun get-nm-line (in)
  (let* ((location (or (let ((*read-base* 16.))
			 (read in nil nil))
		       (return-from get-nm-line nil)))
	 (type-char (progn (peek-char t in) (read-char in)))
	 (globalp (char= #\T type-char))
	 (textp (or globalp (char= #\t type-char)))
	 (name (progn (read-char in) (read-line in))))
    (cond ((string= name "gcc2_compiled.")
	   (values location *source-file-name* 'name))
	  ((not textp)
	   (setq *source-file-name* name)
	   (get-nm-line in))
	  (t
	   (values location name globalp)))))

(defun read-nm-line (in &optional filep)
  (loop do
    (multiple-value-bind (location name globalp)
	(get-nm-line in)
      (unless location
	(return-from read-nm-line nil))
      (unless (and filep (not (eq globalp 'name)))
	(return-from read-nm-line (list location name globalp))))))

(defun read-nm-lines (in &optional filep)
  (loop for nm = (read-nm-line in filep)
	while nm
	collect nm))

(defun sort-nm-lines (lines)
  (coerce (sort (coerce lines 'vector) #'< :key #'car) 'list))

(defun read-nm-file-data (file filep)
  (with-open-file (in (make-pathname :defaults file :type "nm"))
    (sort (loop for (start name type) = nil then next
		for source-name = nil then (if (eq type 'name)
					       name
					       file-name)
		for file-name = source-name
		for next in (sort-nm-lines (read-nm-lines in filep))
		for (finish) = next
		when start
		  collect (list (- finish start) name file-name))
	  #'> :key #'car)))

(defun get-function-size-data (file)
  (update-file-table-for-executable-file file)
  (clrhash *function-size-table*)
  (dolist (nm (read-nm-file-data file nil) *function-size-table*)
    (let ((size (car nm))
	  (name (cadr nm)))
      (setf (gethash name *function-size-table*) size))))

(defun read-nm-file (file &optional filep)
  (update-file-table-for-executable-file file)
  (let ((nm-list (read-nm-file-data file filep))
	(out-file (make-pathname :defaults file
				 :type (if filep
					   "file"
					   "size")))
	(library-totals (when filep (make-hash-table :test 'equal))))
    (with-open-file (out out-file
			 :direction :output)
      (format out "~%")
      (let ((total (reduce #'+ (mapcar #'car nm-list)))
	    (so-far 0))
	(dolist (nm nm-list)
	  (let ((size (car nm))
		(name (cadr nm))
		(file (caddr nm)))
	    (incf so-far size)
	    (format out " ~5,1F " (/ (* 100.0 so-far) total))
	    (format out "~8,'0X ~A" size name)
	    (if filep
		(let* ((c (position #\: name))
		       (lib (if c (subseq name 0 c) "others")))
		  (setf (gethash lib library-totals)
			(+ size (or (gethash lib library-totals) 0))))
		(format out "~49T~A" file))
	    (terpri out)))
	(format out "~&Total: ~13T~8D  ( #X~X )~%" total total)
	(if filep
	    (let ((lt-list nil))
	      (maphash #'(lambda (lib total)
			   (push (cons lib total) lt-list))
		       library-totals)
	      (dolist (lt (sort lt-list #'> :key #'cdr))
		(format out "~&~A:~13T~8D  ( #X~X )~%"
			(file-namestring (car lt)) (cdr lt) (cdr lt))))
	    (let ((init-total 0))
	      (dolist (nm nm-list)
		(let* ((name (cadr nm))
		       (len (length name)))
		  (when (and (< 5 len)
			     (string= "_INIT" name :start2 (- len 5)))
		    (incf init-total (car nm)))))
	      (format out "~&INIT Total: ~13T~8D  ( #X~X )~%" init-total init-total)))))
    (format t "~&Writing ~S.~%" (namestring out-file)))
  (values))

;(read-nm-file "/bt/rh/gsi/opt/skeleton")
;(read-nm-file "/bt/rh/gsi/opt/skeleton" t)

;(read-nm-file "/bt/rh/g2/opt/g2")
;(read-nm-file "/bt/rh/g2/opt/g2" t)

(in-package "TIMPL")

(defvar *c-macro-information*)

(defun read-macro-information ()
  (setq *c-macro-information* (make-hash-table :test #'equal))
  (dolist (n+v (with-open-file (in (library-information-file 'macros))
		 (read in)))
    (let ((name (car n+v))
	  (functions (cdr n+v)))
      (setf (gethash name *c-macro-information*)
	    (if (and functions (null (cdr functions))
		     (equal name (car functions)))
		(car functions)
		functions)))))

(defun get-macro-information (name)
  (unless (boundp '*c-macro-information*)
    (read-macro-information))
  (gethash name *c-macro-information* name))

(defvar *default-call-information-package* "LISP")

(defun ci-pkg () *default-call-information-package*)

(defun list-special-variables (file &optional (package (ci-pkg)))
  (let ((vlist nil))
    (translator-map-environment-names
      #'(lambda (name desc)
	  (declare (ignore desc))
	  (push name vlist))
      nil
      'defined-as-variable)
    (let ((*package* (if (stringp package)
			 (find-package package)
			 package)))
      (with-open-file (out file :direction :output)
	(dolist (v (sort vlist #'fn<))
	  (format out "~S~%" v)))))
  (format t "~&Writing ~S.~%" (namestring file))
  (values))

(defvar *macroexpand-info-macro-table* (make-hash-table :test 'equal))
(defvar *macroexpand-info-caller-table* (make-hash-table :test 'equal))

(defun clear-macroexpand-info ()
  (clrhash *macroexpand-info-macro-table*)
  (clrhash *macroexpand-info-caller-table*)
  nil)

(defun report-macroexpand-info (file &optional (package (ci-pkg)))
  (let ((*package* (if (stringp package)
		       (find-package package)
		       package)))
    (with-open-file (out file :direction :output)
      (let ((m-list nil))
	(maphash #'(lambda (macro info)
		     (push (cons macro info) m-list))
		 *macroexpand-info-macro-table*)
	(dolist (m (sort (copy-list m-list) #'> :key #'cddr))
	  (format out "~6D ~6D ~8,1F ~S~%" (cadr m) (cddr m)
		  (/ (float (cddr m)) (float (cadr m)))
		  (car m)))
	(format out "~2%")
	(dolist (m (sort (copy-list m-list) #'fn< :key #'car))
	  (format out "~6D ~6D ~8,1F ~S~%" (cadr m) (cddr m)
		  (/ (float (cddr m)) (float (cadr m)))
		  (car m)))
	(format out "~2%---------------------------------------~2%"))
      (let ((c-list nil))
	(maphash #'(lambda (caller delta)
		     (push (cons caller delta) c-list))
		 *macroexpand-info-caller-table*)
	(dolist (c (sort (copy-list c-list) #'> :key #'cdr))
	  (format out "~6D ~S~%" (cdr c) (car c)))
	(format out "~2%")
	(dolist (c (sort (copy-list c-list) #'fn< :key #'car))
	  (format out "~6D ~S~%" (cdr c) (car c)))
	(format out "~2%"))))
  (format t "~&Writing ~S.~%" (namestring file))
  (values))

;record both by caller-name and by macro-name
(defun note-macroexpand-call (macro-name caller-name before after)
  (let* ((delta (- after before))
	 (m (or (gethash macro-name *macroexpand-info-macro-table*)
		(setf (gethash macro-name *macroexpand-info-macro-table*)
		      (cons 0 0))))
	 (s (or (gethash caller-name *macroexpand-info-caller-table*) 0)))
    (incf (car m))
    (incf (cdr m) delta)
    (setf (gethash caller-name *macroexpand-info-caller-table*)
	  (+ s delta)))
  macro-name)

(defun macroexpand-info-hook (function form env)
  (if (or (atom form) (not *current-function*) *compile-time-only*
	  (let ((macro-name (car form)))
	    (eq macro-name (find-symbol (symbol-name macro-name) "TCL"))))
      (funcall function form env)
      (let* ((macro-name (car form))
	     (caller-name (function-record-name *current-function*))
	     (before (form-size form))
	     (result (funcall function form env))
	     (after (form-size result)))
	(note-macroexpand-call macro-name caller-name before after)
	result)))

(defun form-size (form)
  (if (atom form)
      1
      (case (car form)
	(quote
	 1)
	(declare
	 0)
	(the
	 (form-size (third form)))
	(t
	 (let ((total 0))
	   (dolist (subform form total)
	     (incf total (form-size subform))))))))

#+ignore ; disable this hook since form-size cannot handle (A . B)
(setq *macroexpand-hook* #'macroexpand-info-hook)

#|
(defun call-macro-function (function form env)
  ;;(funcall *macroexpand-hook* function form env)
  (macroexpand-info-hook function form env))
|#

(proclaim '(special *function-size-table*))

(defvar *local-function-table*
  (make-hash-table :test 'equal))

(defvar *call-information*
  (make-hash-table :test 'equal))

(defvar *variable-information*
  (make-hash-table :test 'eq))

(defvar *inverse-call-information*
  (make-hash-table :test 'equal))

(defvar *called-functions*
  (make-hash-table :test 'equal))

(defun reset-call-information ()
  (clrhash *call-information*)
  (clrhash *inverse-call-information*)
  nil)

(defun get-function-size (name)
  (if (boundp '*function-size-table*)
      (or (gethash name *function-size-table*) 0)
      '?))

(defparameter *set-list-limit* 40)

(defun add-element-to-set (element set)
  (typecase set
    (null (cons 1 (list element)))
    (cons (if (member element (cdr set))
	      set
	      (let* ((old-size (car set))
		     (new-size (1+ old-size)))
		(declare (fixnum old-size new-size))
		(if (< *set-list-limit* new-size)
		    (let ((table (make-hash-table)))
		      (setf (gethash element table) t)
		      (dolist (e (cdr set) table)
			(setf (gethash e table) t)))
		    (progn
		      (setf (car set) new-size)
		      (push element (cdr set))
		      set)))))
    (t    (setf (gethash element set) t)
	  set)))

(defmacro doset ((variable set-form) &body forms)
  `(let ((.set. ,set-form))	 
     (typecase .set.
       (null nil)
       (cons (dolist (,variable (cdr .set.)) ,@forms))
       (t    (maphash #'(lambda (,variable ignore)
			  (declare (ignore ignore))
			  ,@forms)
		      .set.)))))

(defmacro empty-set ()
  nil)

(defun empty-set-p (set)
  (typecase set
    (null t)
    (cons (null (cdr set)))
    (t    nil)))       

(defun set-to-list (set)
  (typecase set
    (null set)
    (cons (cdr set))
    (t    (let ((list nil))
	    (maphash #'(lambda (element ignore)
			  (declare (ignore ignore))
			  (push element list))
		      set)
	    list))))

(defun list-to-set (list)
  (if (null list)
      (empty-set)
      (cons (length list) list)))

(defun sort-set (set fn)
  (let* ((list (set-to-list set))
	 (length (length list)))
    (cons length (sort (copy-list list) fn))))

(defmacro push-set (thing set-location)
  `(setf ,set-location (add-element-to-set ,thing ,set-location)))

(defvar *function-name* nil)
(defvar *definition-count* -1)

(defvar *statement-info-vector*
  #(definition c-call
    with-catch with-unwind-protect with-progv with-local-allocation with-area))

(defstruct fv-info
  (file nil)
  (index -1 :type fixnum)
  (location nil))

(defstruct use-info
  (call (empty-set))
  (use (empty-set))
  (var (empty-set)))

(defstruct (f-info
	     (:include fv-info))
  (flags 0 :type fixnum)
  (use-info (make-use-info)))

(defun get-f-info (fn)
  (or (gethash fn *call-information*)
      (setf (gethash fn *call-information*)
	    (make-f-info))))

(defvar *last-compile-file-pathname* nil)
(defvar *last-file-name* nil)

(defun get-current-file-name ()
  (if (equal *compile-file-pathname* *last-compile-file-pathname*)
      *last-file-name*
      (let* ((name (file-namestring *compile-file-pathname*))
	     (info (get-f-info name)))
	(setq *last-compile-file-pathname* *compile-file-pathname*)
	(setq *last-file-name* name)
	(setf (fv-info-file info) name)
	(setf (fv-info-index info) (incf *definition-count*))
	name)))

(defun get-current-location ()
  *position-in-file-before-read*)

(defun get-current-f-info ()
  (get-f-info (or *function-name* (get-current-file-name))))

(defun cci-note-statement-use (use)
  (let ((info (get-current-f-info)))
    (if (eq use 'definition)
	(progn
	  (setf (fv-info-file info) (get-current-file-name))
	  (setf (fv-info-location info) (get-current-location))
	  (setf (fv-info-index info) (incf *definition-count*))
	  (setf (f-info-flags info) (logior (f-info-flags info) 1)))
	(let* ((flags (f-info-flags info))
	       (bit (position use *statement-info-vector*)))
	  (declare (fixnum flags))
	  (setf (f-info-flags info)
		(logior flags (the fixnum (ash 1 bit)))))))
  use)

(defun cci-note-function-use (name &optional (callp nil))
  (when (environment-entry-p name)
    (setq name (environment-entry-name name)))
  (when (typep name 'function-record)
    (setq name (function-record-name name)))
  (let* ((info (get-current-f-info))
	 (use-info (f-info-use-info info)))
    (let ((value (if callp
		     (use-info-call use-info)
		     (use-info-use use-info))))
      (push-set name value)
      (if callp
	  (setf (use-info-call use-info) value)
	  (setf (use-info-use use-info) value))))
  name)

(defstruct (v-info
	     (:include fv-info))
  (explicitp nil))

(defun get-v-info (var)
  (or (gethash var *variable-information*)
      (setf (gethash var *variable-information*)
	    (make-v-info))))

(defun cci-note-variable-definition (name explicitp)
  (when (symbolp name)
    (let ((info (gethash name *variable-information*)))
      (if info
	  (when explicitp
	    (setf (v-info-file info) (get-current-file-name))
	    (setf (v-info-location info) (get-current-location))
	    (setf (v-info-index info) (incf *definition-count*))
	    (setf (v-info-explicitp info) t))
	  (setf (gethash name *variable-information*)
		(make-v-info :file (get-current-file-name)
			     :location (get-current-location)
			     :index (incf *definition-count*)
			     :explicitp explicitp)))))
  name)

(defun cci-note-variable-use (name)
  (when (symbolp name)
    (let ((use-info (f-info-use-info (get-current-f-info))))
      (push-set name (use-info-var use-info)))
    (cci-note-variable-definition name nil))
  name)

(defun note-inverse-call (from to type)
  (let ((ii (or (gethash to *inverse-call-information*)
		(setf (gethash to *inverse-call-information*)
		      (make-use-info)))))
    (case type
      (call (push-set from (use-info-call ii)))
      (use  (push-set from (use-info-use ii)))
      (var  (push-set from (use-info-var ii)))))
  nil)

(defun invert-call-information ()
  (clrhash *inverse-call-information*)
  (maphash #'(lambda (name info)
	       (let ((flags (f-info-flags info)))
		 (declare (fixnum flags))
		 (dotimes (i 7)
		   (when (and (not (zerop i)) (logbitp 0 flags))
		     (note-inverse-call name (svref *statement-info-vector* i) 'use))
		   (setq flags (ash flags -1))))
	       (let ((use-info (f-info-use-info info)))
		 (doset (use (use-info-use use-info))
		   (note-inverse-call name use 'use))
		 (doset (call (use-info-call use-info))
		   (note-inverse-call name call 'call))
		 (doset (var (use-info-var use-info))
		   (note-inverse-call name var 'var))))
	   *call-information*)
  (values))

(defun c-name-of-function-or-variable (name variablep)
  (if variablep
      (or (name-of-global-variable name) "?")
      (if (consp name)
	  (or (gethash name *local-function-table*) "?")
	  (name-of-function-entry name))))

(defun fnv< (fnv1 fnv2)
  (if (eq (car fnv1) (car fnv2))
      (and (not (eq (cdr fnv1) (cdr fnv2)))
	   (eq (cdr fnv1) 'v))
      (fn< (car fnv1) (car fnv2))))

(defun write-inverse-call-information
    (&optional (file "inverse-call-information.lisp") (package (ci-pkg)))
  (invert-call-information)
  (let ((*package* (if (stringp package)
		       (find-package package)
		       package))
	(info nil))
    (maphash #'(lambda (name inverse)
		 (let ((callers (use-info-call inverse))
		       (users (use-info-use inverse))
		       (vars (use-info-var inverse)))
		   (push (cons (cons name 'f)
			       (sort (append (set-to-list callers) (set-to-list users))
				     #'fn<)) info)
		   (push (cons (cons name 'v)
			       (sort (set-to-list vars) #'fn<)) info)))
	     *inverse-call-information*)
    (clrhash *inverse-call-information*)
    (with-open-file (out file :direction :output)
      (dolist (n+c (sort info #'fnv< :key #'car))
	(let* ((name+type (car n+c))
	       (name (car name+type))
	       (var-p (eq 'v (cdr name+type)))
	       (callers (cdr n+c)))
	  (when callers
	    (format out "(~S ~:S . ~S)~%"
		    name (c-name-of-function-or-variable name var-p) callers))))))
  (format t "~&Writing ~S.~%" (namestring file))
  (values))

(defun caller-f-info (caller &optional info)
  (cons caller (or info (get-f-info caller))))

(defun caller-v-info (caller &optional info)
  (cons caller (or info (get-v-info caller))))

(defun caller-fv< (cfn1 cfn2)
  (let* ((cinfo1 (cdr cfn1))
	 (i1 (fv-info-index cinfo1))
	 (cinfo2 (cdr cfn2))
	 (i2 (fv-info-index cinfo2)))
    (when (eql -1 i1) (setq i1 most-positive-fixnum))
    (when (eql -1 i2) (setq i2 most-positive-fixnum))
    (if (= i1 i2)
	(fn< (car cfn1) (car cfn2))
	(< i1 i2))))

(defun print-width-of-object (object)
  (typecase object
    (null 3) ; NIL
    (symbol
     (let* ((name (symbol-name object))
	    (name-length (length name))
	    (package (symbol-package object)))
       (cond ((null package)
	      (+ 2 name-length))
	     ((eq object (find-symbol name))
	      name-length)
	     (t
	      (+ 1 name-length (length (package-name package)))))))
    (cons
     (let ((total 1))
       (loop for tail = object then next
	     for next = (cdr tail)
	     do (incf total (1+ (print-width-of-object (car tail))))
	     unless (consp next)
	       do (when next (incf total (+ 3 (print-width-of-object next))))
		  (return nil))
       total))
    (string (+ 2 (length object)))
    (t 1)))

(defvar *file-call-line-length* 110)

(defun write-file-call-information1 (out list template &optional name-file)
  (if (consp template)
      (progn
	(write-file-call-information1 out (car list) (car template) name-file)
	(write-file-call-information1 out (cdr list) (cdr template) name-file))
      (when list
	(case template
	  (properties
	   (let ((list (if name-file
			   list
			   (delete 'uncalled list))))
	     (when list
	       (format out "~%   (~A ~{~A~^ ~})"
		       template list))))
	  (t
	   (let ((list (let ((fc nil)
			     (last-file ':none))
			 (dolist (cc list
				  (mapcar #'(lambda (f+cl)
					      (setf (cdr f+cl) (nreverse (cdr f+cl)))
					      f+cl)
					  (nreverse fc)))
			   (let ((caller (car cc))
				 (c-file (fv-info-file (cdr cc))))
			     (if (equal c-file last-file)
				 (push caller (cdar fc))
				 (push (list (setq last-file c-file) caller) fc)))))))
	     (format out "~%   (~A" template)
	     (dolist (e list)
	       (if (not (listp e))
		   (format out "~%     ~S" e)
		   (let* ((initial-position 6)
			  (position initial-position))
		     (format out "~%     (")
		     (dolist (v e)
		       (let ((w (print-width-of-object v)))
			 (cond ((= initial-position position)
				(incf position w))
			       ((<= *file-call-line-length*
				    (incf position (1+ w)))
				(format out "~%       ")
				(setq position (+ 1 initial-position w)))
			       (t
				(write-char #\space out))))
		       (prin1 v out))
		     (format out ")"))))
	     (format out ")")))))))

(defun name-and-file (name)
  (when (and (stringp name) (boundp '*file-table*))
    (let ((file (gethash (format nil "_~A" name)
			 (symbol-value '*file-table*))))
      (if file
	  (list name
		(let ((p (position #\/ file :from-end t)))
		  (if p (subseq file (1+ p)) file)))
	  name))))

(defun write-file-call-information (file library-file package info template)
  (let ((out nil)
	(*package* (if (stringp package)
		       (find-package package)
		       package))
	(last-name-file ':none))
    (unwind-protect
	 (dolist (n+c (sort info #'caller-fv< :key #'car))
	   (let* ((name-c (car n+c))
		  (name (car name-c))
		  (fv-info (cdr name-c))
		  (variablep (eq (type-of fv-info) 'v-info))
		  (name-file (fv-info-file fv-info))
		  (c-name (c-name-of-function-or-variable name variablep))
		  (m-name (when (and (not variablep) c-name)
			    (get-macro-information c-name)))
		  (list (cdr n+c)))
	     (unless (equal last-name-file name-file)
	       (setq last-name-file name-file)
	       (when (or (null out)
			 (eq library-file t)
			 (and library-file (null name-file)))
		 (let* ((name (if (eq library-file t)
				  (format nil "~A-use-information"
					  (if (null name-file)
					      "library"
					      (pathname-name name-file)))
				  (pathname-name
				    (if (null name-file)
					(or library-file file)
					file))))
			(path (make-pathname :defaults file
					     :name name)))
		   (when out (close out))
		   (format t "~&Writing ~S.~%" (namestring path))
		   (setq out (open path :direction ':output))))
	       (format out "~2%; - - - - - - - - - ~A - - - - - - - - -~2%"
		       name-file))
	     (let* ((info
		      (if variablep
			  c-name
			  (if last-name-file
			      m-name
			      (mapcar #'name-and-file
				      (if (listp m-name) m-name (list m-name))))))
		    (name-info
		      (if (or variablep
			      (equal c-name m-name))
			  info
			  (cons c-name info))))
	       (format out "(~A ~S ~:S"
		       (if variablep "V" "F")
		       name
		       name-info))
	     (write-file-call-information1 out list template last-name-file)
	     (format out ")~%"))))
    (when out (close out)))
  (values))

(defun file-fn-use-info (info)
  (let ((use-info (f-info-use-info info)))
    (sort (nconc (mapcar #'caller-f-info (set-to-list (use-info-call use-info)))
		 (mapcar #'caller-f-info (set-to-list (use-info-use use-info))))
	  #'caller-fv<)))

(defun file-var-use-info (info)
  (let ((use-info (f-info-use-info info)))
    (when use-info
      (sort (mapcar #'caller-v-info (set-to-list (use-info-var use-info)))
	    #'caller-fv<))))

(defun file-inverse-fv-info (callers)
  (let ((callers (set-to-list callers)))
    (when callers
      (sort (mapcar #'caller-f-info callers) #'caller-fv<))))

(defun write-call-information-by-file
    (&optional (file "call-information-by-file.lisp") (package (ci-pkg)))
  (let ((info-list nil))
    (maphash #'(lambda (name info)
		 (push (list* (caller-f-info name info)
			      (file-fn-use-info info)
			      (file-var-use-info info))
		       info-list))
	     *call-information*)
    (write-file-call-information file nil package info-list
				 '(uses-functions . uses-variables))))

(defun write-inverse-call-information-by-file
    (&optional (file "inverse-call-information-by-file.lisp") (package (ci-pkg)))
  (invert-call-information)
  (let ((info nil))
    (maphash #'(lambda (name inverse)
		 (let ((callers (use-info-call inverse))
		       (users (use-info-use inverse))
		       (vars (use-info-var inverse)))
		   (declare (ignore users))
		   (let ((sorted-list (file-inverse-fv-info callers)))
		     (when sorted-list
		       (push (cons (caller-f-info name) sorted-list) info)))
		   (let ((sorted-list (file-inverse-fv-info vars)))
		     (when sorted-list
		       (push (cons (caller-v-info name) sorted-list) info)))))
	     *inverse-call-information*)
    (write-file-call-information file nil package info 'used-by-functions)))

(defun write-use-information-by-file
    (&optional
      (file "use-information-by-file.lisp")
      (library-file "library-use-information.lisp")
      (package (ci-pkg)))
  (invert-call-information)
  (compute-called-functions)
  (let ((fv-info-list nil))
    (maphash #'(lambda (fv-info ignore)
		 (declare (ignore ignore))
		 (push fv-info fv-info-list))
	     (let ((fv-table (make-hash-table :test 'equal)))
	       (maphash #'(lambda (name info)
			    (setf (gethash (caller-f-info name info) fv-table) t))
			*call-information*)
	       (maphash #'(lambda (name inverse)
			    (unless (empty-set-p (use-info-call inverse))
			      (setf (gethash (caller-f-info name) fv-table) t))
			    (unless (empty-set-p (use-info-var inverse))
			      (setf (gethash (caller-v-info name) fv-table) t)))
			*inverse-call-information*)
	       fv-table))
    (write-file-call-information
      file library-file package
      (mapcar #'(lambda (fv-info)
		  (cons fv-info
			(let* ((name (car fv-info))
			       (info (cdr fv-info))
			       (inverse (gethash name *inverse-call-information*)))
			  (typecase info
			    (f-info
			     (list* (file-fn-use-info info)
				    (file-var-use-info info)
				    (when inverse
				      (file-inverse-fv-info (use-info-call inverse)))
				    (let* ((entry (c-name-of-function-or-variable name nil))
					   (source-file-location (fv-info-location info))
					   (size (and entry (get-function-size entry)))
					   (called-p (or (consp name)
							 (gethash name *called-functions*)))
					   (symbol-p (and (not (consp name))
							  (function-callable-from-symbol-p name)))
					   (funcallable-p (or symbol-p (consp name))))
				      `(,@(when source-file-location `((source-file-location ,source-file-location)))
					,@(when (and (integerp size) (plusp size)) `((code-size ,size)))
					,@(unless called-p '(uncalled))
					,@(when symbol-p '(symbol))
					,@(when funcallable-p '(funcallable))))))
			    (v-info
			     (list* nil nil
				    (when inverse
				      (file-inverse-fv-info (use-info-var inverse)))
				    (let ((source-file-location (fv-info-location info)))
				      `(,@(when source-file-location
					    `((source-file-location ,source-file-location)))))))))))
	      (sort fv-info-list #'caller-fv<))
      '(uses-functions uses-variables used-by-functions . properties))))

(defun note-called-function (name)
  (unless (gethash name *called-functions*)
    (setf (gethash name *called-functions*) t)
    (let ((use-info (f-info-use-info (get-f-info name))))
      (doset (use (use-info-use use-info))
	(note-called-function use))
      (doset (call (use-info-call use-info))
	(note-called-function call)))))

(defvar gsi-api nil)

(defun compute-called-functions ()
  (when (find-package "AB")
    (setq gsi-api (intern "GSI-API-SYMBOL" "AB")))
  (clrhash *called-functions*)
  (maphash #'(lambda (name info)
	       (declare (ignore info))
	       (when (or (stringp name) (consp name)
			 (and (symbolp name) gsi-api
			      (get name gsi-api))
			 (function-callable-from-symbol-p name))
		 (note-called-function name)))
	   *call-information*))

(defun function-callable-from-symbol-p (name)
  (let ((principal (if (consp name) (cadr name) name))
	(decl-info (translator-set-declaration-information name nil)))
    (or (symbol-exists-at-runtime principal)
	(or (rest (assoc 'tx::include-symbol-at-runtime decl-info))
	    (and (not (rest (assoc 'tx::omit-symbol-at-runtime decl-info)))
		 *function-symbols*)))))

(defun write-uncalled-functions
    (&optional (file "uncalled-functions.lisp") (package (ci-pkg)))
  (compute-called-functions)
  (let ((*package* (if (stringp package)
		       (find-package package)
		       package))
	(uncalled-functions nil)
	(total 0))
    (maphash #'(lambda (name info)
		 (declare (ignore info))
		 (unless (gethash name *called-functions*)
		   (let* ((entry (name-of-function-entry name))
			  (size (get-function-size entry)))
		     (when (integerp size)
		       (incf total size))
		     (push (list name entry size)
			   uncalled-functions))))
	     *call-information*)
    (with-open-file (out file :direction :output)
      (dolist (nes (sort uncalled-functions #'fn< :key #'first))
	(let ((name (first nes))
	      (entry (second nes))
	      (size (third nes)))
	  (if (integerp size)
	      (format out "~S ~A ~D~%" name entry size)
	      (format out "~S ~A~%" name entry))))
      (when (boundp '*function-size-table*)
	(format out "~2%=============================~3%Total: ~D~2%" total)
	(let ((so-far 0) (f (/ 100.0 total)))
	  (dolist (nes (sort uncalled-functions #'> :key #'third))
	    (incf so-far (third nes))
	    (format out "~S ~A ~D ~5,1F~%" (first nes) (second nes) (third nes)
		    (* so-far f)))))))
  (format t "~&Writing ~S.~%" (namestring file))
  (values))

(defun fn< (fn1 fn2)
  (typecase fn1
    (string (or (not (stringp fn2))
		(string< fn1 fn2)))
    (symbol (and (not (stringp fn2))
		 (or (consp fn2)
		     (unless (eq fn1 fn2)
		       (let ((pkg1 (symbol-package fn1))
			     (pkg2 (symbol-package fn2)))
			 (cond ((and (null pkg1) pkg2) t)
			       ((null pkg2) nil)
			       ((not (eq pkg1 pkg2))
				(string< (package-name pkg1)
					 (package-name pkg2)))
			       (t
				(string< (symbol-name fn1)
					 (symbol-name fn2)))))))))
    (cons   (and (consp fn2)
		 (if (equal (car fn1) (car fn2))
		     (fn< (cdr fn1) (cdr fn2))
		     (fn< (car fn1) (car fn2)))))))

(defun write-call-information (&optional (file "call-information.lisp") (package (ci-pkg)))
  (let ((*package* (if (stringp package)
		       (find-package package)
		       package))
	(info-list nil))
    (maphash #'(lambda (name info)
		 (let ((use-info (f-info-use-info info)))
		   (setf (use-info-use  use-info) (sort-set (use-info-use use-info) #'fn<))
		   (setf (use-info-call use-info) (sort-set (use-info-call use-info) #'fn<))
		   (setf (use-info-var  use-info) (sort-set (use-info-var use-info) #'fn<)))
		 (push (cons name info) info-list))
	     *call-information*)
    (setq info-list (sort info-list #'fn< :key #'car))
    (with-open-file (out file :direction :output)
      (dolist (name+info info-list)
	(let* ((name (car name+info))
	       (info (cdr name+info))
	       (file (fv-info-file info))
	       (index (fv-info-index info))
	       (flags (f-info-flags info))
	       (use-info (f-info-use-info info)))
	  (format out "(~S (~S . ~D) . (#B~7,'0B . (~%   ~S~%   ~S~%   ~S)))~%"
		  name file index flags
		  (set-to-list (use-info-use  use-info))
		  (set-to-list (use-info-call use-info))
		  (set-to-list (use-info-var  use-info)))))))
  (format t "~&Writing ~S.~%" (namestring file))
  (values))


#|
(defun user::read-call-information (&optional (file "call-information.lisp") (package (ci-pkg)))
  (let ((*package* (if (stringp package)
		       (find-package package)
		       package)))
    (reset-call-information)
    (with-open-file (in file :direction :input)
      (loop (let* ((value (or (read in nil nil)
			      (return nil)))
		   (name (car value))
		   (file (caadr value))
		   (index (cdadr value))
		   (info (cddr value))
		   (flags (car info))
		   (fn-use-info (cadr info))
		   (var-use-info (caddr info)))
	      (setf (gethash name *call-information*)
		    (make-f-info
		      :file file
		      :index index
		      :flags flags
		      :fn-use-info (if (not (consp fn-use-info))
				       fn-use-info
				       (cons (list-to-set (car fn-use-info))
					     (list-to-set (cdr fn-use-info))))
		      :var-use-info (list-to-set var-use-info)))))))
  file)
|#

(defvar *unnamed-function-records* (make-hash-table :test 'eq))

(defun collect-call-information (statements)
  (dolist (statement statements)
    (when statement
      (let ((substatements (substatements statement)))
	(when substatements
	  (collect-call-information substatements)))
      (let ((type (target-form-type statement)))
	(case type
	  ((function-definition)
	   (let* ((record (second statement))
		  (name (function-record-name record))
		  (statements (function-record-statements record))
		  (*function-name*
		    (case (function-record-classification record)
		      ((:global :bound-global :callable :global-dllexport :callable-dllexport)
		       name)
		      (t (setf (gethash record *unnamed-function-records*)
			       (cons name *function-name*))))))
	     (cci-note-statement-use 'definition)
	     (collect-call-information statements)))
	  (variable-definition
	   (cci-note-variable-definition (second statement) t))
	  (special-variable
	   (cci-note-variable-use (second statement)))
	  (with-special-binding
	   (cci-note-variable-use (third statement)))
	  #|
	  ((null-statement labeled-statement goto switch
	    compound-statement if-statement forever-statement
	    for-statement while-statement do-while-statement
	    break-statement))
	  ((conditional-operator not-operator comma-operator and-expression
	    or-expression cast))
	  ((with-protected-variables with-lexical-bindings local-variable))
	  ((return-value return-values store-value store-values
	    return-stored-values values-assign save-values save-more-values
	    restore-values values nth-value first-multiple-value))
	  ((c-lines preprocessor-conditional))
	  ((setq))
	  ((symbolic-constant constant constant-label
	    load-time-value c-constant))
	  ((unbound-special-p initial-symbol initial-package	   
	    set-symbol-location with-special-binding))
	  |#
	  ((c-call values-c-call variadic-c-call variadic-values-c-call)
	   (cci-note-statement-use 'c-call))
	  ((box-value unbox-value call variadic-call call-generic variadic-call-generic
	    macro-call operator-call foreign-call accessor-call)
	   (let ((name (second statement)))
	     (case type
	       (box-value (setq name (boxer name)))
	       (unbox-value (setq name (unboxer name))))
	     (unless (keywordp name)
	       (cci-note-function-use name t))))
	  ((function-name function-object global-function global-foreign-function)
	   (cci-note-function-use (second statement)))
	  ((with-catch with-unwind-protect with-progv with-local-allocation with-area)
	   (cci-note-statement-use type)))))))

(defun set-function-record-unique-name (record name)
  #+sbcl
  (when *collect-call-information-p*
    (setf (gethash (gethash record *unnamed-function-records*) *local-function-table*) name)
    (remhash record *unnamed-function-records*))
  (setf (function-record-unique-name record) name)
  name)




