;;; -*- Mode: Lisp; Package: TCLOSI; Syntax: Common-Lisp -*-
;;;
;;; Build the CLOS bootstrap information program.
;;;
;;; Copyright (C) 1991 Chestnut Software, Inc.  All Rights Reserved.
;;;

(in-package "TCLOSI")

(himpl:note-rcs-revision
 "$Source: //gensym/ab-repos/chestnut/src/trans/lisp/build-boot.lisp,v $"
 "$Revision: 1.2 $"
 "$Date: 2007/06/27 15:49:24 $")

(defparameter *forms-per-bootstrap-function* 10)
(defparameter *bootstrap-info-package* *tcl-package*)
(defparameter *bootstrap-function-package* *tclos-run-package*)

(defun dump-clos-bootstrap-info
    (pathname &rest keys &key (translate t) h-file &allow-other-keys)
  (setq pathname
	(make-pathname :defaults pathname
		       :type (or (pathname-type pathname)
				 timpl::*translate-file-input-type*)))
  (with-open-file (f pathname
		     :direction :output
		     :if-exists *if-exists-action*
		     :if-does-not-exist *if-does-not-exist-action*)
    (format t "~&Writing ~A..." (namestring (pathname f)))
    (write-bootstrap-info-header f)
    (write-bootstrap-info-file f))
  (when translate
    (when h-file (setq keys (list* :relative-to-directory h-file keys)))
    (setq keys (list* :allow-other-keys t keys))
    (let ((*package* *bootstrap-info-package*))
      (with-translator-environment nil
	(apply #'prepare-file pathname keys)
	(let ((*header-lines* '("#define SI_VARIADIC_KEYWORD_FUNCTIONS"
				"#include \"runtime.h\""
				"#include \"externs.h\"")))
	  (apply #'translate-file pathname
		 :initfunction-name (bootstrap-initfunction-name)
		 keys))))))

(defun write-bootstrap-info-file (f)
  (let ((sinfo (build-initial-slot-index-info))
	(cinfo (build-class-bootstrap-info))
	(ginfo (build-generic-function-bootstrap-info))
	(obsolete-slots (build-slots-for-obsolescence-info))
	(*package* *bootstrap-info-package*)
	(*print-level* nil)
	(*print-length* nil))
    (labels ((build-functions (info name)
	       (do ((functions ())
		    (names ())
		    (index 1 (1+ index)))
		   ((endp info)
		    (values (nreverse functions) (nreverse names)))
		 (let ((forms ()))
		   (dotimes (i *forms-per-bootstrap-function*)
		     (when (null info) (return))
		     (push (pop info) forms))
		   (push nil forms)	; ensure all forms in void context
		   (let ((name (intern (format nil "~A~D" name index)
				       *bootstrap-function-package*)))
		     (push (list* name nil (nreverse forms)) functions)
		     (push name names)))))
	     (collect-functions (&rest pairs)
	       (do ((functions ())
		    (names ())
		    (pairs pairs (cddr pairs)))
		   ((endp pairs)
		    (values (mapcan #'identity (nreverse functions))
			    (mapcan #'identity (nreverse names))))
		 (multiple-value-bind (new-functions new-names)
		     (build-functions (car pairs) (cadr pairs))
		   (push new-functions functions)
		   (push new-names names)))))
      (multiple-value-bind (functions names)
	  (collect-functions sinfo "SLOT-INIT"
			     cinfo "CLASS-INIT"
			     ginfo "GENERIC-FUNCTION-INIT"
			     obsolete-slots "OBSOLETE-INIT")
	(pprint `(flet ,functions ,@(mapcar #'list names)) f)
	(terpri f)))))

(defparameter *bootstrap-initfunction-name*
  (format nil "~A_INIT_clos_bootstrap_info" *internal-function-prefix*))

(defun bootstrap-initfunction-name ()
  *bootstrap-initfunction-name*)

(defparameter *bootstrap-info-header*
  ";;; -*- Mode: Lisp; Package: ~A; Syntax: Common-Lisp -*-
;;;
;;; Copyright (c) ~D, Chestnut Software Inc.  All Rights Reserved.
;;;
;;; Build the bootstrap information used to create initial class hierarchy.
;;; This files is automatically generated by the translator, using the
;;; function ~S.
;;; Creation date for this file is ~D/~D/~D ~2,'0D:~2,'0D:~2,'0D.

")

(defun write-bootstrap-info-header (stream)
  (multiple-value-bind (sec min hour day month year) (get-decoded-time)
    (format stream *bootstrap-info-header*
	    (package-name *bootstrap-info-package*)
	    year 'dump-clos-bootstrap-info
	    month day year hour min sec)))

(defun build-class-bootstrap-info ()
  `((setq tclos-run:%initial-class-info nil)
    ,@(collect-bootstrap-class-info-forms)))

(defun collect-bootstrap-class-info-forms ()
  (let ((classes (make-hash-table :test 'eq)))
    (translator-map-environment-names
        #'(lambda (name class)
	    (declare (ignore name))
	    (unless (gethash class classes)
	      (setf (gethash class classes)
		    (bootstrap-class-info-form class))))
	*initial-global-environment*
	'defined-as-class)
    (let ((info nil))
      (maphash #'(lambda (class cinfo)
		   (declare (ignore class))
		   (push cinfo info))
	       classes)
      info)))

;;; (class name metaclass supers slots bootstrap)
(defun bootstrap-class-info-form (class)
  (let* ((name (tclos:class-name class))
	 (meta (with-class-record (rec class t)
		 (tclos:class-name (class-record-metaclass rec))))
	 (supers `(list ,@(mapcar #'(lambda (super)
				      `',(tclos:class-name super))
			          (tclos:class-direct-superclasses class))))
	 (slots `(list ,@(mapcar #'bootstrap-slotd-info
			         (tclos:class-direct-slots class))))
	 (bootstrap (bootstrap-class-p name)))
    `(setq tclos-run:%initial-class-info
           (cons (list nil ',name ',meta ,supers ,slots ',bootstrap)
	         tclos-run:%initial-class-info))))

(defun build-generic-function-bootstrap-info ()
  `((setq tclos-run:%initial-generic-function-info nil)
    ,@(collect-bootstrap-generic-function-info-forms)))

(defun collect-bootstrap-generic-function-info-forms ()
  (let ((info nil)
	(env *initial-global-environment*))
    (translator-map-environment-names
        #'(lambda (name descriptor)
	    (declare (ignore descriptor))
	    (when (defined-as-generic-function name env)
	      (push (bootstrap-generic-function-info-form name env) info)))
	env
	'defined-as-function)
    info))

;;; (name class lambda-list method-class precedence-order method-combination
;;;       list-of-critical-method-specializers)
(defun bootstrap-generic-function-info-form (name env)
  (let* ((record (translator-find-generic-function-record name t env))
	 (name (generic-function-record-name record))
	 (class (generic-function-record-function-class record))
	 (lambda-list (generic-function-record-lambda-list record))
	 (method-class (generic-function-record-method-class record))
	 (precedence-order
	    (generic-function-record-argument-precedence-order record))
	 (method-combination
	    (cons (generic-function-record-method-combination-type record)
		  (generic-function-record-method-combination-options record)))
	 (critical (generic-function-record-critical-methods record))
	 )
    `(setq tclos-run:%initial-generic-function-info
           (cons (list ',name
		       ',(tclos:class-name class)
		       ',(initial-symbolify-lambda-list lambda-list)
		       ',(tclos:class-name method-class)
		       ',(initial-symbolify-lambda-list precedence-order)
		       ',method-combination
		       ',critical)
	         tclos-run:%initial-generic-function-info))))

(defparameter *initial-package-list*
  (list *tcl-package* *tx-package* *tclos-package*
	*trun-package* *tclos-run-package*))

(defun initial-symbolify-lambda-list (lambda-list)
  (labels ((initial-symbolify (symbol)
	     (if (keywordp symbol) symbol
		 (initial-symbolify-1 (symbol-name symbol)
				      *initial-package-list*
				      symbol)))
	   (initial-symbolify-1 (name pkgs symbol)
	     (dolist (pkg pkgs (missing-initial-symbol symbol))
	       (multiple-value-bind (sym therep)
		   (find-symbol name pkg)
		 (when (eq therep :external) (return sym)))))
	   (missing-initial-symbol (symbol)
	     (warn "~S is not an initial symbol." symbol)
	     symbol))
    (mapcar #'initial-symbolify lambda-list)))

;;; (tclos-run:%assign-slot-index <slot name> <slot index>)
(defun build-initial-slot-index-info ()
  (let ((slots (make-hash-table :test 'eq)))
    (translator-map-environment-names
         #'(lambda (name class)
	     (declare (ignore name))
	     (dolist (slotd (tclos:class-direct-slots class))
	       (setf (gethash (tclos:slot-definition-name slotd) slots) t)))
	 *initial-global-environment*
	 'defined-as-class)
    (maphash #'(lambda (name ignore)
		 (declare (ignore ignore))
		 (push name slots))
	     (prog1 slots (setf slots nil)))
    (cons '(tclos-run:%initialize-slot-index-table)
	  (mapcar #'(lambda (slot)
		      `(tclos-run:%assign-slot-index
			    ',slot
			    (slot-index ,slot)))
		  (sort slots #'string<)))))

(defun build-slots-for-obsolescence-info ()
  `((setf tclos-run:%make-instances-obsolete-slots-to-flush
          ',*make-instances-obsolete-slots-to-flush*)))
