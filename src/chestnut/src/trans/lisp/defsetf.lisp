;;; -*- Mode: Lisp; Package: TIMPL; Syntax: Common-Lisp -*-
;;;
;;; DEFSETF -- handle DEFSETF and DEFINE-SETF-METHOD
;;;            file contains the definitions of all forms that define setf
;;;            methods for use by the translator
;;;
;;; Author : John Gilson
;;;
;;; Copyright (c) 1990, Chestnut Software, Inc.

(in-package "TIMPL")

(himpl:note-rcs-revision
 "$Source: //gensym/ab-repos/chestnut/src/trans/lisp/defsetf.lisp,v $"
 "$Revision: 1.2 $"
 "$Date: 2007/05/21 17:34:43 $")

;;; All temporary variables that appear in either the first or third value of
;;; a setf method are generated by the function make-setf-method-temp-var

(defmacro make-temp-vars-aux (number temp-prefix temp-fn)
  (let ((temps-var (make-symbol "TEMPS"))
	(counter-var (make-symbol "COUNTER")))
    `(if (< ,number 0)
	 (error "First argument must be a non-negative integer.")
         (case ,number
	   (0 nil)
	   (1 (list (,temp-fn ,temp-prefix)))
	   (otherwise
	    (let ((,temps-var nil))
	      (dotimes (,counter-var ,number (nreverse ,temps-var))
		(push (,temp-fn
		        (sformat "~A-~D" ,temp-prefix (1+ ,counter-var)))
		      ,temps-var))))))))

(defun make-setf-method-temp-var (string)
  (let ((sym (make-symbol string)))
    (setf (symbol-plist sym) '(translator-setf-method-temp-var t))
    sym))

(defun make-setf-method-temp-vars (number temp-prefix)
  (make-temp-vars-aux number temp-prefix make-setf-method-temp-var))

(defun make-temp-vars (number temp-prefix)
  (make-temp-vars-aux number temp-prefix make-symbol))

(defun translator-setf-method-temp-var-p (sym)
  (get sym 'translator-setf-method-temp-var))

(defun copy-setf-method-temp-vars (temp-vars)
  (mapcar #'make-setf-method-temp-var
	  (mapcar #'string temp-vars)))

;;; signal an error if apply of a place is not defined as a place

(defun unknown-apply-of-place-error (access-fn)
  (error "APPLY of ~S isn't defined as a place" access-fn))

;;; bindings are not created for forms that are constants

(defun remove-bindings-if-constantp (vars forms &key env multiple-value-bind-p)
  (remove-bindings-if
    #'translator-constantp vars forms env multiple-value-bind-p))

(defun remove-bindings-if (predicate vars forms env multiple-value-bind-p)
  (if multiple-value-bind-p
      (let ((transform (apply-macros forms env)))
	(if (funcall predicate transform env)
	    (if vars
		(values
		  nil
		  nil
		  (cons transform
			(make-list (1- (length (the cons vars)))
				   :initial-element nil)))
	        (values nil transform nil))
	    (values vars transform vars)))
      (let ((new-binding-vars nil)
	    (new-binding-forms nil)
	    (new-forms nil))
        (do ((rest-of-vars vars (rest rest-of-vars))
	     (rest-of-forms forms (rest rest-of-forms)))
	    ((null rest-of-vars)
	     (values
	       (nreverse new-binding-vars)
	       (nreverse new-binding-forms)
	       (nreverse new-forms)))
	    (let ((var (first rest-of-vars))
		  (transform (apply-macros (first rest-of-forms) env)))
	      (if (funcall predicate transform env)
		  (push transform new-forms)
		  (progn
		    (push var new-binding-vars)
		    (push transform new-binding-forms)
		    (push var new-forms))))))))

(defun make-non-circular-symbol-macrolet-bindings
  (temps temp-replacement-forms)
  (let ((bindings nil))
    (mapc #'(lambda (temp temp-replacement-form)
	      (unless (eq temp temp-replacement-form)
	        (push `(,temp ,temp-replacement-form) bindings)))
	  temps temp-replacement-forms)
    (nreverse bindings)))

;;; defined-as-generalized-variable is the property used for places
;;;
;;; the value of this property is a place's setf-method expander function which
;;; is a function that takes two arguments, the place form and a translator
;;; environment, and returns a setf method

;;; DEFINE-SETF-METHOD
;;;
;;; replaces all temporary variables created in the define-setf-method form for
;;; the first or third value of a setf method with temps having mnemonic
;;; names, created with make-setf-method-temp-var, that follow the naming
;;; conventions of all other setf-method temps
;;;
;;; The body of the expander function is implicitly enclosed in a block
;;; construct whose name is the same as the name of the access function

;;; make setf-method expander function from define-setf-method form

(defmacro make-define-setf-method-expander
  (access-fn body decls doc env-var bindings access-form-var)
  (setf env-var (or env-var (make-symbol "ENV")))
  `(function
     (lambda (,access-form-var ,env-var)
       ,@(if doc (list doc) nil)
       (when (eq (first ,access-form-var) 'apply)
	 (unknown-apply-of-place-error ',access-fn))
       (multiple-value-bind
	 (temps value-forms store-vars storing-form accessing-form)
	 (let* ,bindings
	   ,@(if decls `((declare ,@decls)) nil)
	   (block ,access-fn
	     ,@body))
	 (let* ((old-temps nil)
		(replacement-temps
		  (prog1
		    (make-setf-method-temp-vars
		      (count-if #'(lambda (temp)
				    (unless (translator-setf-method-temp-var-p
					      temp)
				      (push temp old-temps)
				      t))
				(the list temps))
		      ,(sformat "~A-ARG" access-fn))
		    (setf old-temps (nreverse old-temps))))
		(new-temps
		  (let ((copy-replacement-temps (copy-list replacement-temps)))
		    (mapcar #'(lambda (temp)
				(if (translator-setf-method-temp-var-p temp)
				    temp
				    (pop copy-replacement-temps)))
			    temps)))
		(new-store-vars
		  (make-setf-method-temp-vars
		    (length (the list store-vars))
		    ,(sformat "~A-NEW-VALUE" access-fn))))
	   (multiple-value-bind
	     (actual-temps actual-value-forms old-temp-replacement-forms)
	     (remove-bindings-if-constantp new-temps value-forms :env ,env-var)
	     (let ((old-temp-bindings
		     (make-non-circular-symbol-macrolet-bindings
		       old-temps old-temp-replacement-forms))
		   (old-store-var-bindings
		     (make-non-circular-symbol-macrolet-bindings
		       store-vars new-store-vars)))
	       (values
		 ;; temps
		 actual-temps
		 ;; value forms
		 actual-value-forms
		 ;; store variables
		 new-store-vars
		 ;; storing form
		 `(symbol-macrolet ,(append old-temp-bindings
					    old-store-var-bindings)
		    ,storing-form)
		 ;; accessing form
		 `(symbol-macrolet ,old-temp-bindings
		    ,accessing-form)))))))))

(define-translator-macro define-setf-method (access-fn lambda-list &body body)
  (multiple-value-bind (real-body decls doc)
      (parse-body body t)
    (multiple-value-bind (env-var rest-of-lambda-list)
	(tutil::extract-environment lambda-list)
      (multiple-value-bind (bindings access-form-var)
	  (destructure rest-of-lambda-list)
	`(progn
	   (eval-when (compile)
	     (print-progress-message "Generalized variable" ',access-fn)
	     (setf (simple-setf-update-function ',access-fn) nil)
	     (setf (defined-as-generalized-variable ',access-fn)
		   (make-define-setf-method-expander
		    ,access-fn ,real-body ,decls ,doc ,env-var ,bindings
		    ,access-form-var)))
	   (eval-when (load eval)
	     ',access-fn))))))

;;; DEFINE-TRANSLATOR-SETF-METHOD
;;;
;;; the lambda-list specified becomes the lambda-list for this place's
;;; setf-method expander function so the setf method for
;;; (apply #'<access-fn> ...) can also be defined
;;;
;;; the body of the expander function is implicitly enclosed in a block
;;; construct whose name is the same as the name of the access function

;;; make setf-method expander function from define-translator-setf-method form

(defmacro make-define-translator-setf-method-expander
    (access-fn lambda-list env-var body decls doc)
  `(function
    (lambda ,lambda-list
     ,@(if doc (list doc) nil)
     ,@(if decls `((declare ,@decls)) nil)
     (multiple-value-bind
	   (temps value-forms store-vars storing-form accessing-form
		  temps-types store-vars-types store-values-types)
	 (block ,access-fn
	   ,@body)
       (multiple-value-bind
	     (actual-temps actual-value-forms old-temp-replacement-forms)
	   (remove-bindings-if-constantp temps value-forms :env ,env-var)
	 (let ((old-temp-bindings
		(make-non-circular-symbol-macrolet-bindings
		 temps old-temp-replacement-forms)))
	   (values
	    ;; temps
	    actual-temps
	    ;; value forms
	    actual-value-forms
	    ;; store variables
	    store-vars
	    ;; storing form
	    `(symbol-macrolet ,old-temp-bindings
			      ,storing-form)
	    ;; accessing form
	    `(symbol-macrolet ,old-temp-bindings
			      ,accessing-form)
	    ;; temps types
	    (mapcar #'(lambda (actual-temp)
			(nth (position actual-temp temps) temps-types))
		    actual-temps)
	    ;; store variables types
	    store-vars-types
	    ;; store values types
	    store-values-types)))))))

(defmacro define-translator-setf-method
    (access-fn lambda-list &body body &aux (env-var (second lambda-list)))
  (multiple-value-bind (real-body decls doc)
      (parse-body body t)
    `(progn
       (setf (simple-setf-update-function ',access-fn) nil)
       (setf (defined-as-generalized-variable ',access-fn)
	     (make-define-translator-setf-method-expander
	      ,access-fn ,lambda-list ,env-var ,real-body ,decls ,doc)))))

;;; DEFSETF

;;; make setf-method expander function from simple defsetf or
;;; translator-defsetf form
;;;
;;; *** side-effecting-access-function-p will be used for temp removal

(defmacro num-access-fn-args-in-update-fn
  (access-fn-arg-count ignore-place-default-value-p)
  `(if ,ignore-place-default-value-p
       (1- ,access-fn-arg-count)
       ,access-fn-arg-count))

(defmacro make-augmented-simple-defsetf-expander
  (access-fn update-fn doc type new-value-type access-fn-arg-count
   ignore-place-default-value-p
   side-effecting-access-function-p)
  ;; *** remove when temp removal is in place
  (declare (ignore side-effecting-access-function-p))
  `(function
     (lambda (access-form env)
       ,@(if doc (list doc) nil)
       (if (eq (first access-form) 'apply)
	   ;; make setf method for apply of access function
	   (let* ((apply-args (cddr access-form))
		  (temps
		    (make-setf-method-temp-vars
		      (length (the cons apply-args))
		      ,(sformat "APPLY-OF-~A-ARG" access-fn)))
		  (store-var
		    (make-setf-method-temp-var
		      ,(sformat "APPLY-OF-~A-NEW-VALUE" access-fn))))
	     (multiple-value-bind
	       (actual-temps actual-apply-args temps&apply-args)
	       (remove-bindings-if-constantp temps apply-args :env env)
	       (values
		 ;; temps
		 actual-temps
		 ;; value forms
		 actual-apply-args
		 ;; store variable
		 (list store-var)
		 ;; storing form
		 ,(case type
		    (:l-value
		     `(make-l-value-apply-storing-form
			',update-fn
			temps&apply-args
			store-var
			',new-value-type
			,(num-access-fn-args-in-update-fn
			   access-fn-arg-count ignore-place-default-value-p)))
		    (:store-function-new-value-last
		     `(make-store-function-new-value-last-apply-storing-form
		        ',update-fn
			temps&apply-args
			store-var
			',new-value-type
			,(num-access-fn-args-in-update-fn
			   access-fn-arg-count ignore-place-default-value-p)))
		    (:store-function-new-value-first
		     `(make-store-function-new-value-first-apply-storing-form
		        ',update-fn temps&apply-args store-var
			',new-value-type))
		    (:simple-defsetf
		     `(make-simple-defsetf-apply-storing-form
		        ',update-fn temps&apply-args store-var)))
		 ;; accessing form
		 ,(case type
		    ((:l-value :store-function-new-value-last)
		     `(make-non-apply-accessing-form-from-apply
		        ',access-fn
			temps&apply-args
			',new-value-type
			,access-fn-arg-count))
		    (otherwise
		     `(make-aug-simple-defsetf-apply-accessing-form
		        ',access-fn temps&apply-args ',new-value-type))))))
	   ;; make setf method for access function
	   (let* ((value-forms
		    ,(if access-fn-arg-count
			 `(let ((num-of-args
				  (length (the list (rest access-form)))))
			    (cond ((eql num-of-args ,access-fn-arg-count)
				   (rest access-form))
				  ((< num-of-args ,access-fn-arg-count)
				   (append (rest access-form)
					   (make-list
					     (- ,access-fn-arg-count
						num-of-args)
					     :initial-element nil)))
				  (t
				   (error
				     "The place ~S has too many arguments."
				     access-form))))
		         `(rest access-form)))
		  (temps
		    (make-setf-method-temp-vars
		      (length (the list value-forms))
		      ,(sformat "~A-ARG" access-fn)))
		  (store-var
		    (make-setf-method-temp-var
		      ,(sformat "~A-NEW-VALUE" access-fn))))
	     (multiple-value-bind
	       (actual-temps actual-value-forms temps&value-forms)
	       (remove-bindings-if-constantp temps value-forms :env env)
	       (values
		 ;; temps
		 actual-temps
		 ;; value forms
		 actual-value-forms
		 ;; store variable
		 (list store-var)
		 ;; storing form
		 ,(case type
		    (:l-value
		     `(let ((ignored-place-default-value-temp
			      ,(when ignore-place-default-value-p
				 `(first (last temps)))))
			(make-l-value-storing-form
			  ',update-fn
			  temps&value-forms
			  store-var
			  (when ignored-place-default-value-temp
			    (first
			      (member ignored-place-default-value-temp
				      actual-temps
				      :test #'eq)))
			  ,ignore-place-default-value-p
			  ',new-value-type)))
		    (:store-function-new-value-last
		     `(let ((ignored-place-default-value-temp
			      ,(when ignore-place-default-value-p
				 `(first (last temps)))))
			(make-store-function-new-value-last-storing-form
			  ',update-fn
			  temps&value-forms
			  store-var
			  (when ignored-place-default-value-temp
			    (first
			      (member ignored-place-default-value-temp
				      actual-temps
				      :test #'eq)))
			  ,ignore-place-default-value-p
			  ',new-value-type)))
		    (:store-function-new-value-first
		     `(make-store-function-new-value-first-storing-form
		        ',update-fn temps&value-forms store-var
			',new-value-type))
		    (:simple-defsetf
		     `(make-simple-defsetf-storing-form
		        ',update-fn temps&value-forms store-var)))
		 ;; accessing form
		 (make-aug-simple-defsetf-accessing-form
		   ',access-fn temps&value-forms ',new-value-type))))))))

;;; make setf-method expander function from simple form of defsetf

(defmacro make-simple-defsetf-expander (access-fn update-fn doc)
  `(make-augmented-simple-defsetf-expander
     ,access-fn ,update-fn ,doc :simple-defsetf t nil nil nil))

(defmacro translator-simple-defsetf (access-fn update-fn &optional doc)
  `(progn
     (setf (simple-setf-update-function ',access-fn) ',update-fn)
     (setf (defined-as-generalized-variable ',access-fn)
	   (make-simple-defsetf-expander ,access-fn ,update-fn ,doc))))

(defun make-simple-defsetf (access-fn update-fn doc)
  `(progn
     (eval-when (compile)
       (print-progress-message "Generalized variable" ',access-fn)
       (translator-simple-defsetf ,access-fn ,update-fn ,doc))
     (eval-when (load eval)
       ',access-fn)))

(defmacro simple-defsetf-p (body)
  `(let ((third-arg (cadr ,body)))
     (or (null third-arg) (stringp third-arg))))

(define-translator-macro defsetf (access-fn &body body &environment env)
  (if (simple-defsetf-p body)
      (make-simple-defsetf access-fn (first body) (second body))
      (let ((lambda-list (first body))
	    (store-vars (second body))
	    (body (cddr body)))
	(multiple-value-bind (real-body decls doc)
	  (parse-body body t)
	  (make-complex-defsetf access-fn lambda-list store-vars real-body
				decls doc env)))))

;;; TRANSLATOR-DEFSETF
;;;
;;; The following arguments are accepted by TRANSLATOR-DEFSETF :
;;;
;;; ACCESS-FN : name of access function
;;;
;;; TYPE : known types are :L-VALUE, :STORE-FUNCTION-NEW-VALUE-LAST, and
;;;        :STORE-FUNCTION-NEW-VALUE-FIRST
;;;        this describes the type of storing form to be made for ACCESS-FN
;;;
;;; UPDATE-FN : if TYPE is :STORE-FUNCTION-NEW-VALUE-LAST or
;;;             :STORE-FUNCTION-NEW-VALUE-FIRST then this gives the name of
;;;             the RTL store function that will update this place
;;;             if TYPE is :L-VALUE then this gives the name of a dummy setter
;;;             function that will be handled as an inline accessor-call
;;;             assignment
;;;
;;; NEW-VALUE-TYPE : the type of the new-value form
;;;
;;; ACCESS-FN-ARG-COUNT :
;;;  If all the arguments to an access function can be extracted from an
;;;  argument list simply by using list access functions (this would be
;;;  arguments that are required and those that are optional with a default
;;;  value of nil), then the number of arguments is given. In general,
;;;  (setf (apply #'access-fn ...) new-value) expands into basically
;;;  (apply #'store-fn new-value ...). However, in some cases, the expansion
;;;  doesn't need to include a call to apply, e.g.,
;;;  (setf (apply #'subseq x) new-value) =>
;;;  (set-subseq (first x) (second x) (third x) new-value)
;;;  because the ACCESS-FN-ARG-COUNT of subseq is three.
;;;  In the case of get and gethash, the third (optional) argument is ignored
;;;  by the update function, i.e., (setf (get x y z) new-value) =>
;;;  (set-get x y new-value) but the ACCESS-FN-ARG-COUNT of get and gethash is
;;;  three. TRANSLATOR-DEFSETF assumes that ACCESS-FN-ARG-COUNT can be
;;;  specified for all places of type :L-VALUE or
;;;  :STORE-FUNCTION-NEW-VALUE-LAST.
;;;
;;; IGNORE-PLACE-DEFAULT-VALUE-P :
;;;  This is t if the last argument to an access function is to be ignored by
;;;  its update function because it represents the place's default value and is
;;;  therefore unnecessary in a call to an update function. If it has not been
;;;  removed, the temporary variable that is bound to this value will appear
;;;  in the place's storing form in a void context to avoid an unreferenced-
;;;  binding warning during translation. The ignored default-value argument is
;;;  included in the ACCESS-FN-ARG-COUNT for the access function. This
;;;  argument is t for get and gethash. TRANSLATOR-DEFSETF allows this
;;;  argument to be specified with places of type :L-VALUE or
;;;  :STORE-FUNCTION-NEW-VALUE-LAST.
;;;
;;; SIDE-EFFECTING-ACCESS-FUNCTION-P : t if ACCESS-FN is side effecting
;;;
;;; DOC : documentation string

;;; make setf-method expander function from translator-defsetf form based on
;;; the specified type

(defmacro make-l-value-expander
  (access-fn update-fn doc new-value-type access-fn-arg-count
   ignore-place-default-value-p)
  `(make-augmented-simple-defsetf-expander
     ,access-fn ,update-fn ,doc :l-value ,new-value-type
     ,(or access-fn-arg-count 1)
     ,ignore-place-default-value-p
     t))

(defmacro make-store-function-new-value-last-expander
  (access-fn update-fn doc new-value-type access-fn-arg-count
   ignore-place-default-value-p
   side-effecting-access-function-p)
  `(make-augmented-simple-defsetf-expander
     ,access-fn ,update-fn ,doc :store-function-new-value-last ,new-value-type
     ,access-fn-arg-count ,ignore-place-default-value-p
     ,side-effecting-access-function-p))

(defmacro make-store-function-new-value-first-expander
  (access-fn update-fn doc new-value-type side-effecting-access-function-p)
  `(make-augmented-simple-defsetf-expander
     ,access-fn ,update-fn ,doc :store-function-new-value-first
     ,new-value-type nil nil ,side-effecting-access-function-p))

(defmacro make-translator-defsetf
    (access-fn &key type update-fn (new-value-type t) access-fn-arg-count
	       ignore-place-default-value-p
	       side-effecting-access-function-p
	       doc)
  `(progn
     (setf (simple-setf-update-function ',access-fn) nil)
     ,(case type
	    (:l-value
	     `(setf (defined-as-generalized-variable ',access-fn)
		    (make-l-value-expander
		     ,access-fn ,update-fn ,doc ,new-value-type
		     ,(or access-fn-arg-count 1)
		     ,ignore-place-default-value-p)))
	    (:store-function-new-value-last
	     `(setf (defined-as-generalized-variable ',access-fn)
		    (make-store-function-new-value-last-expander
		     ,access-fn ,update-fn ,doc ,new-value-type
		     ,access-fn-arg-count ,ignore-place-default-value-p
		     ,side-effecting-access-function-p)))
	    (:store-function-new-value-first
	     `(setf (defined-as-generalized-variable ',access-fn)
		    (make-store-function-new-value-first-expander
		     ,access-fn ,update-fn ,doc ,new-value-type
		     ,side-effecting-access-function-p)))
	    (otherwise
	     (error "~S is an unknown TRANSLATOR-DEFSETF type." type)))))

(defmacro translator-defsetf (&rest args)
  `(make-translator-defsetf ,@args))

;;; define a version of TRANSLATOR-DEFSETF to be used at translation time
;;;
;;; this is useful in making structure access functions setf-able l-values

(define-translator-macro translator-defsetf (&rest args)
  `(progn
     (eval-when (compile)
       (print-progress-message "Generalized variable" ',(first args))
       (make-translator-defsetf ,@args))
     (eval-when (load eval)
       ',(first args))))

;;; functions that create the storing forms and accessing forms for the setf
;;; methods of places defined with translator-defsetf or the simple form of
;;; defsetf

(defun make-l-value-apply-storing-form
  (update-fn temps&apply-args store-var new-value-type
	     num-access-fn-args-to-extract)
  `(the ,new-value-type
     (,update-fn ,@(extract-forms-from-apply-args
		     temps&apply-args num-access-fn-args-to-extract)
		 (the ,new-value-type ,store-var))))

(defun make-store-function-new-value-last-apply-storing-form
  (update-fn temps&apply-args store-var new-value-type
   num-access-fn-args-to-extract)
  `(the ,new-value-type
     (,update-fn ,@(extract-forms-from-apply-args
		     temps&apply-args num-access-fn-args-to-extract)
		 (the ,new-value-type ,store-var))))

(defun make-store-function-new-value-first-apply-storing-form
  (update-fn temps&apply-args store-var new-value-type)
  `(the ,new-value-type
     (apply (function ,update-fn)
	    (the ,new-value-type ,store-var) ,@temps&apply-args)))

(defun make-simple-defsetf-apply-storing-form
  (update-fn temps&apply-args store-var)
  `(apply (function ,update-fn)
	  ,@(butlast temps&apply-args)
	  (append ,(first (last temps&apply-args)) (list ,store-var))))

(defun make-non-apply-accessing-form-from-apply
  (access-fn temps&apply-args new-value-type access-fn-arg-count)
  `(the ,new-value-type
     (,access-fn ,@(extract-forms-from-apply-args
		     temps&apply-args
		     access-fn-arg-count))))

(defun make-aug-simple-defsetf-apply-accessing-form
  (access-fn temps&apply-args new-value-type)
  `(the ,new-value-type	(apply (function ,access-fn) ,@temps&apply-args)))

(defun make-l-value-storing-form
  (update-fn temps&value-forms store-var ignored-place-default-value-temp
	     ignore-place-default-value-p new-value-type)
  `(progn
     ,ignored-place-default-value-temp
     (the ,new-value-type
       (,update-fn
	 ,@(if ignore-place-default-value-p
	       (butlast temps&value-forms)
	       temps&value-forms)
	 (the ,new-value-type ,store-var)))))

(defun make-store-function-new-value-last-storing-form
  (update-fn temps&value-forms store-var
   ignored-place-default-value-temp ignore-place-default-value-p
   new-value-type)
  `(progn
     ,ignored-place-default-value-temp
     (the ,new-value-type
       (,update-fn
	 ,@(if ignore-place-default-value-p
	       (butlast temps&value-forms)
	       temps&value-forms)
	 (the ,new-value-type ,store-var)))))

(defun make-store-function-new-value-first-storing-form
  (update-fn temps&value-forms store-var new-value-type)
  `(the ,new-value-type
     (,update-fn (the ,new-value-type ,store-var) ,@temps&value-forms)))

(defun make-simple-defsetf-storing-form (update-fn temps&value-forms store-var)
  `(,update-fn ,@temps&value-forms ,store-var))

(defun make-aug-simple-defsetf-accessing-form
  (access-fn temps&value-forms new-value-type)
  `(the ,new-value-type	(,access-fn ,@temps&value-forms)))

;;; make setf-method expander function from complex defsetf form
;;;
;;; this extends the complex defsetf form defined in CLtL in that it allows
;;; multiple store variables to be specified

(defmacro make-complex-defsetf-setf-method-for-apply
  (access-form-var access-fn lambda-list store-vars body decls)
  ;; make setf method for apply of access function when the storing form is
  ;; defined using the complex form of defsetf
  ;;
  ;; care needs to be taken in defining the storing form of a place that will
  ;; be used with apply because all lambda-list parameters, including the
  ;; &rest parameter and supplied-p parameters, are bound to temps so if we
  ;; defined a new place with the form
  ;; (defsetf place (a &rest b) (new-value)
  ;;   `(set-place ,new-value ,a ,@b))
  ;; we could not use apply with this place because the parameter b will
  ;; evaluate to a temp (the temp is bound to the &rest list) and not to the
  ;; &rest list itself
  (let ((new-lambda-list-var (make-symbol "NEW-LAMBDA-LIST"))
	(lambda-list-temps-var (make-symbol "LAMBDA-LIST-TEMPS"))
	(apply-args-var (make-symbol "APPLY-ARGS"))
	(apply-args-var-var (make-symbol "APPLY-ARGS-VAR"))
	(bindings-var (make-symbol "BINDINGS"))
	(store-temps-var (make-symbol "STORE-TEMPS")))
    `(multiple-value-bind (,new-lambda-list-var ,lambda-list-temps-var)
       (copy-lambda-list-w/-temps
	 ',lambda-list t ,(sformat "~A-ARG" access-fn))
       (let* ((,apply-args-var (cddr ,access-form-var))
	      (,apply-args-var-var
	        (make-setf-method-temp-var
		  ,(sformat "APPLY-OF-~A-ARGS" access-fn)))
	      (,bindings-var
	        (nreverse
		  (destructure-aux
		    ,new-lambda-list-var
		    ,apply-args-var-var
		    `((,,apply-args-var-var
		        (list* ,@,apply-args-var)))
		    nil)))
	      (,store-temps-var
	        (make-setf-method-temp-vars
		  ,(length (the list store-vars))
		  ,(sformat "APPLY-OF-~A-NEW-VALUE" access-fn))))
	 (values
	   ;; temps
	   (mapcar #'first ,bindings-var)
	   ;; value forms
	   (mapcar #'second ,bindings-var)
	   ;; store variables
	   ,store-temps-var
	   ;; storing form
	   (apply #'(lambda ,(apply #'append
				    store-vars
				    (multiple-value-list
				      (get-function-params
				        lambda-list :include-svars-p t)))
		      ,@(if decls `((declare ,@decls)) nil)
		      (block ,access-fn
			,@body))
		  (append ,store-temps-var ,lambda-list-temps-var))
	   ;; accessing form
	   `(apply (function ,',access-fn) ,,apply-args-var-var))))))

(defmacro make-complex-defsetf-setf-method
  (access-form-var access-fn lambda-list req-params optional-params key-params
   env-var store-vars body decls env)
  ;; make setf method for access function when the storing form is defined
  ;; using the complex form of defsetf
  (let ((arglist-var (make-symbol "ARGLIST"))
	(arg-num-counter-var (make-symbol "ARG-NUM-COUNTER"))
	(keyword-flag-var (make-symbol "KEYWORD-FLAG"))
	(actual-temps-var (make-symbol "ACTUAL-TEMPS"))
	(actual-value-forms-var (make-symbol "ACTUAL-VALUE-FORMS"))
	(store-temps-var (make-symbol "STORE-TEMPS"))
	(temps&value-forms-var (make-symbol "TEMPS&VALUE-FORMS")))
    `(let ((,arglist-var (rest ,access-form-var))
	   (,store-temps-var
	     (make-setf-method-temp-vars
	       ,(length (the list store-vars))
	       ,(sformat "~A-NEW-VALUE" access-fn))))
       (multiple-value-bind
	 (,actual-temps-var ,actual-value-forms-var ,temps&value-forms-var)
	 ,(if key-params
	      `(remove-bindings-if
		 ,(let ((num-non-key-args
			  (+ (length (the list req-params))
			     (length (the list optional-params)))))
		    `(let ((,arg-num-counter-var 0)
			   ,keyword-flag-var)
		       #'(lambda (expanded-value-form env)
			   (cond ((< ,arg-num-counter-var ,num-non-key-args)
				  (incf ,arg-num-counter-var)
				  (translator-constantp
				    expanded-value-form env))
				 ((eql ,arg-num-counter-var ,num-non-key-args)
				  (incf ,arg-num-counter-var)
				  (setf ,keyword-flag-var nil)
				  t)
				 (t (prog1
				      (if ,keyword-flag-var
					  t
					  (translator-constantp
					    expanded-value-form env))
				      (setf ,keyword-flag-var
					    (not ,keyword-flag-var))))))))
		 (make-setf-method-temp-vars
		   (length (the list ,arglist-var))
		   ,(sformat "~A-ARG" access-fn))
		 ,arglist-var
		 ,env-var
		 nil)
	      `(remove-bindings-if-constantp
		 (make-setf-method-temp-vars
		   (length (the list ,arglist-var))
		   ,(sformat "~A-ARG" access-fn))
		 ,arglist-var
		 :env ,env-var))
	 (values
	   ;; temps
	   ,actual-temps-var
	   ;; value forms
	   ,actual-value-forms-var
	   ;; store variables
	   ,store-temps-var
	   ;; storing form
	   ,(multiple-value-bind (v-decls f-decls set-r-decls r-decls)
	      (translator-parse-declarations decls env :variable store-vars)
	      (declare (ignore f-decls set-r-decls r-decls))
	      (multiple-value-bind (appl-decls non-appl-decls)
		(collect-applicable-decls store-vars v-decls)
		`(destructuring-bind ,lambda-list ,temps&value-forms-var
		   (declare ,@non-appl-decls)
		   (destructuring-bind ,store-vars ,store-temps-var
		     (declare ,@appl-decls)
		     (block ,access-fn
		       ,@body)))))
	   ;; accessing form
	   `(,',access-fn ,@,temps&value-forms-var))))))

(defmacro make-complex-defsetf-expander
  (access-fn lambda-list req-params optional-params key-params store-vars body
   decls doc env)
  (let ((access-form-var (make-symbol "ACCESS-FORM"))
	(env-var (make-symbol "ENV-VAR")))
    `(function
       (lambda (,access-form-var ,env-var)
	 ,@(if doc (list doc) nil)
	 (if (eq (first ,access-form-var) 'apply)
	     (make-complex-defsetf-setf-method-for-apply
	       ,access-form-var ,access-fn ,lambda-list ,store-vars ,body
	       ,decls)
	     (make-complex-defsetf-setf-method
	       ,access-form-var ,access-fn ,lambda-list ,req-params
	       ,optional-params ,key-params ,env-var ,store-vars ,body ,decls
	       ,env))))))

(defun make-complex-defsetf
    (access-fn lambda-list store-vars body decls doc env)
  (multiple-value-bind (req-params optional-params rest-param key-params)
      (get-function-params lambda-list)
    (declare (ignore rest-param))
    `(progn
       (eval-when (compile)
	 (print-progress-message "Generalized variable" ',access-fn)
	 (setf (simple-setf-update-function ',access-fn) nil)
	 (setf (defined-as-generalized-variable ',access-fn)
	       (make-complex-defsetf-expander
		,access-fn ,lambda-list ,req-params ,optional-params
		,key-params ,store-vars ,body ,decls ,doc ,env)))
       (eval-when (load eval)
	 ',access-fn))))

;;; utility functions


;;; function takes a lambda list (non-destructured) that can have required,
;;; optional, rest, and key parameters and returns those parameters and a list
;;; of keywords (a keyword and a key parameter are not necessarily the same,
;;; e.g, in the lambda-list (&key ((:x y))) the key parameter is y and the
;;; keyword is :x)

(defun get-function-params (lambda-list &key include-svars-p
					     key-args-not-allowed-p
					     return-keywords-p)
  (let ((context :required)
	(req-params nil)
	(optional-params nil)
	(rest-param nil)
	(key-params nil)
	(keywords nil))
    (dolist (lambda-list-elt lambda-list
			     (if return-keywords-p
				 (values (nreverse req-params)
					 (nreverse optional-params)
					 rest-param
					 (nreverse key-params)
					 (nreverse keywords))
			         (values (nreverse req-params)
					 (nreverse optional-params)
					 rest-param
					 (nreverse key-params))))
      (cond ((or (eq lambda-list-elt '&optional) (eq lambda-list-elt '&rest))
	     (setf context lambda-list-elt))
	    ((eq lambda-list-elt '&key)
	     (when key-args-not-allowed-p
	       (error "Keyword arguments are not permitted in lambda-list : ~S"
		      lambda-list))
	     (setf context lambda-list-elt))
	    ((symbolp lambda-list-elt)
	     (case context
	       (:required (push lambda-list-elt req-params))
	       (&optional (push lambda-list-elt optional-params))
	       (&rest (push lambda-list-elt rest-param))
	       (&key (push lambda-list-elt key-params)
		     (when return-keywords-p
		       (push (tutil::keywordify lambda-list-elt) keywords)))))
	    (t
	      (let ((svar (third lambda-list-elt)))
		(if (eq context '&optional)
		    (if (and include-svars-p svar)
			(progn (push (first lambda-list-elt) optional-params)
			       (push svar optional-params))
		        (push (first lambda-list-elt) optional-params))
		    (let ((key-param-spec (first lambda-list-elt)))
		      (if (symbolp key-param-spec)
			  (progn
			    (when return-keywords-p
			      (push (tutil::keywordify key-param-spec)
				    keywords))
			    (if (and include-svars-p svar)
				(progn (push key-param-spec key-params)
				       (push svar key-params))
			        (push key-param-spec key-params)))
			  (progn
			    (when return-keywords-p
			      (push (first key-param-spec) keywords))
			    (if (and include-svars-p svar)
				(progn (push (second key-param-spec)
					     key-params)
				       (push svar key-params))
			        (push (second key-param-spec)
				      key-params))))))))))))

(defmacro make-lambda-list-temp
  (gen-setf-method-temp-p setf-method-temp-string lambda-list-temp-string
			  use-suffix-p suffix)
  `(if ,gen-setf-method-temp-p
       (make-setf-method-temp-var
	 (if ,use-suffix-p
	     (sformat "~A-~A" ,setf-method-temp-string ,suffix)
	     ,setf-method-temp-string))
       (make-symbol ,lambda-list-temp-string)))

;;; make a copy of a lambda-list (non-destructured that can have required,
;;; optional, rest, and key parameters) using temporary variables, possibly
;;; setf method temps

(defun copy-lambda-list-w/-temps
  (lambda-list gen-setf-method-temps-p &optional setf-method-temp-string)
  (let ((new-lambda-list nil)
	(mappings nil)
	(use-param-num-p (more-than-one-lambda-list-param-p lambda-list))
	(param-num 0))
    (dolist (lambda-list-elt lambda-list (values (nreverse new-lambda-list)
						 (nreverse
						   (mapcar
						     #'second mappings))))
      (cond ((or (eq lambda-list-elt '&optional) (eq lambda-list-elt '&rest)
		 (eq lambda-list-elt '&key))
	     (push lambda-list-elt new-lambda-list))
	    ((symbolp lambda-list-elt)
	     (incf param-num)
	     (let ((temp
		     (make-lambda-list-temp gen-setf-method-temps-p
					    setf-method-temp-string
					    (string lambda-list-elt)
					    use-param-num-p
					    param-num)))
	       (push `(,lambda-list-elt ,temp) mappings)
	       (push temp new-lambda-list)))
	    (t
	      (let ((param (if (atom (first lambda-list-elt))
			       (first lambda-list-elt)
			       (second (first lambda-list-elt))))
		    (initform (second lambda-list-elt))
		    (svar (third lambda-list-elt)))
		(incf param-num)
		(let* ((temp-param
		         (make-lambda-list-temp gen-setf-method-temps-p
						setf-method-temp-string
						(string param)
						use-param-num-p
						param-num))
		       (temp-svar
			 (if svar
			     (make-lambda-list-temp gen-setf-method-temps-p
						    (string temp-param)
						    (string svar)
						    t "P")))
		       (new-initform
		         (cond ((constantp initform) initform)
			       ((symbolp initform)
				(let ((mapping (assoc initform mappings)))
				  (if mapping
				      (second mapping)
				      initform)))
			       (t `(symbol-macrolet ,(copy-list mappings)
				     ,initform)))))
		  (push `(,param ,temp-param) mappings)
		  (if svar (push `(,svar ,temp-svar) mappings))
    		  (push `(,(if (atom (first lambda-list-elt))
			       temp-param
			       `(,(first (first lambda-list-elt))
				 ,temp-param))
			  ,new-initform
			  ,@(if svar `(,temp-svar) nil))
			new-lambda-list))))))))

(defun more-than-one-lambda-list-param-p (lambda-list)
  (let ((lambda-list-elt (first lambda-list)))
    (if (or (eq lambda-list-elt '&optional) (eq lambda-list-elt '&rest)
	    (eq lambda-list-elt '&key))
	(if (cddr lambda-list) t nil)
        (if (rest lambda-list) t nil))))

(defun extract-forms-from-apply-args
  (apply-args num-of-forms &optional
	                   (num-of-apply-args (length (the cons apply-args)))
			   result
			   (counter 0)
			   &aux temp)
  (cond ((eq num-of-forms 0) (nreverse result))
	((eq num-of-apply-args 1)
	 (extract-forms-from-apply-args
	   apply-args (1- num-of-forms) 1
	   (push (if (setf temp
			   (nth counter '(first second third fourth fifth
					  sixth seventh eigth ninth tenth)))
		     `(,temp ,(first apply-args))
		     `(nth ,counter ,(first apply-args)))
		 result)
	   (1+ counter)))
	(t
	  (extract-forms-from-apply-args
	    (rest apply-args) (1- num-of-forms)
	    (1- num-of-apply-args) (push (first apply-args) result)))))

(defun collect-applicable-decls (names parsed-decls)
  (let ((applicable nil)
	(non-applicable nil))
    (dolist (parsed-decl parsed-decls (values (nreverse applicable)
					      (nreverse non-applicable)))
      (if (member (first parsed-decl) names :test #'equal)
	  (push parsed-decl applicable)
	  (push parsed-decl non-applicable)))))

